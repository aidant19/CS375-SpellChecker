 analysis of algorithms cs  fall  project  due in part by monday oct    and in part by thursday nov     please see notes and descriptions below project  algorithm design and explanation loop invariants exhaustive search and beyond in this assignment you'll work in teams of four to design multiple algorithms to use loop invariants to understand and explain algorithms and to create and deliver a presentation about some of the algorithms you designed  the goals of this project are to give you practice designing algorithms starting here with exhaustive search algorithms  and improving the efficiency of algorithms to give you practice using loop invariants to explain algorithm correctness to give you practice creating and giving a technical presentation and to give you practice working with other students as a team  the project assignment this project is a multi-part assignment with different deadlines for different parts the deadline for part  is oct    and the deadline for parts  is nov   see section  below  as an overview here are the parts of the project assignment as presented in class on oct    design exhaustive search algorithms your team will collectively design ex- haustive search algorithms for a variety of problems with specifications given below   improve time efficiency your team will pick one of the problems and make your exhaustive search algorithm more efficient   reduction for the same problem chosen for part  above yes make sure it's the same one you will reduce that problem to one of the other problems given in part   this is a new topic for us more about it soon  create and give a presentation your team will present work from all three other parts of the assignment about the problem you chose for parts  and  above using loop invariants where appropriate to explain the correctness of your algorithms  there are things to do for each part of the assignment as described individually below    design exhaustive search algorithms for this project your team will collectively solve eight problems with exhaustive search algorithms  then you will submit revised solutions for four of those problems one on which you will focus heavily including doing a presentation and three others for which your submission will be a simpler write-up  instructions are below but as always please be in touch with any questions   independent problem solving your team has eight problems to solve grouped into three categories of related problems described in section  below  with four people in your team each of you should come up with exhaustive search algorithms to solve two of the eight problems  under these constraints each person in your team should solve two problems but they cannot be from the same category  your team of four people should collectively solve all eight problems each person solving two of the eight  once you've met as a team to divide the eight problems among the four of you please work fully individually on these exhaustive search algorithms not discussing them with anyone but your tas and prof  and not using any additional resources other than your clrs textbook  there is of course a reason for this more about this below each individual on the team will individually submit their two algorithms to their sub- mitted work folder  this will be graded as a smaller assignment for the individual submit- ter not part of the project grade and graded based on effort  full credit will be given for strong demonstrated effort regardless of whether or not the solutions are correct   team problem solving once each team member has submitted their two algorithms your entire team should meet to discuss the algorithms  part of the point of this is to give and receive constructive feedback to  from teammates about algorithm design as you're reading over each other's work having not seen it before  if you have worked together on the initial submissions it will diminish the value of this part of the project  then for your team's final project submission your team will work together to revise and write up algorithms for three of the original eight problems keeping in mind the following your three problems must notinclude the problem on which you're doing your pre- sentation  your three problems must include one from each category in section  below  each of your three algorithms should be presented as pseudocode with a short english description of how the algorithm works and a concise high-level analysis of its time and space complexity  you do not need to give a detailed correctness argument or use loop invariants for these three algorithms   for other parts of this project your team will also work on an algorithm for a fourth of the eight problems  as described in sections  your team will improve on the time efficiency of that algorithm you will come up with a solution for it using a reduction  and you will give a presentation about it accompanied by an informative write-up that includes complexity analyses and the use of loop invariants for explaining correctness  to submit for this part of the project bypm on monday october   each individual team member should submit a document containing exhaustive search algorithms for their two of the eight problems  standard file naming conventions apply please submit your typewritten answers in a pdf file named cs projstage userid pdf where userid is replaced by your full colby userid and submit it to your submittedwork folder  bypm on thursday november   the entire team should submit a docu- ment containing their polished write-ups of algorithms for three of the eight problems as described above  please submit these typewritten answers in a pdf file named cs proj threealgos team initials pdf   additional instructions for submit- ting this threealgos document along with the remainder of your work for the project are given in section  below   improve time efficiency as mentioned in section  your team will choose one of the eight problems on which to give a presentation and focus for the other parts of this project  in the remainder of this project assignment i'll use the variable name pto refer to the problem on which your team chooses to focus just so that there's a name for it  after your team has worked together to arrive at a good exhaustive search solution for problem p in your work for part  of the project your next step will be to improve upon the time efficiency of that exhaustive search solution  in general not just for this project but in general for algorithm design there are a few ways to think of improving upon an algorithm's time efficiency  they include   you can make it somewhat faster with small-ish changes that streamline but do not substantially redesign the algorithm or change its asymptotic complexity class    you can make it much faster with a substantial redesign perhaps even giving a new algorithm altogether which might even improve its asymptotic complexity class    you can focus on special cases of the input that can be solved very efficiently  that is instead of coming up with a more efficient solution that works for allpossible inputs in the problem's specification come up with a solution that is much more efficient i e  a better asymptotic complexity class for some of the possible inputs  for example imagine that you've solved a problem with this input specification input k a positive integer  but you then come up with a much faster algorithm that will work only when kis an even number  that faster algorithm does not meet the original problem specifications but it is an improvement in the special case of an even integer input  note smaller input sizes are rarely considered special cases in this sense  if a suggested improvement is it's the same algorithm but it's super-fast on small inputs that likely is not actually a useful improvement  please see me if your team has a suggested improvement that requires looking at only very small inputs to confirm that it's worthy of including in your project write-up  presentation for this project your team will come up with improvements upon the efficiency of your original exhaustive search algorithm for problem p  you are encouraged to think of improve- ments in terms of the three ways listed above and you are especially encouraged not to restrict yourself to only the first or second of them special-case improvements can be very helpful even on very simple-seeming special cases there are no fixed criteria for this project about exactly how much you must speed up your initial exhaustive search algorithm or with the special cases approach how broadly applicable your improvements might be to cover as many cases as possible  your team can also propose up to three algorithms or modifications that improve the efficiency of your original algorithm for problem p although submitting three improvements is not necessarily better than one  ultimately your team will earn more credit on this part of the project for improvements that show more depth of thought about the problem and its solutions achieve greater time efficiency apply more broadly to possible inputs and are more thoroughly and helpfully analyzed and described but in some cases one substantial improvement might achieve that better that three small ones  i hope these criteria make intuitive sense to you  as always please feel free to ask me questions hint you are advised notto try to come up with polynomial-time solutions for the general cases of any of the eight problems presented  you might however create polynomial time solutions for special cases which you could choose to include in your write-up  presentation to submit for this part of the project in your presentation for this project your team should present not only your original exhaustive search algorithm for problem pbut also your improvements to it  in the write-up that accompanies your presentation please include the following a full description of your exhaustive search algorithm for problem p including a short english description of it pseudocode for it a concise and convincing correctness argu- ment for it using loop invariants to establish correctness and a concise high-level complexity analysis for it  english descriptions of each improvement  each description should include  sen- tences about how you came up with the ideas behind that proposed improvement  pseudocode showing what each improvement does  a concise high-level complexity analysis showing how much each improvement actually improved the time efficiency of the original exhaustive search algorithm  although you do not need to use formal definitions of asymptotic complexity in your analysis you might want to use some part of them in particular if your improvement doesn't  change the asymptotic complexity class you might describe its improvement in terms of a lower leading constant for complexity analysis  you do not necessarily need to give a separate correctness argument for your improvements although if they affect the loop invariants your team previously used to show correctness of the exhaustive search algorithm you do need to show that the improvements also solve the problem correctly which could involve a modified loop invariant  more details about your presentation and its write-up are in section  below   reduction sometimes we can incorporate solutions to previously solved problems as subroutines in an algorithm we're designing  for this project your team will do that in a specific way you'll reduce problem pto another problem  informally in general reducing problem ato problem bmeans creating an algorithm that if you plugged in a subroutine that solved problem b would immediately be able to solve problem a the algorithm reduces the task of solving problem ato the task of solving problem b  we'll call such an algorithm a reduction from atob  as a concrete very simple example which we also went over in our oct   class meeting consider problem awith these specifications input  list l c c       c n of numbers  output true if the first element of lc is  false otherwise  and consider problem bwith these specifications input  list m d d       d k of numbers  output true if the last element of mdk is  false otherwise  for these problems a reduction from atobwould take some input l remember this reduction is an algorithm for some problem a so it has to take an input intended for a  and create a new list m c that contains only the first element of l  then the reduction would use mas input to a subroutine that solved problem b  if that subroutine returned true that would mean c   do you see why  which in turn means that the first element of lis  so the reduction solving ashould return true  on the other hand if that subroutine for breturned false on input of list m that would mean cis not  so the reduction solving ashould return false   there are other possible reductions that could have worked for instance mcould in- stead have been created as m cn       c  built from all elements of lin reverse order rather than just a list with one element the rest of the reduction would have been exactly the same  for this project your team just needs to present one correct reduction  please note again that this is a very simple example your work for this project may not be quite this simple for this project your team will create a reduction from problem ptoany other of the eight problems given in the project  here is the specific way to think of it for this assignment an all-powerful creature has bestowed upon you a wonderful gift of magic they've given you seven magic subroutines one for each problem in section  other than p  that will solve each problem in o time to use one of these magic subroutines just  give it some input that matches the input specifications for the problem and then it will instantly give you a correct true or false answer for that input to that problem there's a catch though you only get to use oneof these magic subroutines any one you choose but only that one and you only get to use it once  after that all seven subroutines disappear your task is to write a new algorithm to solve problem pthat makes use of the magic subroutine of your choice  it shouldn't be an exhaustive search algorithm anymore the magic subroutine can do the hard work of exhaustive search in fact if you are careful in choosing and employing the magic subroutine you could even come up with apolynomial time algorithm for problem p recall from lecture that a polynomial time algorithm is one that is onk for some constant k  this is much faster than any exponential- or factorial-time algorithm even a large polynomial like nhas a rate of growth much slower than n  just to give a name to the problem you choose to reduce pto let's use variable qto refer to that problem i e  you'll using the magic subroutine that solves problem qas part of your reduction from ptoq  your reduction should thus transform any possible input p for problem pinto an input qfor problem q such that when you get a true or false answer about input qforq you can use that to come up with a correct true or false answer about input pfor problem p  for this part of the project in addition to creating the reduction as described above you will also do all of the following analyze the time complexity of your reduction under the assumption that the solution forqcomes in o time  for maximal credit your reduction should be in polynomial time  onk for some k but don't worry about what constant kyou use  every correct polynomial time reduction will be equally good for this project include the reduction in your presentation see section  below  be sure to include problems pand qyou're reducing from and to a short description of your reduction algorithm pseudocode is not required though you may include it if you think it helps your presentation a short explanation of correctness and a short complexity analysis  describe the reduction in the write-up document accompanying the presentation  again state the problems pand qyou're reducing from and to and give a helpfully complete description of the reduction an english description is required pseudocode is optional along with a short explanation of correctness and your complexity analysis of the reduction  your explanation of correctness does not need to use loop invariants your reduction will probably be straightforward enough that loop invariants aren't required  if your team thinks loop invariants might be a good idea to use though feel free to do so or feel free to ask me about it important note  a correct reduction must be exactly consistent with the input  output specifications for both pandq  for full credit your explanation of correctness should explicitly refer to those specifications   your presentation and accompanying write-up document will contain all the work you need to submit for this part of the project  please make sure your reduction is clearly and concisely described in the presentation itself and all helpful details for understanding the reduction are included in the write-up hint see section   for a hint that might or might not depending on your approach be useful for reductions involving problems in the social networks category   create and give a presentation at this point your team has done a lot of work on problem p  let's hear about it your team will give a technical presentation about the algorithms you've created for problem p  for your presentation create slides in powerpoint google slides or some other application of your choice and take  minutes to present all of the material needed  presentations that are too long or too short may not receive full credit too short often indicates that some important material was not well presented too long often indicates that additional preparation would have resulted in a more effective talk so it is recommended that you target a  minute presentation  if you think your talk will be much longer or shorter than that please discuss that with me i will be happy to help you find a good balance for your presentation  the default expectation is that you will record your presentation as a screen recording in zoom  if you believe another option would be better for your team please see me about it as soon as possible this is a team presentation and a class assignment so ideally the entire team would learn about all parts of the topic being presented and not only would the workload be balanced among team members but it would also appear balanced to viewers  for that reason your presentation should consist of each person presenting for roughly  minutes at a time followed by a different teammate so for example in a roughly  minute presentation each person on a four-person team would take two non-consecutive shifts of presenting for roughly  minutes each  this structure might require a conceptual topic to be split among multiple individuals in the presentation due to the impositions of time limits but that's part of the pedagogical benefit of this it encourages more people to engage with more different parts of the topic being presented  important note presentations not following this structure will not receive full credit for this assignment  if there are questions about what's expected in terms of the division among teammates of time spent presenting please let me know here are some things you should include in your presentation not necessarily in this order your exhaustive search algorithm for your exhaustive search algorithm please include an accessible description of the problem pyou solved  a high-level summary of your algorithm and how it works  a short example that you step through to give your audience a sense of what problem pis and how your algorithm works  it may be appropriate to only step through a part of an example instead of an entire one but you should do enough to fully illuminate how your algorithm works for your audience   pseudocode of the algorithm along with a correctness argument using a loop invariant   a complexity argument of the algorithm including what the worst-case and best- case complexities are and how much space is needed beyond the original input  your improvements to your exhaustive search algorithm for each of the improve- ments you're presenting please include a high-level description of the improved algorithm  a short example that you step through to give your audience a sense how the improvement differs from the original exhaustive search algorithm  once again you may not need to go through a full example but you should do enough to illuminate the differences in your improved algorithm  pseudocode of the improved algorithm along with a correctness argument  as noted above you need not use loop invariants for this though you could if you thought it was necessary but you do need to give a concise and convincing correctness argument  you can refer to your original exhaustive search algorithm and its correctness without re-explaining them  a complexity argument of the algorithm including what the worst-case and best- case complexities are and how much space is needed beyond the original input  a comparison of the complexity of your improved algorithm with that of your exhaustive search algorithm  your reduction algorithm for your reduction please include an accessible description of the problem qyou're reducing to  a high-level description of the reduction algorithm that solves p including how it uses the subroutine for qin that solution  a short example to show your audience what the reduction does transforming input to pinto input to q and using output from the subroutine for qto get a correct answer on the input to p  pseudocode of the reduction along with a correctness argument  as noted in section  above this will involve referring to the specifications of pand q  you need not use loop invariants for this just give a concise and convincing correctness argument that the reduction meets specifications and solves pcorrectly assuming the subroutine solves qcorrectly  you can refer to your original exhaustive search algorithm and its correctness without re-explaining them  worst-case time complexity and space complexity arguments for the reduction assuming the subroutine for qhaso time and space complexity  magic you should assume that your audience is at the level of cs students who are familiar with asymptotic complexity and loop invariants but are not yet experts with them  for example assume that your audience knows a set of size nhas nsubsets a list of length nhasn per- mutations and all about the relative growth rates of functions used in asymptotic complexity including knowing what polynomial time means but would need to be walked through details involving leading constants and nthresholds in definitions of asymptotic complexity   you should also assume your audience has no previous knowledge of your algorithms or any problems involved and they may not quickly grasp any subtleties  to help prepare for your presentation please look through the documents linked from cs's project assignments page some general advice on how to give good technical presentations  dale skrien shared this with his classes and i am passing it along to you a tutorial on screen recording with zoom from colby academic its  advice on setting up a good environment for a web conference using zoom from colby academic its  i'm not sure how useful this will be but i'm including it just in case  your accompanying write-up in addition to the presentation itself your team will create an accompanying write-up document which should enable your audience to under- stand the highlights of your presentation even if they do not see your talk  this document must be typed submitted in pdf and contain some important details that you may not have time to include in your talk itself  for example some small but important details of complexity arguments might not fit in the  minutes of your talk but they can be included in the write-up  for full credit your write-up must be polished well formatted for a professional technical presentation easy to read and free of grammatical errors  please see individual sections above for more information about details to include in your presentation write-up about the exhaustive search improvements and reduction algorithms  depending on the margins  font size  etc  of your document your write-up should probably be  pages in length  please keep it as concise as it can be while still containing all relevant information  if your write-up is running longer or shorter than that range please see me to check whether it contains unneeded material or too little material write-ups that are much too long or too short are not maximally effective and may not receive full credit  dress rehearsal as part of this project please schedule a dress rehearsal with me  this should be a live in-person presentation rather than on zoom the intent is to be as effective as possible in giving feedback on the organization and content of your talk rather than on using zoom technology  as in our class meetings masks will be required for our dress rehearsal meeting  if that will be problematic for any of your teammates please let me know plan on  minutes for the dress rehearsal  come to the dress rehearsal already having practiced your talk with your slides ready and your write-up ready for me to look at while you're presenting the rehearsal is a dress rehearsal not a draft rehearsal  so that the dress rehearsal time can be used as effectively as possible you are strongly encouraged to record a draft rehearsal  practice run of your talk beforehand and do a self- evaluation of how it went identifying areas of strength and room for improvement  time permitting i will be happy to give feedback on that recording during our appointment time please note there will be significant deductions to your grade if your eventual project submission includes a poor presentation including things like poor organization poor clarity of speaking or poor knowledge of the material so please use your draft rehearsals and our dress rehearsal time wisely to polish your work  i expect to schedule all dress rehearsal appointments for the afternoons of friday oct  andsaturday oct     please email me to set up an appointment and please be as flexible as possible with your availability for scheduling those will be very busy days  some suggestions for getting audiences engaged in a presentation note from your prof   dale skrien gave these suggestions to his students for his presen- tation assignments  i'm not sure that they all fully apply to this presentation but in the interest of giving you good advice about technical presentations in general i'm passing them along to you  get the audience to care about the subject  for example get the presentation started by asking a question whose answer the audience cares about  keep examples simple and focused  don't make the audience think about irrelevant things  use conversational tones in presentations  use i me and we so that the lis- tener's brain thinks it's in a conversation  garr reynolds the author of presentation zen  says the principles and techniques for creating a presentation for a conference or a keynote address have more in common with the principles and techniques behind the creation of a good documentary film or a good comic book than the creation of a conventional static business document with bullet points  something to think about regarding your presentation also from garr if the au- dience could remember only one thing and you'll be lucky if they do what do you want it to be please feel free to ask me questions about them if you'd like  submission instructions deadline pm oct   for the individual work in section  as described in that section every individual should submit typewritten answers in a pdf file named cs projstage userid pdf where userid is replaced by your full colby userid and submit it to your submittedwork folder  deadline pm nov   for all of the group work in this project a designated sub- mitter from each team should submit four items one to their google drive submittedwork folder and three by emailing them to me  the file to submit to the submittedwork folder of the designated submitter a document containing their polished write-ups of algorithms for the three problems solved for section  as described above  please submit these typewritten answers in a pdf file named cs proj threealgos team initials pdf  where initials is replaced by the initials of the team members in the group in the team assignments  e g  if eric aaron and stephanie taylor were the teammates the file from that team would be called cs proj threealgos team east pdf    the items to email to me eaaroncolby edu a pdf file with all of the slides used for the presentation  please put two slides per page as is done for cs course lecture notes and name the file cs proj slides team initials pdf   the write-up document that accompanies your presentation which should be a pdf file called cs proj writeup team initials pdf   a video file or link to it of your presentation  please put it in your google drive space if it's too large to simply include in an email  please name the file cs proj presentation team initials mp note the preferred mpformat  if for any reason you cannot submit an mpvideo please let me know as soon as possible lateness policy to keep pace with the project assignments in cs it is important that this assignment be turned in promptly  for this project there will be a deduction of   for each day late i e    deduction for submitting up to  hours late   deduction for submitting more than  hours late up to  hours etc up to a  deduction for submitting up to  days  hours late  after  days late submissions will receive a  deduction  please submit your work promptly as always extenuating circumstances will be considered please contact me as soon as possible if any extenuating circumstances are impeding your work on this project   the eight problems to be solved below are the eight problems to be solved divided into three categories  note that each of the problems is a decision problem  it asks for a true  false answer to be given  for each of the problems below in all three categories your exhaustive search algorithm will need to look through either all subsets of a set or all permutations of a list  for your work please assume that you can use algorithms to create the relevant lists for your exhaustive search meeting the specifications given here the same as those in our lecture notes and with the time and space complexities given here generate-all-subsets you may use a generate-all-subsetss algorithm that hastime complexity nn and space complexity nn on input sof size n meeting these specifications input ss s s        s n a set of nelements output l a list of all subsets of s generate-all-permutations you may use a generate-all-permutationsl al- gorithm that has time complexity nn and space complexity nn on input l of size n meeting these specifications input l s s s        s n a list of nelements output psl a list of all permutations of l note that you are not told how these algorithms work and they may not be identical to the ones we derived in class you should just assume that they exist for your use and meet these specifications  in addition here are some reminders about setsandgraphs that might be useful the specifications for some of the problems below involve sets  please recall that by the definition of a set no two values in a set can be equal to each other  all of the specifications were written to be consistent with this definition  the specifications for some of the problems below involve graphs  every graph gis defined as a combination of a set vof vertices in the graph and a set eof edges that connect some or all or none of the vertices in the graph for short we say g v e  see clrs appendix b  pg   for more about graphs and as always please feel free to ask me any questions about definitions regarding graphs the following sections give the three categories containing the eight problems to be solved    category taking stuff the problems to be solved in this category are  fair share you and a friend are in a room with nvaluable items with values c c      c n and you want to take all of them but only if you each take exactly the same value with you  is that possible with the items in front of you  the fair-share problem input  a set cc      c nofnpositive integer values the values of the nitems  output true if there exists a subset sofcfor which the sum of the values insisexactly the sum of the values not in sfalse otherwise  for example  ifc a correct algorithm for fair-share would return true because there's a set swhere the sum of the values is  and the sum of values not in sis       on the other hand if we consider set c  there is no set sof values from cthat could equal the values not in stry it no subset of cworks for these values so a correct algorithm would return false    price is exactly right you're in a store with nitems with costs c c      c n and you have an amount vto spend on these items  can you spend exactly von some or all of the items from this store the price-exactly-right problem input  a set cc      c nofnpositive integer values the values of the nitems and a positive integer v  output true if there exists a subset sofcfor which the sum of the values insisexactly equal to vfalse otherwise  for example  ifcandv  a correct algorithm should return true because there exists subset cfor which the values add up to   that's not the only subset with values that add to  but one is enough for the algorithm to return true  on the other hand for the same c ifv  there is no subset sofcfor which the values of scould add up to exactly    book bag you're at a used book sale where there's a deal available if you pay a flat fee let's call the fee amount k they give you a bag with a capacity of cand you can take as many books as you want as long as they all fit in that bag  the numbers kandccan be in whatever units you like as long as we're consistent throughout the problem it doesn't matter which they are  you can choose books to take from a setbb      b nofnbooks and each book bihas a size sbi and a value vbi  is it possible to find some subset sof the books such that all the books in scould fit in the bag they give you and the total value of the books in sadd up to more than the amount kthat you'd pay for the deal the book-bag problem input  set bb      b nso that each bihas a positive integer size siand a positive integer value vi positive integer capacity c positive integer fee k  output true if there exists a subset sa      a mofbfor which the sum of the sizes m isai is less than or equal to candthe sum of the values m ivai is greater than or equal to kfalse otherwise  for example  let bb b bwhere bhas size  and value  bhas size  and value  and bhas size  and value   then if c  and k  a correct  figure  an example graph referred to in examples accompanying problem statements  figure taken from clrs  algorithm should return true on inputs b c k  because the set of books b bhas their total size equal to  less than or equal to c and their total value equal to  greater than or equal to k  for the same bandk however but c  a correct algorithm should return false  one way to see this is that the greatest value possible for a set of books from bwith total size less than or equal to  would be  from the subset b b and that's not greater than or equal to k    category social networks in all of the problems in this category we'll be using graphs to represent social networks every vertex in a graph will represent a person and every edge between two people will represent that the people know each other  please assume graphs for problems in this category are undirected  the problems to be solved in this category are  clique aclique is defined to be a collection cc      c jof people such that every pair of people in cknow each other  because we're using a graph g v e to represent the social network a clique is a subset cof the vertices of the graph for which every pair of vertices in chas an edge between them   ccould in principle be equal to v which would be a complete graph  the question  given a number k is there a clique of size kin the social network we're studying the clique problem input  graph g v e positive integer k v  output true if there is a clique cof size kingfalse otherwise  for example  in figure  the graph contains multiple cliques of size  such as the set  the set is not a clique because  is not connected to    strangers in the social network g v e we will define a group of people s s      s jto be strangers to each other when for every pair of people in s they do not know each other  because we're using graph g v e to represent the social network a set of strangers is a subset sof the vertices of the graph for which no edge ineexists between any two people in s  scould in principle be equal to v which would be a maximally sparse graph  the question  given a number k is there a set of strangers sof size kin the social network we're studying  figure  an example graph referred to in examples regarding the complement of a graph  figure taken from clrs  the strangers problem input  graph g v e positive integer k v  output true if there is a set of strangers swhere shas size kingfalse otherwise  for example  in figure  the set is a set of strangers of size  there are also others but there is no set of strangers of size  for every three people in the graph there's a connection between some two of them  try it  network cover in the social network g v e we will define a group of people pp      p jto be a network cover if across all the people in p every social connection in the network involves at least one of the people in p  because we're using graph gto represent the social network a network cover is a subset pof the vertices ingsuch that every edge in einvolves at least one person in p the question  given a number k is there a network cover pof size kin the social network we're studying the network-cover problem input  graph g v e positive integer k v  output true if there is a network cover pwhere phas size kingfalse otherwise  for example  in figure  the set is a network cover of size  there are also others but the set is not a network cover because the connection between  and  is not covered by    hint this hint only applies to reductions section  not other parts of the project  when thinking about designing reductions involving the problems in the social networks category section   you might want to consider the complement of a graph as part of your reduction  by definition for a graph g v e the complement ofgis a graph g v e where the vertices are the same as in gbut the edges are all edges not in e   more precisely considering every edge in a graph as a pair of vertices eu vu vvbut u ve  as a concrete example let gbe the graph in figure  then there would be edges from vertex  to every other vertex in the complement g because none of those edges are in g but edge   would not be in gbecause there is an edge between vertices  and  in g  you don't need to use the complement of a graph in your reduction but you might want to in some cases  as always please feel free to talk with me about these concepts   category maps and touring in the problems in this category we'll be using graphs to represent maps every vertex in a graph will represent a location and every edge between two locations will represent that we can travel between those locations in either direction  please assume graphs for problems in this category are undirected  for these problems we'll define a tour on a map g v e a tour is a path that starts in some initial city cinvand then following edges in e passes through every other city invexactly once before returning to c  for example in the map represented by the graph in figure  one possible tour is represented by the shaded edges the one from utowtov toxand then back to starting city u  note that there are many possible tours through all cities on this map this is just one possibility  also for the problems in this section note that in a tour it doesn't really matter which city we indicate as the starting city since the tour goes through all of them exactly once before looping back to where it started its starting point could equivalently be anywhere for these problems  the direction also doesn't matter for the problems in this section because the graphs are undirected  for example the tour indicated by the shaded edges in figure  could be viewed as starting at city xand going xtovtowtoutoxjust as well as utow tovtoxtou  the problems to be solved in this category are  traveling salesman in this classic cs problem we start with a complete graph g v e in which every pair of cities vi vjinvis connected by an edge in e  in addition to the graph there is a distance function dthat gives a distance dvi vj between every pair of cities assume that the distance is the same in either direction sodvi vj dvj vi for every pair of cities  it is our traveling salesperson's job to make a tour to start from their home city then follow edges in the graph to visit every other city exactly once before returning to their home city  the question  given a number k is it possible to make a tour while covering total distance kor less the traveling-salesman problem  figure  an example tour on a graph referred to in examples accompanying problem statements  here there are many possible tours through all cities on this map including one from utowtovtoxand then back to starting city ushown by shaded edges in the graph  figure taken from clrs  input  graph g v e distance function das described above and positive integer k  output true if there is a tour of vhaving distance kor less false otherwise  for example  in figure  the distance function dgiving distances between cities is indicated by the number over each edge e g  dv x   and dx w    consider the map in that figure that distance function d and number k   a correct algorithm would return false  because there is no tour of all those cities remember it has to end up back where it started with distance  or less  on the other hand with that map that distance function and k  a correct algorithm would return true indeed the shaded edges are a tour of distance  which is less than    hamiltonian tour unlike the traveling salesman example the touring company ofhamilton does notstart with a complete graph instead they start with some map g v e that may or may not have edges between any two cities  there is also no distance function to be considered here all that matters is whether or not they can get from one city to the next  their goal however is to make a tour in the same technical sense of tour used in the traveling salesman problem to visit every city exactly once before returning home  the question  given a map g v e is there a tour in the map visiting each city exactly once before returning to the city from which it started the hamiltonian-tour problem input  graph g v e  output true if there is a tour in gfalse otherwise  for example  in figure  there are many paths that are not tours in this sense  for example if a possible tour started at city  and then went to  and then  and then  it could not get to city  without going back to  along the way and that's not a tour in our sense of the word it would visit city  more than once before returning to where it started  nonetheless there is a tour through that graph for example it could go from  to  to  to  to  before going back to  so a correct algorithm would return true on that graph  