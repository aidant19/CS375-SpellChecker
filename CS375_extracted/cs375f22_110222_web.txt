 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   definition  of our llist data structure   in english we'd say an llist is   either the empty list   or   an element called first   and an llist called rest representing all the elements after first   to be unambiguous about how we work with llists these  will be the primitive functions defined on llists   firstl returns value of the first element of an llist l   restl returns value of the rest sublist of an llist l   consvl a constructor function that takes an item v and an llist l  and returns a new llist l' such that   what do you think it might be note this definition may  show up on hw too  what do you think  the complexities of  these functions are  cs --    business   grading update   ps in progress   expect ps out real soon now   due no sooner than  week after it's assigned   project    first part due already   other parts due nov     please note some restrictions on my schedule   i expect to be traveling on nov   and probably wo n't be on email or able to  answer questions after noon on that day so please plan accordingly  definition  of our llist data structure   in english we'd say an llist is   either the empty list   or   an element called first   and an llist called rest representing all the elements after first   to be unambiguous about how we work with llists these  will be the primitive functions defined on llists   firstl returns value of the first element of an llist l   restl returns value of the rest sublist of an llist l   consvl a constructor function that takes an item v and an llist l  and returns a new llist l' such that   v is the element first of l'   l is the sublist rest of l' note this definition may  show up on hw too  for example how would you write  this llist as a list in brackets  consconscons  sometimes the empty list is written as    we could display all llists in  brackets as is usual for lists  we'll treat all  three of these as  constant-time fns  cs --    definition  of our llist data structure   to be unambiguous about how we work with llists these  will be the primitive functions defined on llists  firstl returns value of the first element of an llist l  restl returns value of the rest sublist of an llist l  consvl a constructor function that takes an item v and an llist l  and returns a new llist l' such that   v is the element first of l'   l is the sublist rest of l' note this definition may  show up on hw too  reminder  firstl restl and consvl are functions that return  values they are not fields of an object  because o f this we cannot  assign values to them e g  firstl   or restl   is not permitted   what could be done instead with this syntax to ch ange the first  element of some llist lto  this convention below is  common in functional  programming languages  definition  of our llist data structure   to be unambiguous about how we work with llists these  will be the primitive functions defined on llists  firstl returns value of the first element of an llist l  restl returns value of the rest sublist of an llist l  consvl a constructor function that takes an item v and an llist l  and returns a new llist l' such that   v is the element first of l'   l is the sublist rest of l' note this definition may  show up on hw too  reminder  firstl restl and consvl are functions that return  values they are not fields of an object  because o f this we cannot  assign values to them e g  firstl   or restl   is not permitted   what could be done instead with this syntax to ch ange the first  element of some llist lto  ans we could do l  consrestl  this convention below is  common in functional  programming languages  cs --    llist example  remove first occurrence of an element   consider the problem of removing the first occurre nce of an element from a  sequence specified here for a list   how would you design an algorithm to solve this problem  it's going to be recursive because  the definition of llist is recursive   follow the definition  how would we break the problem  down into  or more smaller  subproblems and then use the  results in a solution for the original  problem input item i and llist l  x   x n output if i x kand k is the smallest value for which i x k  return llist x   x k- x k   x n otherwise i e  when there is no k such that i x k return l  llist either empty   or  - element first  -llist rest  functions on llists  - firstl returns first  - restl returns rest  - consvl creates new llist  with v as first and l as rest  correctness  remove first occurrence of an element   how would you argue the correctness of this algorithm   be sure to refer to these specifications as well as lines of pseudocode    hint it will be an inductive argument because th e algo is recursive input item i and llist l  x   x n output if i x kand k is the smallest value for which i x k  return llist x   x k- x k   x n otherwise i e  when there is no k such that i x k return l  llist either empty   or  - element first  -llist rest  functions on llists  - firstl returns first  - restl returns rest  - consvl creates new llist  with v as first and l as rest algorithm llremovei l   see specification immediately above  if l     return l  else  if i  firstl  return restl  else  return consfirstlllremoveirestl  cs --    time complexity of  remove first occurrence of an element   how would you analyze the time complexity of this algorithm  functions on llists - firstl returns first  - restl returns rest  - consvl creates new llist  with v as first and l as rest  assume all of these functions  are o they would be in  most implementations algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstlllremoveirestl this is something we haven't done before let's think it through  we analyze complexity as a function of input size as usual  let's let nstand for input size and tn stand for time complexity on input of size n we need to figure out what tn is    what foundati ons or definitions can we follow  zen principles to help us  well it's recursive     so let's look at the base case and recursive case sepa rately  recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   in the base case what is the input size                                                      and what is the runtime of the algo recall that firstl restl consvl functions are all o algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl  cs --    recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   in the base case what is the input size                                                      and what is the runtime of the algo recall that firstl restl consvl functions are all o algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl  base case  input size empty list n    runtime  do you see why  recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   in the base case what is the input size                                                      and what is the runtime of the algo recall that firstl restl consvl functions are all o algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl  base case  input size empty list n    runtime  do you see why so we'd say t   to  express the base case runtime  cs --    recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   base case t     how about the recursive case what is the input si ze and runtime algorithm llremovei l  if i  firstl  return restl  else  return consfirstl  llremoveirestl  recursive case we say input is size n as usual l has n elements  also  it does some work other than the recursive call comb ined  do you see why  all of its other runtime is in its recursive call  how would we represent th e runtime of  that particular recursive call let's just focus on the  recursive case for now  recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   base case t     how about the recursive case what is the input si ze and runtime algorithm llremovei l  if i  firstl  return restl  else  return consfirstl  llremoveirestl  recursive case we say input is size n as usual l has n elements  also  it does some work other than the recursive call comb ined  do you see why  all of its other runtime is in its recursive call   input size to recursive call n- a list of  less element than l do you see why  how do we express the runtime of that call use our definition of t let's just focus on the  recursive case for now  cs --    recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   base case t     recursive case tn  tn-   algorithm llremovei l  if i  firstl  return restl  else  return consfirstl  llremoveirestl  this may look unusual and recursive but it follows  cleanly from the previous slide  in the recursive case  it does some work other than the recursive call comb ined   do you see why  all of its other runtime is in its recursive call tn- let's just focus on the  recursive case for now  recurrences for time complexity  of recursive functions   putting all the pieces together so far there's more coming up  let's put the pieces together  for n   t    for n    tn  tn-    that is a full definition of the  complexity of this algorithm   both the base case and the  recursive case algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstlllremoveirestl let's let nstand for input size and tn stand for time complexity on input of size n we need to figure out what tn is    let's look at the base case and recursive case  separately  the base case prev  slide is t     what's the complexity in the recursive case  tn  tn-    the time taken by everything but the recursive call is just   do you see why   and the recursive call is on input of size n-  so by our definition of function t  complexity of the recursive call is tn-  do you see how this  characterization of tn  exactly fits our  llremovel algo cs --    solving a time complexity  recurrence   let's focus on our definition of runtime function tn and how to use it   important vocabulary   we say this definition of tn is a recurrence  it defines tn in terms of itself   note that it follows good design principles for re cursive definitions   it has a base case   its recursive case is defined in terms  of itself on smaller inputs   indeed the two parts together are  a complete definition of the runtime   but we're not done yet what's the  asymptotic complexity of llremove for n   t    for n   tn  tn-   algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl 