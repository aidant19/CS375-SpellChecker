CS   CS   Analysis of Algorithms Professor Eric Aaron Lecture  M W pm Lecture Meeting Location Davis  Business  Grading update  SA returned  PS extended  unusual deadline  Due pm today  Project   First part due already  Other parts due Nov   Please schedule dress rehearsals with me for Frida y  Saturday I will not be available for them next Tuesday or la ter CS   Business Project   Project  out due Nov   Parts of Project   Design Exhaustive Search Algorithms  Your team will collectively design exhaustive search algorithms for  problems  Improve Time Efficiency  Your team will pick one of the problems and make your exhaustive search algorithm more efficient  Reduction  For the same problem chosen for part  above you will reduce that problem to one of the other seven problems from part   Create and Give a Presentation  Your team will present work from the previous three parts of the assignment using loop invariants where appropriate to explain correctness Hint  Your team may want to be strategic about which of the  problems you choose to focus on for your improvements reduction and presentation Pick a problem for which you can do good work Have you read through Proj yet Would you have preferred the assignment sheet to be broken up into separate documents CS   Common myths about recursion debunked  What impressions do you have about recursion  Here are some things Ive heard paraphrased slightly  Recursion is basically just a party trick  Recursive design is just trial and error  Recursion is slow compared to iteration  People dont really use recursion Admittedly Ive mostly heard them in the context o f a student saying I used to think this was true but now I dont anym ore But still Ive heard them or something very much l ike them If theres anything youd like to add to this list  let me know Its actually very useful There are methods to use People really do it can be very natural to use Well sort of It can be But its not as bad as i t used to be and related concepts can enable some very fast code  A Functional Digression The Functional Programming Paradigm  Some important features of pure functional programming  Immutable data  Stateless functions everything selfcontained  no side effects  Uses recursion for iteration rather than loops Supports parallel computation recall applications to data science  Code can be easier to show correct  debug For those of us who like to think about programming  languages at the theory and design level it may be interesting to note tha t the last three of the above five features kinda follow from the first two This is subtle and well beyond the scope of CS but please feel free to talk with me more about it outside of class if you d like CS   Zen and The Art Of Algorithm Design  A couple of Generally Good Ideas principles to help you design your algorithms and their implementations  I might restate principle  as  Keep your foundations simple  I might restate principle  as  Let your definitions tell you what to do  Lets apply this to binary trees  The foundationsie relevant definitions and dat a structuresshould be as simple as possible while sti ll providing all needed functionality  Let the foundations guide the development and ana lysis of algorithms based on them Binary Trees A Review  Remember binary trees from CS This figure from CLRS illustrates that binary trees  could in principle contain the same data in different tree structures parts a and b Part c shows external nodes the null fields in a typical implementation of a binary tree They can be thought of as empty s ubtrees in context External nodes are hidden in parts a and b CS   Binary Trees A Review  Remember binary trees from CS  Application Binary search trees BSTs  Whats a good definition of a binary tree Note This isnt asking about the definition of a B ST but about the more general data structure of a binary t ree Just as a reminder of where youve seen binary trees before  Both of these are examples of a binary search treea specific kind of binary tree In our work over the several slides well talk not about BSTs but about binary trees in general One Possible Definition of Binary Tree  Often an implementation of a binary tree is based  on two classes a Node class and a Tree class as well as a type T o f data to store  NodeT class has fields item  T  the data stored at the node a value of type Tleft  Node  the left subtree represented by its root node right  Node  the right subtree represented by its root  node   and perhaps others   TreeT class has fields root  NodeT  the root node which represents the tree  and perhaps others such as  size  int  the number of nodes in the tree If we wanted a data structure just to be a binary t ree of integers for example would we need all of this structure Is this a good definition Consider Principle  Keep your foundations simple CS   Definition of our IntBinTree Data Structure  Throughout CS we will sometimes refer to an IntBinTree data structure representing a binary tree of integers  In English wed say an IntBinTree is  Either empty  Or  an int called val  and two subtrees called left and right  that are also IntBinTrees  Programmers might be used to seeing it more like this Definition IntBinTree Empty or int val  the int value not empty intBinTree left  the left subtree intBinTree right  the right subtree Is this a good definition Consider Principle  Keep your foundations simple NOTE This definition may show up on HW too Is this definition equivalent to the English one above The fact that a tree could be empty is often implicit in many specifications Definition of our IntBinTree Data Structure  In English wed say an IntBinTree is  Either empty  Or  an int called val  and two subtrees called left and right  that are also IntBinTrees  To be unambiguous  and consistent with functional programming  about how we work with IBTs these will be the primitive functions defined on IBTs  val T returns the val element of an IBT T left T returns the left subtree of an IBT T right T returns the right subtree of an IBT TNOTE This definition may show up on HW too Well call them IBT s for short Important note valT leftT and rightT are functions that return values they are not fields of an object Because of this we cannot assign values to themeg valT   is not permittedFor CS these are the only ways to access val left right  So something like Tval is not permitted CS   IntBinTrees An Exercise  Design an algorithm to return the number of levels in an IntBinTree  What design paradigm will we use for this algorithm  Will it be iterative or recursive As IntBinTrees we would say tree a has  levels and tree b has  levels Consider principle  Let your definitions tell yo u what to do How does our definition of an IntBinTree tell us wh at to do here Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree IntBinTrees An Exercise  Design an algorithm to return the number of levels in an IntBinTree Because the definition of IntBinTree is recursive it makes sense that algorithms over it would be recursive As IntBinTrees we would say tree a has  levels and tree b has  levels In fact because an IntBinTree is defined recursive ly in terms of two IntBinTrees it might make sense for an algo over IntBinTree to have two recursive calls Thats an example of Principle letting definition s tell us what to do Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree CS   A Review of Recursive Design Divide and Conquer  Every recursive algorithm has the following components Base cases  One or more small cases for which it is easy to identify or compute and return a solution Recursive cases  One or more cases in which the algorithm calls itself on a smaller instance of its input Divide  The algorithm must break the original problem input down into smaller subproblems subinputs on which the algo can be called recursively Conquer  The algorithm must solve each of the subproblems Combine  The algorithm must combine  employ the solutions  of subproblems into a solution of the original pro blem Recursive cases bring input closer to terminating in a base case Its really important that recursions terminate IntBinTrees An Exercise  Design an algorithm to return the number of levels in an IntBinTree  Reminder In English an IntBinTree is either empty or an int and two subtrees  For our recursive algorithm to compute the number of levels  What are the input and output  What input does the base case check for  Whats the intended output for the base case  How many recursive calls will the algorithm make  How do we use output from recursive calls to compute the output on the given input Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree It can be helpful to write down a problem specification with input and output types CS   IntBinTrees An Exercise  Design an algorithm to return the number of levels in an IntBinTree  Reminder In English an IntBinTree is either empty or an int and two subtrees  Our recursive algorithm to compute the number of levels  How would we explain this algorithms correctness Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree Algorithm LevelsT Input IntBinTree TOutput integer number of levels in T if T is empty return  else return maxLevelsleftT LevelsrightT   Correctness of Recursive Algorithms Inductive Arguments  When arguing the correctness of a recursive algorithm the general form is that of an inductive argument  The explanation follows the structure of the algorithm  Show that the algorithms base case returns correc t output  Show that the recursive cases return correct outpu t under the assumption that all recursive calls retur n correct output  Here how would that work  How would we explain the base case The recursive case Just like when creating recursive codewe assume rec ursive calls work in the recursive case Algorithm LevelsT Input IntBinTree TOutput integer number of levels in T if T is empty return  else return maxLevelsleftT LevelsrightT   CS   Correctness of Recursive Algorithms Inductive Arguments  When arguing the correctness of a recursive algorithm the general form is that of an inductive argument  The explanation follows the structure of the algorithm  Show that the algorithms base case returns correc t output  Show that the recursive cases return correct outpu t under the assumption that all recursive calls retur n correct output  As part of explaining recursive cases also explain how we know the algo terminates  Show arguments in recursive calls get closer to base case Just like when creating recursive codewe assume rec ursive calls work in the recursive case Algorithm LevelsT Input IntBinTree TOutput integer number of levels in T if T is empty return  else return maxLevelsleftT LevelsrightT   Another IntBinTrees Exercise Search  The search problem on IntBinTrees asks if an int is anywhere in an IntBinTree  How would we write the problem specification for IBTSearch  What would be the input  What would be correct output  How would we design an algorithm to solve it  Would the algorithm be iterative or recursive  How would we argue its correctness Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree CS   Another IntBinTrees Exercise Search  The search problem on IntBinTrees asks if an int is anywhere in an IntBinTree  How would we write the problem specification for IBTSearch  Input an int i and an IntBinTree T Output True exactly when iis in TFalse otherwise Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree Algorithm IBTSearchi T Input int I IntBinTree TOutput True exactly when iis in T False otherwise Another IntBinTrees Exercise Search  The search problem on IntBinTrees asks if an int is anywhere in an IntBinTree  How would we write the problem specification for IBTSearch  Input an int i and an IntBinTree T Output True exactly when iis in TFalse otherwise Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree Algorithm IBTSearchi T Input int i IntBinTree TOutput True exactly when iis in T False otherwise if T  empty return False else if valT  i return True else return IBTSearchileftT or IBTSearchirightT  The last line uses the Boolean operator or  which is inclusive it is True when either or both operands are True 