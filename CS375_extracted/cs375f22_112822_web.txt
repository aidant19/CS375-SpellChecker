cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   sa sa due already   sa out due pm dec     sa involves working through an example of the algo we covered last   monday   ps due nov     no exercises beyond the lookahead   ps out nov   due dec     ps will be the final ps for the semester there may be other sas   ps sa sa grading update   project  out today   due pm monday dec     severe late penalties if turned in during exams i e  after pm dec     intended team size  but talk to me if you'd prefer to work with a   smaller team size  cs --     cs --   all-pairs shortest paths   a vertex-based recursive solution    we're still considering shortest path p from i to j with   intermediate vertices in vk  what's the relationship between p and the set of shortest paths from i to j   with intermediate vertices in vk-    depends on whether or not vertex k is an intermediate vertex   on path p  if not then p is also a shortest path i to j with intermediate vertices in vk-  if so then p can be broken down into sub-paths that are shortest paths with   intermediate vertices in vk-    one sub-path is from i to k the other is from k to j   altogether if w is the weights matrix and           is the shortest path  value from i to j using only intermediate vertices numbered up to k  ijd  k    by the way which one's warshall  floyd-warshall algorithm   bottom-up all-pairs shortest paths   floyd-warshall algorithm for all-pairs shortest paths the bottom-up   method based on this decomposition   computes matrices dk           where each         is the shortest path   ijd  k    k    ijd  value from i to j using only intermediate vertices numbered up to k  note this computes  shortest path values  not the paths  see  clrs pages -  about computing the  paths themselves    what does this algorithm return what makes that a useful return value   what is the running time of this algorithm    cs --   a floyd-warshall example  see clrs  ch      computes matrices dk           where each           k  k      ijd  ijd  is the shortest path value from i to j using only  intermediate vertices numbered up to k   what d matrices does it   compute for this  example graph  a floyd-warshall example   computes matrices dk           where each           k  k      ijd  ijd  is the shortest path value from i to j using only  intermediate vertices numbered up to k   what d matrices does it   compute for this  example graph    cs --     and now for something completely   different  it's  and now for something completely different  change  well not that  kind of change   consider the coin changing problem given a number   non-negative integer n of cents make exactly that much  change using the smallest number of coins  assuming you have only pennies nickels dimes and quarters to   work with what would your algorithm be   how would you explain correctness  optimality  actually  also that kind of change  greedy algorithms greedy-choice  property and optimal substructure    it turns out the coin changing problem can be solved by a  greedy algorithm  choose the best option first keep doing that until problem is solved   here choose the biggest coin say it has value c that could be   used for n cents change   then repeat that for the n-c cents in the remaining subproblem   for this greedy method to work   optimal substructure an optimal solution with k coins is composed of   optimal solutions with k- coins for the relevant number of cents   greedy-choice property by choosing locally the greedy choice first   and continuing this method we get globally an optimal solution  this makes sense it basically says if choosing greedily won't help and optimal solutions  on subproblems won't help then don't use a greedy method  cs --     cs --   see clrs sec  b   and b    the trees  see also the rush album  hemispheres which many  people may find even more  dense and inaccessible  than the clrs textbook    a tree sometimes called a free tree is an acyclic connected undirected   graph   we've seen rooted trees such as   a collection of possibly  disconnected trees is  called a forest  really   binary trees before but from a more  general graph-oriented perspective trees do not need to have roots    important properties of free trees the below statements are all  equivalent for undirected graph g  v e   g is a free tree   any two vertices in g are connected by a unique simple path   g is connected but if any edge is removed the resulting graph is disconnected   g is connected and e  v-   g is acyclic and e  v-   g is acyclic but if any edge is added to g the resulting graph has a cycle    more trees   with rooted trees recall vocabulary   ancestor  descendant    parent  child  sibling   internal node  external node  leaf   depth  height of a node in the tree   given a connected undirected graph g  ve many   subgraphs of g are trees  consider an acyclic subgraph that connects all the vertices in v   how do we know it's a tree   how many edges must it have  minimum spanning trees msts   given a connected undirected graph g  ve an acyclic   subgraph that connects all the vertices in v is a spanning tree of g   it's a tree and it covers spans all the vertices of g   for network g represents unique connections  paths between each pair of   nodes in g   consider the minimum spanning tree mst problem given weighted   undirected connected graph g find a spanning tree t with minimal  total weight over all edges in t  cs --     cs --   in the not too distant future -- mst k  a generic mst algorithm   minimum spanning trees can be grown one edge at a time   safe here means an edge that  can be added without  violating the property that a  is a subgraph of an mst   digression how do we argue  correctness of the algorithm   some vocabulary   a cut sv-s of an undirected graph gve is a partition of v   an edge uv crosses a cut if u is in s and v is in v-s   a cut respects a set of edges if no edge in the set crosses the cut   a light edge is a minimum-weight edge satisfying a property e g    a light edge that crosses a cut  how can this vocab be used to  describe an mst algorithm  greedy mst algorithms   greedy strategy for building msts add the best edge from   edge set e of graph g repeat until an mst is built  overall structure turn a forest some trees have only  node into a   tree by adding light edges connecting separate components   question what is the best edge the greedy choice to add  a possibility pick the least-weight edge from e that connects two   separate components   possibly results in multiple trees growing         invariant all subgraphs are  trees  how do we know  in the forest but all will be connected by the end of the algorithm   i e  maintains a disjoint set of sub-trees    