 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   thank you again to those who participated in class  discussion oct     please come talk with me about any aspect of that you'd like to discuss   grading update   ps returned   ps in progress   project returned for groups that submitted on tim e  following instructions   slight delay for others coming soon   a note about grading in cs in general and on p roj in particular   median grade on proj   scales to at least a  b    so about sorting method     sa due already  note i found a typo in the hint for part cof the invariants-explanation   assignment said loop ended with i  n  instead of i  n   revised sa now posted with a revised hint but no  other differences   ps out due oct    cs --    business project    project  out very soon   multi-stage project with final due date in early november  project  is to be done in teams of   important by end of day wednesday oct   one p erson from each team  should email me and everyone on the team to let me know they're teaming up   if you'd like my help finding a team for you plea se let me know   parts of project     design exhaustive search algorithms  your team will collectively design  exhaustive search algorithms for a variety of probl ems     improve time efficiency  your team will pick one of the problems and make  your exhaustive search algorithm more efficient     reduction  for the same problem chosen for part  above you  will reduce that  problem to one of the other problems given in part   this is a new topic for  us more soon    create and give a presentation  your team will present work from the  previous three parts of the assignment using loop invariants where appropriate  to explain the correctness of your algorithms   using loop invariants in  algorithm design and explanations   loop invariants state properties known to be true for each iteration of a loop   can think of it as a property known to be true imm ediately before and  immediately after each iteration   in our examples we've understood loop invariants in terms of before and  after conditions  before  what is helpful and known to be true before a giv en iteration of the loop  after  what is helpful and known to be true after a give n iteration of the loop  which establishes the truth of the before condition before the next iteration   key point loop invariant gives a property that's true after the loop is  finished that helps explain algo correctness  to informally use loop invariants to help explain  algo correctness  explain how the invariant is true before the first iteration of the loop  explain how the invariant is true after each follow ing iteration  explain how the invariant property shows that the a lgo meets its  specifications  cs --    a logical digression  logical reasoning about empty stuff   how does it work if we're asked if something is tr ue for all elements of an  empty structure   examples   say l is a list of strings and l is empty  is it true that every string on the list  has length greater than    say s is a set of numbers and s is empty  is it t rue that every number in s is  equal to    the answer to these questions is yes it is true   we say it is vacuously true    part of the way propositional logic works is that when we ask if some  property is true of every element in some empty structure    the answer is always yes because there are no el ements to reason  about we can vacuously say anything is true of anything in that empty set  this follows from the same idea that once it is sho wn that false  true  the system is incoherent so we can say anything is  true in that system  a logical digression  vacuous truth   how does it work if we're asked if something is tr ue for all elements of an  empty structure   more examples   say l is a list of numbers and l is empty  is it true that l is in sorted order    say l is a list of numbers and l is empty  is it true that l is out of sorted  order    the answer to these questions is yes they are vacuously true  it's completely understandable if you're not feelin g totally happy about this dealing  with logical incoherence is tricky  it turns out though this convention of vacuous tr uth can be really useful and it  gets very intuitive after a while this can be useful as part of using loop invariants  especially when showing  a property is true in some boundary case either before the first iteration of  a loop or after the last iteration of a loop  cs --    example of reasoning with vacuous truth  loop invariants and bubble sort   yes bubble sort is the actual name of this sorting algorithm   in pseudocode   do you understand how the algo works try it on a   how do we use loop invariants to show correctness i e  that  it sorts a in non-decreasing order bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- what's the time complexity of this algorithm  example of reasoning with vacuous truth  loop invariants and bubble sort  on   loop invariant for outer loop   use invariant to show correctness    show invariant is true before first loop iteratio n how    show pseudocode ensures invariant is true after e ach successive iteration  assuming that it's true at the start of the iterati on how    show when loop is done algorithm meets specifica tions how bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n cs --    example of reasoning with vacuous truth  loop invariants and bubble sort  on   loop invariant for outer loop   use invariant to show correctness    show invariant is true before first loop iteratio n how bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n before the first iteration iis set to   for the invariant we look at a  i-   a     by convention a   is an empty array    so it vacuously contains the i- smallest values of a in sorted order  example of reasoning with vacuous truth  loop invariants and bubble sort  on   loop invariant for outer loop   use invariant to show correctnessbubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n super important note  show that the entire invariant is true not just part of it  a   vacuously contains the i- smallest values of a in sorted order   we still need to explain how a  n consists of th e remaining values of a no  constraint on order but that's not that difficult  cs --    explaining correctness  loop invariants and bubble sort  on   loop invariant for outer loop   use invariant to show correctness    show invariant is true before first loop iteratio n done    show pseudocode ensures invariant is true after e ach successive iteration  assuming that it's true at the start of the iterati on how    show when loop is done algorithm meets specifica tions how bubblesorta    for i   to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n explaining correctness step   loop invariants and bubble sort  on   loop invariant for outer loop    show pseudocode ensures invariant is true after e ach successive iteration  assuming that it's true at the start of the iterati on bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n there are many right ways to do this step it's all a bout explaining how the algo works  refer directly to the pseudocode in your explanatio n citing specific lines of pseudocode  how might we structure this explanation  cs --    explaining correctness step   loop invariants and bubble sort  on   loop invariant for outer loop    show pseudocode ensures invariant is true after e ach successive iteration  assuming that it's true at the start of the iterati on bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n one possible explanation idea  each iteration of the inner loop ensures after the swap  that aj- is smaller than aj  for each i at the end of the inner loop in lines  - the smallest value remaining in  ai  n has been swapped down the array into positi on ai explaining correctness step   loop invariants and bubble sort  on   loop invariant for outer loop    show when loop is done algorithm meets specifica tions bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n there are many right ways to do this step too  refer directly to the invariant property and to the  specifications in your explanation  referring to specifications is essential for showin g algo correctness  cs --    explaining correctness step   loop invariants and bubble sort  on   loop invariant for outer loop    show when loop is done algorithm meets specifica tions bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n one possible explanation idea with important detai ls omitted  because the invariant is true at the end of the out er loop when i  n  we know a  n-  contains the n-smallest values of ain sorted order  then an must be the largest value in a  do you see why  and  can you fill this in  so the elements in a are in sorted order  do you see why  which meets the  specifications of the sorting problem so the algor ithm is correct  algorithm correctness and loop invariants  a recap   to explain correctness of iterative algos look at the loop   loop invariants can help three steps to using loop invariants    show the invariant is true before the first itera tion    show the invariant stays true after each successi ve iteration  assuming it was true before that iteration    show the algo meets specifications using what the  invariant says is  true after the loop is done see clrs    these three steps correspond to three parts mention ed in our clrs textbook    initialization property is true before the first iteration    maintenance if a property is true before an iteration it is tr ue after that iteration  before the next  iteration    termination when the loop terminates the property is useful in  showing algorithm correctness  you do not need to use these three terms from clrs for cs when discussing invariants although  you can if you want to i just wanted to connect our approach in this slides to our textbook  cs --    time complexity classes illustrated  complexity class what we call it example algorithms   objects  o constant print hello world stack operations  and much much more be careful  olg n log time binary search  on linear exhaustive search of an array linear  search merge as used in mergesort on lg n n lg n mergesort heapsort  recall sorting can be done in n lg n  on n-squared quadratic insertion  selection  bubble s ort  several graph algos  on n-cubed cubic my favorite algorithm  a graph algo on exponential number of subsets of a set of size n  on factorial number of orderings  permutations of  elements of a list of length nthe green-shaded ones are examples of polynomial time classes upper bounded by nkfor  some constant k  problems solvable in polynomial time are consider ed tractable  more  about this later in the semester  cs --    constant time   o usually refers to primitive operations   printing a finite string print hello world   accessing an array   copying a reference or value into a variable of fi xed constant size    or to a constant number of them to complete a tas k compare and swap  two elements which can be very useful i might not usually  consider these to  be  algorithms  constant time   o usually refers to primitive operations   printing a finite string print hello world   accessing an array   copying a reference or value into a variable of fi xed constant size    or to a constant number of them to complete a tas k compare and swap  two elements which can be very useful pro tip  warning technically by definition of asymptotic complexity   the time complexity of the following are all upper bounded by a constant   evaluating all possible moves for a turn in chess   solving a standard x sudoku   reading our entire clrs textbook into a new text f ile i might not usually  consider these to  be  algorithms  why are these technically o  cs --    constant time   o usually refers to primitive operations   printing a finite string print hello world   accessing an array   copying a reference or value into a variable of fi xed constant size    or to a constant number of them to complete a tas k compare and swap  two elements which can be very useful  pro tip  warning technically by definition of asymptotic complexity   the time complexity of the following are all upper bounded by a constant   evaluating all possible moves for a turn in chess   solving a standard x sudoku   reading our entire clrs textbook into a new text f ile   but calling these o is not helpful   it does nothing to illuminate how algorithms to ca rry  out such tasks vary with input sizes   e g  how would the time complexity for a sudoku-s olving algorithm scale up as the  grid size got bigger why are these technically o  because they're all constant  size as specified   but that's not a helpful  observation for asymptotic  complexity i might not usually  consider these to  be  algorithms 