cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   ps due dec     ps sa sa returned   ps sa grading update   project  due pm monday dec      important admin notes  change to syllabus to be counted for credit all pss and sas   including revisions must be submitted by pm sunday dec   extended from dec     final ta hours of semester thursday dec     likely additions to our schedule not yet confirmed   make-up lecture friday dec   at pm more about that soon   office hours monday dec   am more bout that soon  cs --     cs --   bottom-up computation of optimal lcs   value   need m-by-n matrix c to store lengths   actually m-by-n to  include the  case too   to compute cij need values of ci-j- when xi  yj and   ci- j and ci j- when xi  yj   recall our recursive definition   base case cj   and ci   for all i j recursive  step to compute cij for ij    if xi  yj cij  ci-j-    if xi    yj cij  maxcij- ci-j   what is the time complexity of this algorithm   lcsx y  input sequences x y    m  lengthx    n  lengthy    for i   to m do  ci       in first col of each row    for j   to n  do  c j     in first row of each col    for i   to m do        for j   to n do     process row by row             if xi  yj then ci j  ci- j-               else ci j  max ci j- ci- j    return cm n   what is the optimal  length the length  of an lcs of full  sequences  x and y  bottom-up computation of an optimal lcs   to find an lcs also store which symbols indices of symbols   are actually part of the lcs as it's being built  i e   which table elements have optimal sub-problem values   if xi  yj  answer came from the upper left diagonal of current element i e  one less elt  of both x and y   if xi  yj the answer came from above or to the left whichever is larger   if equal we can choose above by convention  i e  either x or y  lcsx y    m  lengthx    n  lengthy    for i   to m do  ci       for j   to n  do  c j      for i   to m do        for j   to n do  bi j  upleft  if xi  yj then ci j  ci- j-    if ci -  j   ci j -  then            else                   bi j  up one less elt  of x      ci j  ci -  j  else ci  j  ci j -   bi j  left one less elt  of y     lcs example  lcs of  x  abcbdab and  y  bdcaba  the algorithm finds  an lcs bcba  are there others  cs --     a few kinds of graph problems   graph representations are very useful and broadly applicable   examples robot navigation  inspection problems   patrol team of robots repeatedly inspects all critical points on a map e g    locations of valuable items to check for intruders or other problems    boundary coverage team of robots completely inspects the boundaries of all   items in a d-mapped environment   pursuit-evasion team of robots corners  captures intruders that are trying to   avoid capture   map visitation team of robots visits every critical point on a map   typically a map underlies these problems  solutions and that map   is represented by a graph  map visitation problem mvp   there are multiple variations on the mvp but we'll look at the multi-  robot multi-depot mvp   optimization problem fastest way for a team of robots starting from a   collection of depot locations on a map to visit all nodes on that map   mvp looks at this as how do we make sure that the last node visited is  visited as soon as possible to get information about every node as soon  as possible  note this isn't the same as say minimizing total distance traveled  by all robots combined it's a different metric for optimization  properties of map  robots for mvp   each robot starts at a specified depot   navigation on the map is pre-computed not figured   out by the robot as it moves    a solution to mvp means at least one robot visits   each point on the map  example     robots  start here        cs --     map visitation problem mvp   so you're at your job and your supervisor tells you to write an   efficient poly-time algo to solve the mvp in the general case not  just special cases of it  what do you do   how would you go about trying to solve  the mvp any ideas  input integer k number of robots   weighted undirected graph g  ve map for visitation    depots dv  vk starting points for each robot  output min-max length of the paths for visiting all nodes in g  given starting depots d  example     robots  start here        map visitation problem mvp   so you're at your job and your supervisor tells you to write an   efficient poly-time algo to solve the mvp in the general case not  just special cases of it  what do you do multiple choice   use a minimum-spanning tree approach    use an all-pairs shortest paths approach    have a long conversation with your supervisor about wasting your time  input integer k number of robots   weighted undirected graph g  ve map for visitation    depots dv  vk starting points for each robot  output min-max length of the paths for visiting all nodes in g  given starting depots d  example     robots  start here        cs --     map visitation problem mvp   so you're at your job and your supervisor tells you to write an   efficient poly-time algo to solve the mvp in the general case not  just special cases of it  what do you do multiple choice   use a minimum-spanning tree approach    use an all-pairs shortest paths approach    have a long conversation with your supervisor about wasting better uses of   your time  options  and  won't work but before you  do option  you should know you're right  input integer k number of robots   weighted undirected graph g  ve map for visitation    depots dv  vk starting points for each robot  output min-max length of the paths for visiting all nodes in g  given starting depots d  example     robots  start here        headlines  coming up on cs   what's the fastest sorting algorithm   is it quicksort    the answer might surprise you or it might not   all the hottest fashion trends for programmers most important   complexity classes for programmers   with essential algos from each one   common myths about recursion debunked   some of the answers here actually might surprise you   how to make an algorithm not just a little faster but a lot faster   could your next problem be np-complete  and how would you know  have you heard of np-completeness  before what do you know about it   plus language  nlp applications a little peek into what a compiler    interpreter does and more  cs --     review subroutines   an algorithm that solves a problem can be used as a subroutine   in another algorithm  key to using subroutines understanding the specifications of the   problems being solved  problem specs given as  input  output descriptions   example subroutine solving merge problem   input arrays a  x    xm and a  y  yn of numbers in sorted   order   output array n  n  nmn of numbers in sorted order combining   all of x    xm and y  yn into n   how could we use a merge subroutine to create a sorting   algorithm  review subroutines and reductions      in general and in these specific examples key to using a  subroutine is to meet its specifications  structure your algorithm to give subroutine the proper input   structure your algorithm to use subroutine's output to solve the original   problem  in these cases can reduce one problem a to another problem  b where there's already a subroutine  algorithm for b  algorithm that does the reducing can be called a reduction   example   mergesort reduced to merge  cs --     cs --   this slide starts getting into non-review material   subroutines and time complexity      in general and in these specific examples key to using a  subroutine is to meet its specifications  structure your algorithm to give subroutine the proper input   structure your algorithm to use subroutine's output to solve the original   problem  in these cases can reduce one problem a to another problem  b where there's already a subroutine  algorithm for b  algorithm that does the reducing can be called a reduction    important but maybe obvious note   complexity of resulting algorithm depends on complexity of subroutine  this is not surprising the complexity of every algorithm depends  on the complexity of its parts  i'm just making that point explicit here  because we'll use it again later     