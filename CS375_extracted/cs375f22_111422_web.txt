 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   sa out due monday nov    possibility of very small sa out today too more on that if it happens   expect ps-lookahead out soon   likely due after thanksgiving break   project  out   deadline extended due end of day nov    note  assume you have constructors and accessors for the  four types  of ples not and or implies similar to ibts and llists   document your function names in your project and u se them as usual as we did for  ibts and llists   project  grading update   in progress but will be slow catching up from il lness may take a  while   please meet with me if you'd like prompt feedback on any part of  project  cs --    recursion-tree method   an example  mergesort  tn  tn   tn  tn   tn   tn   tn  t   t   t   t   t   t   t   t  n tn   k n  n  k n   k n                 log n n log n    t n if  n tn  sorting both halves       n merging otherwise         recursion tree for algorithm  total work done  recursion tree exercises   use the recursion-tree method to solve the following  recurrences for n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     those last three examples illustrate three different cases    the amount of work per level increases with the most work done  at the leaves of the tree    the amount of work per level decreases with the most work  done at the root    the amount of work per level is constant and there  are             lg n   levels in the tree there are lg n   levels in all three cases  really but it's of particular importance here note these three cases  are important we'll  come back to them on a  later slide  cs --    a recurring observation   in general many divide-and-conquer algorithm  runtimes may be expressed as recurrences of the  form   where  a number of sub-problems  nb  size of a sub-problem  dn  time to divide the problem into sub-problems  cn  time to re-combine the sub-problem solutions   if n  k atnb  dn  cn otherwise tn   dn  cn might be represented as a single function fn   i e  work done at each node in a recursion tree  master method   in many common cases there is a cookbook solution  available using the master theorem   master theorem   let a  b   be constants fn be a function asymp  p ositive   and tn be defined by tn  atnb  fn on non-neg  integers   then tn can be bounded asymptotically as follow s    tn  nlog ba if fn  onlog ba- for some constant      tn  nlog balgn         if fn  nlog ba    tn  fn if fn  nlog ba for some constant    and if afnb cfn  for some constant    c   and all sufficiently large n  see section   of clrs  cs --    master terminology   master theorem slightly abridged  elided   let a  b   fn be a function tn  atnb  fn  then    tn  nlog ba if fn  onlog ba- for some constant      tn  nlog balgn         if fn  nlog ba    tn  fn if fn  nlog ba for some constant    and if afnb cfn  for some constant    c   and all sufficiently large n    note comparison of fn with nlog baor nlog ba    case   fn is polynomially smaller than nlog ba  case   fn is asymptotically equal to nlog ba  case   fn is polynomially larger than nlog ba  also case   regularity condition  afnb cfn for   c   etc    intuition amount of work goes down with each recu rsive call i e  number of  times dividing a by bto get o  master key   some intuition behind the master theorem  this isn't obvious  just by looking at  it  please talk with  me outside of  class if you'd like  to understand  this in detail see section    for a proof  cs --    incomplete mastery   master theorem slightly abridged  elided   let a  b   fn be a function tn  atnb  fn  then    tn  nlog ba if fn  onlog ba- for some constant      tn  nlog balgn         if fn  nlog ba    tn  fn if fn  nlog ba for some constant    and if afnb cfn  for some constant    c   and all sufficiently large n    note the three cases are not exhaustive e g    fn may be smaller than nlog ba but not polynomially smaller see cases    fn may be larger than nlog ba but not polynomially larger see cases    if the function falls into one of these gaps or i f the regularity condition  can't be shown to hold the master method can't be used  an example  master theorem slightly abridged  elided    tn  nlog ba if fn  onlog ba- for some constant      tn  nlog balgn         if fn  nlog ba    tn  fn if fn  nlog ba for some constant    and if afnb cfn  for some constant    c   and all sufficiently large n    example  tn  tn  n   a   b   fn  n nlog ba n log   n   so compare fn  n with n  n  on  -   thus case  applies  tn  n   example  tn  tn   i e  fn is polynomially  smaller than n log ba cs --    more examples  master theorem slightly abridged  elided    tn  nlog ba if fn  onlog ba- for some constant      tn  nlog balgn         if fn  nlog ba    tn  fn if fn  nlog ba for some constant    and if afnb cfn  for some constant    c   and all sufficiently large n    examples   tn  tn  n lg n  tn  tn  n lg n  tn  tn  n   tn  tn  n   tn  tn  n  design  paradigm analysis  complexity efficiency correctness  iterative counting  exact count of operations  space used loop invariants  recursive solving recurrences induction  cs --    time complexity classes illustrated  complexity class what we call it example algorithms   objects  o constant print hello world stack operations  and much much more be careful  olg n log time binary search  on linear exhaustive search of an array linear  search merge as used in mergesort on lg n n lg n mergesort heapsort  recall sorting can be done in n lg n  on n-squared quadratic insertion  selection  bubble s ort  several graph algos  on n-cubed cubic my favorite algorithm  a graph algo on exponential number of subsets of a set of size n  on factorial number of orderings  permutations of  elements of a list of length nthe green-shaded ones are examples of polynomial time classes upper bounded by nkfor  some constant k  problems solvable in polynomial time are consider ed tractable  more  about this later in the semester 