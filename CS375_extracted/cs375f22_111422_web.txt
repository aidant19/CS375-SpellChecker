cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   sa out due monday nov    possibility of very small sa out today too more on that if it happens   expect ps-lookahead out soon   likely due after thanksgiving break   project  out   deadline extended due end of day nov     note assume you have constructors and accessors for the four types   of ples not and or implies similar to ibts and llists   document your function names in your project and use them as usual as we did for   ibts and llists   project  grading update   in progress but will be slow catching up from illness may take a   while   please meet with me if you'd like prompt feedback on any part of   project   cs --     recursion-tree method   an example  mergesort             t n             t n            sorting both halves    n   merging  if   n    otherwise  tn  tn  tn  tn  tn  tn  tn  logn  tn  k  t  t  t  t  t  t  t  t  recursion tree for algorithm  n  n  n        k n  k        n   n logn  total work done  recursion tree exercises   use the recursion-tree method to solve the following   recurrences for n    tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n    note these three cases  are important we'll  come back to them on a  later slide   those last three examples illustrate three different cases    the amount of work per level increases with the most work done   at the leaves of the tree    the amount of work per level decreases with the most work   done at the root    the amount of work per level is constant and there are              lg n   levels in the tree  there are lg n   levels in all three cases  really but it's of particular importance here  cs --     cs --   a recurring observation   in general many divide-and-conquer algorithm  runtimes may be expressed as recurrences of the  form  tn     atnb  dn  cn  if n k otherwise   where      a  number of sub-problems  nb  size of a sub-problem    dn  time to divide the problem into sub-problems   cn  time to re-combine the sub-problem solutions  dn  cn might be represented as a single function fn  i e  work done at each node in a recursion tree  see section   of clrs  master method    in many common cases there is a cookbook solution  available using the master theorem   master theorem   let a   b   be constants fn be a function asymp  positive   and tn be defined by tn  atnb  fn on non-neg  integers    then tn can be bounded asymptotically as follows     tn  nlogba if fn  onlogba-   tn  nlogbalgn         if fn  nlogba  if fn  nlogba   tn  fn   for some constant      for some constant      and if afnb  cfn  for some constant   c   and all sufficiently large n     cs --   master terminology   master theorem slightly abridged  elided   let a   b   fn be a function tn  atnb  fn then    tn  nlogba if fn  onlogba-   tn  nlogbalgn         if fn  nlogba  if fn  nlogba   tn  fn   for some constant      for some constant      and if afnb  cfn  for some constant   c   and all sufficiently large n   note comparison of fn with nlogba or nlogba    case   fn is polynomially smaller than nlogba  case   fn is asymptotically equal to nlogba  case   fn is polynomially larger than nlogba  i e  number of  times dividing a by b to get o   also case   regularity condition afnb  cfn for   c   etc    intuition amount of work goes down with each recursive call  master key  see section    for a proof   some intuition behind the master theorem  this isn't obvious  just by looking at  it   please talk with  me outside of  class if you'd like  to understand  this in detail    cs --   incomplete mastery   master theorem slightly abridged  elided   let a   b   fn be a function tn  atnb  fn then    tn  nlogba if fn  onlogba-   tn  nlogbalgn         if fn  nlogba  if fn  nlogba   tn  fn   for some constant      for some constant      and if afnb  cfn  for some constant   c   and all sufficiently large n       note the three cases are not exhaustive e g   fn may be smaller than nlogba but not polynomially smaller see cases   fn may be larger than nlogba but not polynomially larger see cases   if the function falls into one of these gaps or if the regularity condition  can't be shown to hold the master method can't be used  an example  master theorem slightly abridged  elided   tn  nlogba if fn  onlogba-   tn  nlogbalgn         if fn  nlogba  if fn  nlogba   tn  fn   for some constant      for some constant      and if afnb  cfn  for some constant   c   and all sufficiently large n    example  tn  tn  n   a   b   fn  n nlogba  nlog  n  so compare fn  n with n n  on -   thus case  applies  tn  n   example  tn  tn    i e  fn is polynomially  smaller than nlogba    cs --   more examples  master theorem slightly abridged  elided   tn  nlogba if fn  onlogba-   tn  nlogbalgn         if fn  nlogba  if fn  nlogba   tn  fn   for some constant      for some constant      and if afnb  cfn  for some constant   c   and all sufficiently large n    examples   tn  tn  n lg n   tn  tn  n lg n   tn  tn  n  tn  tn  n  tn  tn  n  design  paradigm  iterative  analysis  complexity efficiency  correctness  counting  exact count of operations  space used  loop invariants  recursive  solving recurrences  induction    cs --   the green-shaded ones are examples of polynomial time classes upper bounded by nk for  some constant k  problems solvable in polynomial time are considered tractable  more  about this later in the semester  time complexity classes illustrated  complexity class  what we call it  example algorithms  objects  o  olg n  on  constant  log time  linear  on lg n  n lg n  n-squared quadratic  print hello world stack operations  and much much more be careful  binary search  exhaustive search of an array linear  search merge as used in mergesort  mergesort heapsort recall sorting can be done in n lg n  insertion  selection  bubble sort  several graph algos  on  on  on  on  n-cubed cubic  my favorite algorithm a graph algo  exponential  factorial  number of subsets of a set of size n  number of orderings  permutations of  elements of a list of length n    