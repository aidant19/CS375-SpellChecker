cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   definition   note this definition may  show up on hw too  of our llist data structure    in english we'd say an llist is   either the empty list   or    an element called first   and an llist called rest representing all the elements after first   to be unambiguous about how we work with llists these   will be the primitive functions defined on llists  firstl returns value of the first element of an llist l   restl returns value of the rest sublist of an llist l   consvl a constructor function that takes an item v and an llist l   and returns a new llist l' such that    what do you think it might be  what do you think  the complexities of  these functions are  cs --     business   grading update  ps in progress   expect ps out real soon now   due no sooner than  week after it's assigned   project    first part due already   other parts due nov     please note some restrictions on my schedule    i expect to be traveling on nov   and probably won't be on email or able to  answer questions after noon on that day so please plan accordingly  definition   note this definition may  show up on hw too  of our llist data structure    in english we'd say an llist is   either the empty list  sometimes the empty list is written as     or    an element called first  we could display all llists in  brackets as is usual for lists   and an llist called rest representing all the elements after first   to be unambiguous about how we work with llists these   will be the primitive functions defined on llists  firstl returns value of the first element of an llist l   restl returns value of the rest sublist of an llist l  we'll treat all  three of these as  constant-time fns   consvl a constructor function that takes an item v and an llist l   and returns a new llist l' such that   v is the element first of l'   l is the sublist rest of l'  for example how would you write  this llist as a list in brackets  consconscons   cs --     definition   note this definition may  show up on hw too  of our llist data structure   to be unambiguous about how we work with llists these   will be the primitive functions defined on llists  firstl returns value of the first element of an llist l   restl returns value of the rest sublist of an llist l   consvl a constructor function that takes an item v and an llist l   and returns a new llist l' such that   v is the element first of l'   l is the sublist rest of l'  this convention below is  common in functional programming languages  reminder firstl restl and consvl are functions that return  values they are not fields of an object  because of this we cannot  assign values to them e g  firstl   or restl   is not permitted   what could be done instead with this syntax to change the first  element of some llist l to   definition   note this definition may  show up on hw too  of our llist data structure   to be unambiguous about how we work with llists these   will be the primitive functions defined on llists  firstl returns value of the first element of an llist l   restl returns value of the rest sublist of an llist l   consvl a constructor function that takes an item v and an llist l   and returns a new llist l' such that   v is the element first of l'   l is the sublist rest of l'  this convention below is  common in functional programming languages  reminder firstl restl and consvl are functions that return  values they are not fields of an object  because of this we cannot  assign values to them e g  firstl   or restl   is not permitted   what could be done instead with this syntax to change the first  element of some llist l to  ans we could do l  consrestl   cs --     llist example  remove first occurrence of an element   consider the problem of removing the first occurrence of an element from a   sequence specified here for a list  input item i and llist l  x  xn  output if i  xk and k is the smallest value for which i  xk   return llist x  xk- xk  xn  otherwise i e  when there is no k such that i  xk return l   how would you design an algorithm to solve this problem  it's going to be recursive because  the definition of llist is recursive   follow the definition  llist either empty   or  - element first - llist rest  how would we break the problem  down into  or more smaller  subproblems and then use the  results in a solution for the original  problem  functions on llists  - firstl returns first - restl returns rest - consvl creates new llist with v as first and l as rest  correctness  remove first occurrence of an element   how would you argue the correctness of this algorithm   be sure to refer to these specifications as well as lines of pseudocode   input item i and llist l  x  xn  output if i  xk and k is the smallest value for which i  xk   return llist x  xk- xk  xn  otherwise i e  when there is no k such that i  xk return l   hint it will be an inductive argument because the algo is recursive  algorithm llremovei l  see specification immediately above  if l     return l  else  if i  firstl  return restl  else  return consfirstlllremoveirestl  llist either empty   or  - element first - llist rest  functions on llists  - firstl returns first - restl returns rest - consvl creates new llist with v as first and l as rest  cs --     time complexity of  remove first occurrence of an element   how would you analyze the time complexity of this algorithm  this is something we haven't done before let's think it through  we analyze complexity as a function of input size as usual  let's let n stand for input size and tn stand for time complexity on input of size n  we need to figure out what tn is    what foundations or definitions can we follow   zen principles to help us   well it's recursive    so let's look at the base case and recursive case separately  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstlllremoveirestl  functions on llists  - firstl returns first - restl returns rest - consvl creates new llist with v as first and l as rest  assume all of these functions  are o they would be in  most implementations  recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases  return consfirstl  llremoveirestl    in the base case what is the input size                                                     and what is the runtime of the algo  recall that firstl restl consvl functions are all o  cs --     cs --   recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases  return consfirstl  llremoveirestl    in the base case what is the input size                                                     and what is the runtime of the algo  recall that firstl restl consvl functions are all o  base case    input size empty list n     runtime  do you see why  recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases  return consfirstl  llremoveirestl    in the base case what is the input size                                                     and what is the runtime of the algo  recall that firstl restl consvl functions are all o  base case    input size empty list n     runtime  do you see why  so we'd say t   to  express the base case runtime    cs --   recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove  algorithm llremovei l   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  let's just focus on the  recursive case for now  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases   base case t    return consfirstl  llremoveirestl   how about the recursive case what is the input size and runtime   recursive case we say input is size n as usual l has n elements  also it does some work other than the recursive call combined  do you see why     all of its other runtime is in its recursive call  how would we represent the runtime of   that particular recursive call  recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove  algorithm llremovei l   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  let's just focus on the  recursive case for now  if i  firstl  return restl   because llremove is recursive let's                                                  else  return consfirstl  llremoveirestl  look at the base case  recursive cases   base case t     how about the recursive case what is the input size and runtime   recursive case we say input is size n as usual l has n elements  also it does some work other than the recursive call combined  do you see why     all of its other runtime is in its recursive call      input size to recursive call n-  a list of  less element than l do you see why   how do we express the runtime of that call use our definition of t    cs --   recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove  algorithm llremovei l   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  let's just focus on the  recursive case for now  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases   base case t     recursive case tn  tn-    return consfirstl  llremoveirestl  this may look unusual and recursive but it follows  cleanly from the previous slide  in the recursive case    it does some work other than the recursive call combined   do you see why   all of its other runtime is in its recursive call tn-   recurrences for time complexity   of recursive functions   putting all the pieces together so far there's more coming up   let's let n stand for input size and tn stand for time complexity on input of size n  we need to figure out what tn is    let's look at the base case and recursive case   separately  the base case prev  slide is t      what's the complexity in the recursive case tn  tn-    the time taken by everything but the recursive call is just  do you see why   and the recursive call is on input of size n-   so by our definition of function t complexity of the recursive call is tn-   algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  do you see how this  characterization of tn  exactly fits our  llremovel algo  return consfirstlllremoveirestl  let's put the pieces together  for n   t    for n     tn  tn-    that is a full definition of the  complexity of this algorithm  both the base case and the  recursive case    cs --   solving a time complexity   recurrence   let's focus on our definition of runtime function tn and how to use it   for n   t    for n   tn  tn-      important vocabulary   we say this definition of tn is a recurrence it defines tn in terms of itself   note that it follows good design principles for recursive definitions   it has a base case   its recursive case is defined in terms   of itself on smaller inputs   indeed the two parts together are   a complete definition of the runtime   but we're not done yet what's the   asymptotic complexity of llremove  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl    