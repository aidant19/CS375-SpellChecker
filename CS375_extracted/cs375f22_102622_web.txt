 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   grading update   sa returned   ps extended  unusual deadline   due pm today   project    first part due already   other parts due nov     please schedule dress rehearsals with me for frida y  saturday  i will not be available for them next tuesday or la ter  cs --    business project    project  out due nov     parts of project     design exhaustive search algorithms  your team will collectively design  exhaustive search algorithms for  problems     improve time efficiency  your team will pick one of the problems and make  your exhaustive search algorithm more efficient     reduction  for the same problem chosen for part   above you will reduce that problem to one of the  other seven problems from part      create and give a presentation  your team will  present work from the previous three parts of the  assignment using loop invariants where  appropriate to explain correctness  hint  your team may  want to be strategic  about which of the   problems you choose to  focus on for your  improvements  reduction and  presentation  pick a  problem for which you  can do good work have you read through proj yet  would you have preferred the assignment sheet  to be broken up into separate documents   cs --    common myths about recursion  debunked   what impressions do you have about recursion   here are some things i've heard paraphrased slightly   recursion is basically just a party trick   recursive design is just trial and error   recursion is slow compared to iteration   people don't really use recursion admittedly i've mostly heard them in the context o f a student saying  i used to think this was true but now i don't anym ore  but still i've heard them or something very much l ike them  if there's anything you'd like to add to this list  let me know it's actually very useful  there are methods to use  people really do it can be very natural to use well sort of  it can be  but it's not as bad as i t used to be  and related concepts can enable some very fast code   a functional digression  the functional programming paradigm   some important features of pure functional programming   immutable data   stateless functions everything self-contained  no side effects   uses recursion for iteration rather than loops  supports parallel computation recall applications to data science   code can be easier to show correct  debug  for those of us who like to think about programming  languages at the theory  and design level it may be interesting to note tha t the last three of the above  five features kinda follow from the first two  this is subtle and well beyond the scope of cs but please feel free to  talk with me more about it outside of class if you 'd like  cs --    zen and the art of  algorithm design   a couple of generally good ideas principles to help you  design your algorithms and their implementations   i might restate principle  as  keep your foundations simple   i might restate principle  as  let your definitions tell you what to do   let's apply this to binary trees   the foundations i e  relevant definitions and dat a  structures should be as simple as possible while sti ll  providing all needed functionality    let the foundations guide the development and ana lysis  of algorithms based on them  binary trees a review   remember binary trees from cs  this figure from clrs illustrates that binary trees  could in principle  contain the same data in different tree structures parts a and b   part c shows external nodes the null fields in a typical implementation  of a binary tree  they can be thought of as empty s ub-trees in context   external nodes are hidden in parts a and b   cs --    binary trees a review   remember binary trees from cs   application binary search trees bst's   what's a good definition of a binary tree  note this isn't asking about the definition of a b st but  about the more general data structure of a binary t ree  just as a reminder of where  you've seen binary trees  before  both of these are  examples of a binary search  tree a specific kind of  binary tree   in our work over the several  slides we'll talk not about  bst's but about binary  trees in general  one possible definition of  binary tree   often an implementation of a binary tree is based  on two classes a  node class and a tree class as well as a type t o f data to store   nodet class has fields  item  t  the data stored at the node a value of type t left  node  the left sub-tree represented by its root node  right  node  the right sub-tree represented by its root  node    and perhaps others    treet class has fields  root  nodet  the root node which represents the tree   and perhaps others such as   size  int  the number of nodes in the tree  if we wanted a data structure just to be a binary t ree of integers  for example would we need all of this structure is this a good definition consider principle   keep your foundations simple   cs --    definition  of our intbintree data structure   throughout cs we will sometimes refer to an intbintree  data structure representing a binary tree of integers   in english we'd say an intbintree is   either empty   or   an int called val   and two subtrees called left and right  that are also intbintrees   programmers might be used to seeing it more like this  definition intbintree empty or  int val  the int value not empty  intbintree left  the left subtree  intbintree right  the right subtree is this a good definition consider principle   keep your foundations simple  note this definition may  show up on hw too  is this definition equivalent  to the english one above  the fact that a tree could be  empty is often implicit in  many specifications  definition  of our intbintree data structure   in english we'd say an intbintree is   either empty   or   an int called val   and two subtrees called left and right  that are also intbintrees   to be unambiguous  and consistent with functional  programming  about how we work with ibts these will be  the primitive functions defined on ibts   val t returns the val element of an ibt t  left t returns the left subtree of an ibt t  right t returns the right subtree of an ibt tnote this definition may  show up on hw too  we'll call them ibt s for short  important note valt leftt and rightt are functions that return values  they are not fields of an object  because of this we cannot assign values  to them e g  valt   is not permitted for cs these are the  only ways to access val  left right   so something  like t val is not permitted   cs --    intbintrees an exercise   design an algorithm to return the number of levels in an  intbintree   what design paradigm will we use for this algorithm   will it be iterative or recursive  as intbintrees we would say  -tree a has  levels and  -tree b has  levels  consider principle  let your definitions tell yo u what to do   how does our definition of an intbintree tell us wh at to do here definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  intbintrees an exercise   design an algorithm to return the number of levels in an  intbintree  because the definition of intbintree is recursive it makes  sense that algorithms over it would be recursive  as intbintrees we would say  -tree a has  levels and  -tree b has  levels  in fact because an intbintree is defined recursive ly in terms of two intbintrees  it might make sense for an algo over intbintree to have two recursive calls  that's an example of principle  letting definition s tell us what to do  definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  cs --    a review of recursive design  divide and conquer   every recursive algorithm has the following components  base cases  one or more small cases for which it is easy to  identify or compute and return a solution  recursive cases  one or more cases in which the algorithm calls  itself on a smaller instance of its input  divide  the algorithm must break the original problem input  down into smaller sub-problems sub-inputs on which the algo  can be called recursively  conquer  the algorithm must solve each of the sub- problems  combine  the algorithm must combine  employ the solutions   of sub-problems into a solution of the original pro blem  recursive cases bring input closer to terminating in a base case  it's really important that  recursions terminate  intbintrees an exercise   design an algorithm to return the number of levels in an  intbintree   reminder in english an intbintree  is either empty or  an int and two subtrees   for our recursive algorithm to compute the number of levels   what are the input and output   what input does the base case check for   what's the intended output for the base case   how many recursive calls will the algorithm make   how do we use output from  recursive calls to compute  the output on the given input definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  it can be helpful to write down  a problem specification with  input and output types    cs --    intbintrees an exercise   design an algorithm to return the number of levels in an  intbintree   reminder in english an intbintree  is either empty or  an int and two subtrees   our recursive algorithm to compute the number of levels   how would we explain this algorithm's correctness definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  algorithm levelst  input intbintree t output integer number of levels in t  if t is empty  return   else  return maxlevelsleftt levelsrightt    correctness of recursive  algorithms inductive arguments   when arguing the correctness of a recursive algorithm the  general form is that of an inductive argument   the explanation follows the structure of the algorithm   show that the algorithm's base case returns correc t output   show that the recursive cases return correct outpu t  under the assumption that all recursive calls retur n correct output   here how would that work   how would we explain the  base case the recursive case just like when creating recursive code we assume rec ursive calls work in the  recursive case  algorithm levelst  input intbintree t output integer number of levels in t  if t is empty  return   else  return maxlevelsleftt levelsrightt    cs --    correctness of recursive  algorithms inductive arguments   when arguing the correctness of a recursive algorithm the  general form is that of an inductive argument   the explanation follows the structure of the algorithm   show that the algorithm's base case returns correc t output   show that the recursive cases return correct outpu t  under the assumption that all recursive calls retur n correct output   as part of explaining recursive  cases also explain how we  know the algo terminates   show arguments in recursive  calls get closer to base case just like when creating recursive code we assume rec ursive calls work in the  recursive case  algorithm levelst  input intbintree t output integer number of levels in t  if t is empty  return   else  return maxlevelsleftt levelsrightt    another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere  in an intbintree   how would we write the problem specification for ibtsearch   what would be the input   what would be correct output   how would we design an  algorithm to solve it   would the algorithm be iterative or recursive   how would we argue its correctness definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  cs --    another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere  in an intbintree   how would we write the problem specification for ibtsearch   input an int i and an intbintree t  output true exactly when iis in t false otherwise definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  algorithm ibtsearchi t  input int i intbintree t output true exactly when iis in t false otherwise  another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere  in an intbintree   how would we write the problem specification for ibtsearch   input an int i and an intbintree t  output true exactly when iis in t false otherwise definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  algorithm ibtsearchi t  input int i intbintree t output true exactly when iis in t false otherwise  if t  empty  return false  else  if valt  i  return true  else  return ibtsearchileftt or ibtsearchirightt  the last line uses the  boolean operator or   which is inclusive  it is  true when either or  both operands are true 