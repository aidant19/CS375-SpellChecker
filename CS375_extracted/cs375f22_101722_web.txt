cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   thank you again to those who participated in class discussion oct     please come talk with me about any aspect of that you'd like to discuss   grading update   ps returned   ps in progress   project returned for groups that submitted on time  following instructions   slight delay for others coming soon   a note about grading in cs in general and on proj in particular   median grade on proj   scales to at least a b    so about sorting method     sa due already   note i found a typo in the hint for part c of the invariants-explanation   assignment said loop ended with i  n instead of i  n   revised sa now posted with a revised hint but no other differences   ps out due oct    cs --     business project    project  out very soon   multi-stage project with final due date in early november   project  is to be done in teams of    important by end of day wednesday oct   one person from each team   should email me and everyone on the team to let me know they're teaming up   if you'd like my help finding a team for you please let me know   parts of project     design exhaustive search algorithms your team will collectively design   exhaustive search algorithms for a variety of problems     improve time efficiency your team will pick one of the problems and make   your exhaustive search algorithm more efficient     reduction for the same problem chosen for part  above you will reduce that   problem to one of the other problems given in part   this is a new topic for  us more soon    create and give a presentation your team will present work from the   previous three parts of the assignment using loop invariants where appropriate  to explain the correctness of your algorithms   using loop invariants in   algorithm design and explanations   loop invariants state properties known to be true for each iteration of a loop   can think of it as a property known to be true immediately before and   immediately after each iteration    in our examples we've understood loop invariants in terms of before and  after conditions   before what is helpful and known to be true before a given iteration of the loop   after what is helpful and known to be true after a given iteration of the loop   which establishes the truth of the before condition before the next iteration   key point loop invariant gives a property that's true after the loop is   finished that helps explain algo correctness  to informally use loop invariants to help explain algo correctness  explain how the invariant is true before the first iteration of the loop  explain how the invariant is true after each following iteration  explain how the invariant property shows that the algo meets its   specifications  cs --     a logical digression  logical reasoning about empty stuff   how does it work if we're asked if something is true for all elements of an   empty structure   examples   say l is a list of strings and l is empty  is it true that every string on the list   has length greater than    say s is a set of numbers and s is empty  is it true that every number in s is   equal to    the answer to these questions is yes it is true  we say it is vacuously true    part of the way propositional logic works is that when we ask if some   property is true of every element in some empty structure     the answer is always yes because there are no elements to reason   about we can vacuously say anything is true of anything in that empty set  this follows from the same idea that once it is shown that false  true  the system is incoherent so we can say anything is true in that system  a logical digression  vacuous truth   how does it work if we're asked if something is true for all elements of an   empty structure   more examples   say l is a list of numbers and l is empty  is it true that l is in sorted order    say l is a list of numbers and l is empty  is it true that l is out of sorted   order    the answer to these questions is yes they are vacuously true  this can be useful as part of using loop invariants especially when showing  a property is true in some boundary case either before the first iteration of  a loop or after the last iteration of a loop  it's completely understandable if you're not feeling totally happy about this dealing  with logical incoherence is tricky  it turns out though this convention of vacuous truth can be really useful and it  gets very intuitive after a while  cs --     cs --   example of reasoning with vacuous truth  loop invariants and bubble sort      yes bubble sort is the actual name of this sorting algorithm  in pseudocode  what's the time complexity of this algorithm  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-   do you understand how the algo works try it on a   how do we use loop invariants to show correctness i e  that   it sorts a in non-decreasing order   example of reasoning with vacuous truth loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b   use invariant to show correctness    show invariant is true before first loop iteration how    show pseudocode ensures invariant is true after each successive iteration   assuming that it's true at the start of the iteration how    show when loop is done algorithm meets specifications how    cs --   example of reasoning with vacuous truth loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b   use invariant to show correctness    show invariant is true before first loop iteration how   before the first iteration i is set to   for the invariant we look at a  i-  a     by convention a   is an empty array    so it vacuously contains the i- smallest values of a in sorted order  example of reasoning with vacuous truth loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b   use invariant to show correctness  super important note show that the entire invariant is true not just part of it  a   vacuously contains the i- smallest values of a in sorted order   we still need to explain how a  n consists of the remaining values of a no   constraint on order but that's not that difficult    cs --   explaining correctness  loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta     for i          to a length    for j  a length downto i  if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b   use invariant to show correctness    show invariant is true before first loop iteration done    show pseudocode ensures invariant is true after each successive iteration   assuming that it's true at the start of the iteration how    show when loop is done algorithm meets specifications how  explaining correctness step   loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b    show pseudocode ensures invariant is true after each successive iteration   assuming that it's true at the start of the iteration   there are many right ways to do this step it's all about explaining how the algo works  refer directly to the pseudocode in your explanation citing specific lines of pseudocode  how might we structure this explanation    cs --   explaining correctness step   loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b    show pseudocode ensures invariant is true after each successive iteration   assuming that it's true at the start of the iteration   one possible explanation idea   each iteration of the inner loop ensures after the swap that aj- is smaller than aj  for each i at the end of the inner loop in lines - the smallest value remaining in   ai  n has been swapped down the array into position ai  explaining correctness step   loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b    show when loop is done algorithm meets specifications   there are many right ways to do this step too  refer directly to the invariant property and to the specifications in your explanation   referring to specifications is essential for showing algo correctness    cs --   explaining correctness step   loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b    show when loop is done algorithm meets specifications   one possible explanation idea with important details omitted   because the invariant is true at the end of the outer loop when i  n we know a  n-  contains the n- smallest values of a in sorted order then an must be the largest value in a do you see why and can you fill this in     so the elements in a are in sorted order do you see why which meets the   specifications of the sorting problem so the algorithm is correct  algorithm correctness and loop invariants   a recap  see clrs     to explain correctness of iterative algos look at the loop   loop invariants can help three steps to using loop invariants    show the invariant is true before the first iteration    show the invariant stays true after each successive iteration   assuming it was true before that iteration    show the algo meets specifications using what the invariant says is   true after the loop is done  these three steps correspond to three parts mentioned in our clrs textbook     maintenance if a property is true before an iteration it is true after that iteration  before the next   initialization property is true before the first iteration  iteration    termination when the loop terminates the property is useful in showing algorithm correctness you do not need to use these three terms from clrs for cs when discussing invariants although  you can if you want to i just wanted to connect our approach in this slides to our textbook    cs --   the green-shaded ones are examples of polynomial time classes upper bounded by nk for  some constant k  problems solvable in polynomial time are considered tractable  more  about this later in the semester  time complexity classes illustrated  complexity class  what we call it  example algorithms  objects  o  olg n  on  constant  log time  linear  on lg n  n lg n  n-squared quadratic  print hello world stack operations  and much much more be careful  binary search  exhaustive search of an array linear  search merge as used in mergesort  mergesort heapsort recall sorting can be done in n lg n  insertion  selection  bubble sort  several graph algos  on  on  on  on  n-cubed cubic  my favorite algorithm a graph algo  exponential  factorial  number of subsets of a set of size n  number of orderings  permutations of  elements of a list of length n    cs --   constant time   o usually refers to primitive operations   printing a finite string print hello world   accessing an array  i might not usually  consider these to  be  algorithms   copying a reference or value into a variable of fixed constant size    or to a constant number of them to complete a task compare and swap   two elements which can be very useful  constant time   o usually refers to primitive operations   printing a finite string print hello world   accessing an array  i might not usually  consider these to  be  algorithms   copying a reference or value into a variable of fixed constant size    or to a constant number of them to complete a task compare and swap   two elements which can be very useful   pro tip  warning technically by definition of asymptotic complexity  the time complexity of the following are all upper bounded by a constant  evaluating all possible moves for a turn in chess  why are these technically  o   solving a standard x sudoku   reading our entire clrs textbook into a new text file    cs --   constant time   o usually refers to primitive operations   printing a finite string print hello world   accessing an array  i might not usually  consider these to  be  algorithms   copying a reference or value into a variable of fixed constant size    or to a constant number of them to complete a task compare and swap   two elements which can be very useful   pro tip  warning technically by definition of asymptotic complexity  the time complexity of the following are all upper bounded by a constant  evaluating all possible moves for a turn in chess   solving a standard x sudoku   reading our entire clrs textbook into a new text file   but calling these o is not helpful    it does nothing to illuminate how algorithms to carry   out such tasks vary with input sizes  why are these technically  o  because they're all constant   size as specified   but that's not a helpful  observation for asymptotic  complexity   e g  how would the time complexity for a sudoku-solving algorithm scale up as the   grid size got bigger     