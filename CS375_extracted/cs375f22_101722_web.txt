CS   CS   Analysis of Algorithms Professor Eric Aaron Lecture  M W pm Lecture Meeting Location Davis  Business  Thank you again to those who participated in class  discussion Oct   Please come talk with me about any aspect of that youd like to discuss  Grading update  PS returned  PS in progress  Project returned for groups that submitted on tim e  following instructions  Slight delay for otherscoming soon  A note about grading in CS in general and on P roj in particular  Median grade on Proj  Scales to at least a  B  So about Sorting Method   SA due already NOTE I found a typo in the hint for part cof the invariantsexplanation  Assignment said loop ended with i  n  instead of i  n  Revised SA now posted with a revised hint but no  other differences  PS out due Oct  CS   Business Project   Project  out very soon  Multistage project with final due date in early November Project  is to be done in teams of  IMPORTANT By end of day Wednesday Oct  one p erson from each team should email me and everyone on the team to let me know theyre teaming up  If youd like my help finding a team for you plea se let me know  Parts of Project   Design Exhaustive Search Algorithms  Your team will collectively design exhaustive search algorithms for a variety of probl ems  Improve Time Efficiency  Your team will pick one of the problems and make your exhaustive search algorithm more efficient  Reduction  For the same problem chosen for part  above you  will reduce that problem to one of the other problems given in part  This is a new topic for usmore soon  Create and Give a Presentation  Your team will present work from the previous three parts of the assignment using loop invariants where appropriate to explain the correctness of your algorithms Using Loop Invariants in Algorithm Design and Explanations  Loop invariants state properties known to be true for each iteration of a loop  Can think of it as a property known to be true imm ediately before and immediately after each iteration  In our examples weve understood loop invariants in terms of before and after conditions Before  What is helpful and known to be true before a giv en iteration of the loop After  What is helpful and known to be true after a give n iteration of the loop which establishes the truth of the Before condition before the next iteration  Key point Loop invariant gives a property thats true after the loop is finished that helps explain algo correctness To informally use loop invariants to help explain  algo correctness Explain how the invariant is true before the first iteration of the loop Explain how the invariant is true after each follow ing iteration Explain how the invariant property shows that the a lgo meets its specifications CS   A Logical Digression Logical Reasoning About Empty Stuff  How does it work if were asked if something is tr ue for all elements of an empty structure  Examples  Say L is a list of strings and L is empty Is it true that every string on the list has length greater than   Say S is a set of numbers and S is empty Is it t rue that every number in S is equal to   The answer to these questions is Yes it is true  We say it is vacuously true  Part of the way propositional logic works is that when we ask if some property is true of every element in some empty structure   the answer is always yes Because there are no el ements to reason about we can vacuously say anything is true of anything in that empty set This follows from the same idea that once it is sho wn that False  True the system is incoherent so we can say anything is  True in that system A Logical Digression Vacuous Truth  How does it work if were asked if something is tr ue for all elements of an empty structure  More Examples  Say L is a list of numbers and L is empty Is it true that L is in sorted order   Say L is a list of numbers and L is empty Is it true that L is out of sorted order   The answer to these questions is Yesthey are vacuously true Its completely understandable if youre not feelin g totally happy about thisdealing with logical incoherence is tricky It turns out though this convention of vacuous tr uth can be really useful and it gets very intuitive after a while This can be useful as part of using loop invariants  especially when showing a property is true in some boundary caseeither before the first iteration of a loop or after the last iteration of a loop CS   Example of Reasoning with Vacuous Truth Loop Invariants and Bubble Sort  Yes bubble sort is the actual name of this sorting algorithm  In pseudocode  Do you understand how the algo works Try it on A  How do we use loop invariants to show correctness ie that it sorts A in nondecreasing order BubbleSortA  for i    to Alength   for j  Alength downto i  if Aj  Aj  swap Aj with Aj Whats the time complexity of this algorithm Example of Reasoning with Vacuous Truth Loop Invariants and Bubble Sort  On  Loop invariant for outer loop  Use invariant to show correctness  Show invariant is true before first loop iteratio n How  Show pseudocode ensures invariant is true after e ach successive iteration assuming that its true at the start of the iterati on How  Show when loop is done algorithm meets specifica tions How BubbleSortA  for i    to Alength   for j  Alength downto i  if Aj  Aj  swap Aj with Aj Subarray Ai consists of the i smallest val ues of A in sorted order and Ain consists of the rem aining values of A no constraint on order Sorting Problem Input Sequence of  numbers a   a nOutput Permutation reordering b   bn of the input sequence perhaps leaving them unchanged such that b  b     b nCS   Example of Reasoning with Vacuous Truth Loop Invariants and Bubble Sort  On  Loop invariant for outer loop  Use invariant to show correctness  Show invariant is true before first loop iteratio n How BubbleSortA  for i    to Alength   for j  Alength downto i  if Aj  Aj  swap Aj with Aj Subarray Ai consists of the i smallest val ues of A in sorted order and Ain consists of the rem aining values of A no constraint on order Sorting Problem Input Sequence of  numbers a   a nOutput Permutation reordering b   bn of the input sequence perhaps leaving them unchanged such that b  b     b nBefore the first iteration iis set to  For the invariant we look at Ai   A By convention A is an empty array  So it vacuously contains the i smallest values of A in sorted order Example of Reasoning with Vacuous Truth Loop Invariants and Bubble Sort  On  Loop invariant for outer loop  Use invariant to show correctnessBubbleSortA  for i    to Alength   for j  Alength downto i  if Aj  Aj  swap Aj with Aj Subarray Ai consists of the i smallest val ues of A in sorted order and Ain consists of the rem aining values of A no constraint on order Sorting Problem Input Sequence of  numbers a   a nOutput Permutation reordering b   bn of the input sequence perhaps leaving them unchanged such that b  b     b nSuper Important Note  Show that the entire invariant is true not just part of it A vacuously contains the i smallest values of A in sorted order We still need to explain how An consists of th e remaining values of A no constraint on order but thats not that difficult CS   Explaining Correctness Loop Invariants and Bubble Sort  On  Loop invariant for outer loop  Use invariant to show correctness  Show invariant is true before first loop iteratio n Done  Show pseudocode ensures invariant is true after e ach successive iteration assuming that its true at the start of the iterati on How  Show when loop is done algorithm meets specifica tions How BubbleSortA  for i   to Alength   for j  Alength downto i  if Aj  Aj  swap Aj with Aj Subarray Ai consists of the i smallest val ues of A in sorted order and Ain consists of the rem aining values of A no constraint on order Sorting Problem Input Sequence of  numbers a   a nOutput Permutation reordering b   bn of the input sequence perhaps leaving them unchanged such that b  b     b nExplaining Correctness step  Loop Invariants and Bubble Sort  On  Loop invariant for outer loop  Show pseudocode ensures invariant is true after e ach successive iteration assuming that its true at the start of the iterati on BubbleSortA  for i    to Alength   for j  Alength downto i  if Aj  Aj  swap Aj with Aj Subarray Ai consists of the i smallest val ues of A in sorted order and Ain consists of the rem aining values of A no constraint on order Sorting Problem Input Sequence of  numbers a   a nOutput Permutation reordering b   bn of the input sequence perhaps leaving them unchanged such that b  b     b nThere are many right ways to do this stepits all a bout explaining how the algo works Refer directly to the pseudocode in your explanatio n citing specific lines of pseudocode How might we structure this explanation CS   Explaining Correctness step  Loop Invariants and Bubble Sort  On  Loop invariant for outer loop  Show pseudocode ensures invariant is true after e ach successive iteration assuming that its true at the start of the iterati on BubbleSortA  for i    to Alength   for j  Alength downto i  if Aj  Aj  swap Aj with Aj Subarray Ai consists of the i smallest val ues of A in sorted order and Ain consists of the rem aining values of A no constraint on order Sorting Problem Input Sequence of  numbers a   a nOutput Permutation reordering b   bn of the input sequence perhaps leaving them unchanged such that b  b     b nOne possible explanation idea Each iteration of the inner loop ensures after the swap  that Aj is smaller than Aj For each i at the end of the inner loop in lines   the smallest value remaining in Ain has been swapped down the array into positi on AiExplaining Correctness step  Loop Invariants and Bubble Sort  On  Loop invariant for outer loop  Show when loop is done algorithm meets specifica tions BubbleSortA  for i    to Alength   for j  Alength downto i  if Aj  Aj  swap Aj with Aj Subarray Ai consists of the i smallest val ues of A in sorted order and Ain consists of the rem aining values of A no constraint on order Sorting Problem Input Sequence of  numbers a   a nOutput Permutation reordering b   bn of the input sequence perhaps leaving them unchanged such that b  b     b nThere are many right ways to do this step too Refer directly to the invariant property and to the  specifications in your explanationreferring to specifications is essential for showin g algo correctness CS   Explaining Correctness step  Loop Invariants and Bubble Sort  On  Loop invariant for outer loop  Show when loop is done algorithm meets specifica tions BubbleSortA  for i    to Alength   for j  Alength downto i  if Aj  Aj  swap Aj with Aj Subarray Ai consists of the i smallest val ues of A in sorted order and Ain consists of the rem aining values of A no constraint on order Sorting Problem Input Sequence of  numbers a   a nOutput Permutation reordering b   bn of the input sequence perhaps leaving them unchanged such that b  b     b nOne possible explanation idea with important detai ls omitted Because the invariant is true at the end of the out er loop when i  n  we know An contains the nsmallest values of Ain sorted order Then An must be the largest value in A  do you see why  and  can you fill this in So the elements in A are in sorted order  do you see why  which meets the specifications of the sorting problem so the algor ithm is correct Algorithm Correctness and Loop Invariants A Recap  To explain correctness of iterative algos look at the loop  Loop invariants can help Three steps to using loop invariants  Show the invariant is true before the first itera tion  Show the invariant stays true after each successi ve iteration assuming it was true before that iteration  Show the algo meets specifications using what the  invariant says is true after the loop is done See CLRS  These three steps correspond to three parts mention ed in our CLRS textbook  Initialization Property is true before the first iteration  Maintenance If a property is true before an iteration it is tr ue after that iteration  before the next iteration  Termination When the loop terminates the property is useful in  showing algorithm correctness You do not need to use these three terms from CLRS for CS when discussing invariants although you can if you want toI just wanted to connect our approach in this slides to our textbook CS   Time Complexity Classes Illustrated Complexity Class What we call it Example algorithms   objects O Constant Print Hello World stack operations and much much morebe careful Olg n Log time Binary search On Linear Exhaustive search of an array linear search Merge as used in MergesortOn lg n n lg n Mergesort Heapsort Recall sorting can be done in n lg n On nsquared quadratic Insertion  selection  bubble s ort several graph algos On ncubed cubic My favorite algorithm  a graph algoOn Exponential Number of subsets of a set of size n On Factorial Number of orderings  permutations of elements of a list of length nThe greenshaded ones are examples of polynomial time classesupper bounded by nkfor some constant k Problems solvable in polynomial time are consider ed tractable More about this later in the semester CS   Constant Time  O usually refers to primitive operations  Printing a finite string print Hello World  Accessing an array  Copying a reference or value into a variable of fi xed constant size   or to a constant number of them to complete a tas k compare and swap two elementswhich can be very useful I might not usually consider these to be  algorithms Constant Time  O usually refers to primitive operations  Printing a finite string print Hello World  Accessing an array  Copying a reference or value into a variable of fi xed constant size   or to a constant number of them to complete a tas k compare and swap two elementswhich can be very usefulPro Tip  Warning Technically by definition of asymptotic complexity  the time complexity of the following are all upper bounded by a constant  Evaluating all possible moves for a turn in chess  Solving a standard x Sudoku  Reading our entire CLRS textbook into a new text f ile I might not usually consider these to be  algorithms Why are these technically O CS   Constant Time  O usually refers to primitive operations  Printing a finite string print Hello World  Accessing an array  Copying a reference or value into a variable of fi xed constant size   or to a constant number of them to complete a tas k compare and swap two elementswhich can be very useful Pro Tip  Warning Technically by definition of asymptotic complexity  the time complexity of the following are all upper bounded by a constant  Evaluating all possible moves for a turn in chess  Solving a standard x Sudoku  Reading our entire CLRS textbook into a new text f ile  But calling these O is not helpful  It does nothing to illuminate how algorithms to ca rry out such tasks vary with input sizes  Eg how would the time complexity for a sudokus olving algorithm scale up as the grid size got bigger Why are these technically O Because theyre all constant size as specified But thats not a helpful observation for asymptotic complexity I might not usually consider these to be  algorithms 