cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   ps due dec     sa returned   ps grading update   project  due pm monday dec      important admin notes  change to syllabus to be counted for credit all pss and sas   including revisions must be submitted by pm sunday dec   extended from dec     final ta hours of semester thursday dec     additions to our schedule   make-up lecture friday dec   at pm davis    office hours monday dec   am  acknowledgment some ideas in today's notes are influenced by  httpswww cs princeton eduwaynecslecturesnp-complete  cs --     which is easier pt     which is easier finding a solution or checking  verifying a   solution   consider the problem of checking if a number is composite   i e  not a prime number  input integer n  this kind of thing can be useful in  cryptography applications   output yes if n is composite if there exists some number   c  n   such that n is a multiple of c no otherwise i e  n is prime   which is easier   finding if n   is composite or   checking that c   is a factor of n  it's useful to think of this  as solving the problem  when you're given a  solution and all you  have to do is confirm it  thanks to httpswww cs princeton eduwaynecslecturesnp-complete  which is easier pt     which is easier finding a solution or checking  verifying a   solution   consider the problem of checking if a number is composite   i e  not a prime number  input integer n  this kind of thing can be useful in  cryptography applications   output yes if n is composite if there exists some number   c  n   such that n is a multiple of c no otherwise i e  n is prime   which is easier   finding if n   is composite or   checking that c   is a factor of n  here  is a certificate  vocabulary certificate  we call the possible   solution that was given  to us to be checked a  certificate  thanks to httpswww cs princeton eduwaynecslecturesnp-complete  cs --     which is easier pt     which is easier finding a solution or checking  verifying a   solution   a clique in an undirected graph gve is a subset v'v   s t  each pair in v' is connected by an edge in e  i e  a clique corresponds to a complete subgraph of g   the clique problem    input graph g and integer k    output yes if there is a clique of   size k in g no otherwise   which is easier   finding a clique of size  in a graph g or   checking that vertices uvxy are a clique of size  in graph g  vocab review here the set uvxy would be a certificate  which is easier pt     which is easier an optimization problem or its related   decision problem   consider the optimization problem of finding a minimum   spanning tree mst of a graph  compare that to the related decision problem mst-decision   given a graph g and a number w does g have an mst with total  weight at most w  cs --     cs --   which is easier pt     which is easier an optimization problem or its related   decision problem   consider the optimization problem of finding a minimum   spanning tree mst of a graph  compare that to the related decision problem mst-decision   given a graph g and a number w does g have an mst with total  weight at most w  some observations       if it's easy fast to solve the optimization problem it's easy fast to solve the  decision problem just use the optimization problem answer it's not true the other way around if it's easy fast to solve the decision problem  for a particular value of w it's not necessarily easy to solve the optimization  problem you might have to check a lot of different values of w  which is easier pt     which is easier an optimization problem or its related   decision problem   consider the optimization problem of finding a minimum   spanning tree mst of a graph  compare that to the related decision problem mst-decision   given a graph g and a number w does g have an mst with total  weight at most w  some observations       if it's easy fast to solve the optimization problem it's easy fast to solve the  decision problem just use the optimization problem answer it's not true the other way around if it's easy fast to solve the decision problem  for a particular value of w it's not necessarily easy to solve the optimization  problem you might have to check a lot of different values of w    so if the decision problem can't be solved easily we know the optimization  problem can't be solved easily either this is subtle let's think about it     cs --     map visitation problem mvp   so you're at your job and your supervisor tells you to write an   efficient poly-time algo to solve the mvp in the general case not  just special cases of it  what do you do multiple choice   use a minimum-spanning tree approach    use an all-pairs shortest paths approach    have a long conversation with your supervisor about wasting better uses of   your time  options  and  won't work but before you  do option  you should know you're right  input integer k number of robots   weighted undirected graph g  ve map for visitation    depots dv  vk starting points for each robot  output min-max length of the paths for visiting all nodes in g  given starting depots d  example     robots  start here        review reductions   subroutines and time complexity      in general and in these specific examples key to using a  subroutine is to meet its specifications  structure your algorithm to give subroutine the proper input   structure your algorithm to use subroutine's output to solve the original   problem  in these cases can reduce one problem a to another problem  b where there's already a subroutine  algorithm for b  algorithm that does the reducing can be called a reduction    important but maybe obvious note   complexity of resulting algorithm depends on complexity of subroutine  this is not surprising the complexity of every algorithm depends  on the complexity of its parts  i'm just making that point explicit here  because we'll use it again later   we'll be considering decision problems from here on out unless otherwise specified  graph problems clique   a clique in an undirected graph gve is a subset v'v s t    each pair in v' is connected by an edge in e  i e  a clique corresponds to a complete subgraph of g   the clique problem    input graph g and integer k   output yes if there is a clique of size k in g no otherwise  on project  someone on your team  designed a brute force algorithm for  clique that was not polynomial time  poly time for short    can you design a poly time algorithm  for clique  cs --     graph problems vertex cover  also called network cover on project    a vertex cover of an undirected graph gve is a subset v'v s t  if   uv is in e then at least one of u or v is in v'   that is if a vertex covers its incident edges a vertex cover is a set that   covers all of e   the size of a vertex cover is the number of vertices in it   the vertex cover problem   input graph g and integer k   output yes if there is a vertex cover of g with size k no otherwise  graph for which vertex set w z is a vertex  cover of size    graph problems and subroutines    reductions   recall focusing only on decision problems   the clique problem    input graph g and integer k   output yes if there is a clique of size k in g   no otherwise   the vertex cover problem   input graph g and integer k   output yes if there is a vertex cover of g with size k   no otherwise   how could we use a solution for one of these as a subroutine to solve the   other   for example assume we had a solution for vertex cover  how   could we use that to create a solution for clique  cs --     cs --   reduction from clique to   vertex cover   for a graph gve we can consider the complement of g gve   that is the complement of g consists of the same vertices as in g and all the   edges pairs of vertices unordered not in g   given an instance gckc of clique construct instance gvckvc of   vertex cover where   gvc is the complement of gc  kvc is v - kc that is the number of vertices not in the possible clique for the   is this a polynomial time reduction  clique instance  what does this reduction say about the   complexity of vertex cover   assume that clique cannot be solved in polynomial time  this is a huge assumption note that we're not just saying one algorithm  is not poly time  we're saying every algorithm is not poly time we're  talking about the complexity of the problem not just of an algorithm    then because we can reduce clique to vertex   cover in poly time  we know vertex cover cannot be poly time either   how do we know argument by contradiction    if vertex cover could be solved in poly time we'd use that poly   time algorithm as our subroutine  this is deep    and useful    then we'd be able to solve clique in poly time by this reduction   but clique by assumption at the beginning of this slide can't be  poly time so our assumption that vertex cover could be poly  time must be false    cs --   tractability and complexity   tractability   it is generally accepted that a problem is tractable solvable in practice   not just in theory if there is a polynomial-time algorithm for it    i e  in class onk for some constant k   if a problem requires an exponential time solution or worse it is   considered intractable without an efficient solution   goal classify problems by how efficiently they can be solved   big-o or theta classes relatively fine-detail distinctions   tractability distinctions based in larger classes  more about  verifiability  coming soon   p problems solvable in polynomial time hence the name p   np problems with solutions verifiable in polynomial time   pspace  problems solvable in polynomial space no restriction on time   exptime problems solvable in exponential time    expspace problems solvable in exponential space  etc  etc  etc      the class np  a quick introduction   np the class of problems solvable in nondeterministic   polynomial time hence the name np  somewhat loosely that means that a problem is in np if it can be   verified in polynomial time   could think of it as if we were given a certificate of a solution   essentially a potential solution we could check it for correctness    is it actually a solution in polynomial time in input size   could think of it as if given a correct certificate we could solve   the problem in polynomial time   note that if a solution to a problem can be found in polynomial   time that problem can be verified in polynomial time  recall this is about decision problems not related optimization problems   what does this say about the relationship between p and np   for more about nondeterminism in computation see cs  clique is in np   a clique in an undirected graph gve is a subset v'v s t  we'll focus on  v'    do  you see why  each pair in v' is connected by an edge in e  i e  a clique corresponds to a complete subgraph of g   the clique problem    input graph g and integer k    output yes if there is a clique of size k in g no otherwise  clique is in np  what would a poly-time verification algorithm take as input  - what would the certificate be - what would the verification algorithm do   using the certificate  cs --     hamiltonian cycle is in np  also called hamiltonian tour on project    consider the hamiltonian cycle problem  in some sources hamiltonian  is capitalized but not in clrs    a hamiltonian cycle of a connected directed graph gve is a simple cycle   that contains each vertex in v though perhaps not every edge in e   the hamiltonian cycle problem given connected digraph g does g contain a   hamiltonian cycle   example is there a hamiltonian cycle   in this graph  historical note hamiltonian cycle isn't named  after that hamilton   less historical note i have a great idea for an  np-completeness musical  lin-manuel call me  although nobody knows for sure experts  believe that an np-completeness musical  would run for a very very long time  hamiltonian cycle is in np   consider the hamiltonian cycle problem  in some sources hamiltonian  is capitalized but not in clrs    a hamiltonian cycle of a connected directed graph gve is a simple cycle   that contains each vertex in v though perhaps not every edge in e   the hamiltonian cycle problem given connected digraph g does g contain a   hamiltonian cycle   example is there a hamiltonian cycle          in this graph  hamiltonian cycle is in np  what would a poly-time verification algorithm  take as input  - what would the certificate be - what would the verification algorithm do   using the certificate  cs --     cs --   which is easier pt     recall the hamiltonian cycle problem   a hamiltonian cycle of a connected directed graph gve is a simple cycle that contains each vertex in v though perhaps not every edge in e   the hamiltonian cycle problem given connected digraph g does g contain   a hamiltonian tour   consider the euler tour problem   an euler tour of a connected directed graph is a cycle that uses each edge   exactly once though it can visit vertices multiple times   the euler tour problem given connected digraph g does g contain an euler   tour   how long what complexity would it take to    solve each of these problems    verify that a possible solution was correct if we were given one   and is there a meaningful difference in tractability between the problems    no joke this is an exceptionally important slide   p np and np-completeness   we know p  np because if a solution can be found in polynomial time   one can be checked in polynomial time  is np  p good question  one of the best around actually    extra credit exercise prove or disprove np  p  you would get an a for   this course  oh and also  at least  really    it is generally believed that pnp problems in p are tractable and np-  problems not in p are thought to be intractable   thus it's important to determine if a problem is in np or at least as hard as a   problem that is in np and not known to be in p   complexity class npc class of np-complete problems   a problem is np-complete if a it is in np and b it is at least as hard as   every problem in np    so if one np-complete   npc problems are the hardest problems in  np thus they're presumed intractable  problem is tractable all problems in np are tractable  using reductions to show   intractability   at least we think  they're intractable     if we know problem b has no polynomial time algorithm then consider a  reduction from b to a  takes an instance  of b  transforms it in polynomial time into an instance  of a   such that a decision on  would give us a decision on    then if a could be solved in polynomial time b could also   thus by contradiction a must not be solvable in polynomial time   more generally a is at least as hard to solve in poly time as b   a similar procedure will be used to show np-completeness    if b is np-complete a must be at least as difficult to solve   in poly time so a is a candidate for being np-complete   this is a common use of polynomial-time reductions  cs --     cs --   np-completeness   more formally  concisely here's what we mean by   np-completeness complexity class npc  l  npc iff    l  np    for every l' in np     l' reduces to  l   an implication    if l satisfies   it is called np- hard   if l is np-hard and also in np  then it's np-complete    if l is np-complete and l is in p then   np-completeness   more formally  concisely here's what we mean by   np-completeness complexity class npc  l  npc iff    l  np    for every l' in np     l' reduces to  l   an implication    if l satisfies   it is called np- hard   if l is np-hard and also in np  then it's np-complete    if l is np-complete and l is in p then p  np   so if p  np then if l is np-complete l is not in p  we think p  np  so we believe all np-complete problems are  not possible to solve in poly time  but we don't know for sure    cs --   which of these represents something   possible about p and np  list of np-complete problems partial list from wikipedia  httpsen  wikipedia  orgwikili stofnp- complete problems   graphs and hypergraphs   games and puzzles   graphs occur frequently in everyday   applications  examples include  biological or social networks which  contain hundreds thousands and even  billions of nodes in some cases e g   facebook or linkedin             -planarity  -dimensional matching  bipartite dimension  capacitated minimum spanning   tree  route inspection problem also   called chinese postman problem for  mixed graphs having both directed and  undirected edges  the program is  solvable in polynomial time if the graph  has all undirected or all directed edges                            battleship  bulls and cows marketed as master   mind certain optimisation problems  but not the game itself   eternity ii  generalized freecell  fillomino  hashiwokakero  heyawake  generalized instant insanity  kakuro cross sums  kuromasu also known as   kurodoko  lemmings with a polynomial time   limit  light up    list of np-complete problems partial list from wikipedia  httpsen  wikipedia  orgwikili stofnp- complete problems                                                                                                                        graphs and hypergraphs  graphs occur frequently in everyday applications  examples include biological  or social networks which contain hundreds thousands and even billions  of nodes in some cases e g   facebook or linkedin   -planarity  -dimensional  matching  bipartite dimension  capacitated minimum  spanning  tree  route inspection  problem also called chinese postman problem for mixed graphs having both directed and undirected edges  the program is solvable in polynomial  time if the   graph has all  undirected or all directed edges  variants include the rural postman problem   clique problem  complete coloring  a k a  achromatic number  domatic number  dominating  set a k a  domination  number  np-complete special cases include the edge dominating  set problem i e  the dominating  set problem in line graphs  np-complete variants include the connected dominating  set   problem and the maximum  leaf spanning tree problem   bandwidth problem  clique cover problem  rank coloring  a k a  cycle rank  degree-constrained spanning tree  exact cover problem  remains np-complete for -sets  solvable in polynomial  time for -sets this is a matching   feedback vertex set  feedback arc set  graph homomorphism  problem  graph coloring  graph partition  into  subgraphs of specific types triangles isomorphic  subgraphs hamiltonian  subgraphs forests perfect matchings are known np-complete  partition into  cliques is   the same problem as coloring the complement of the given graph  a related problem is to find a partition  that is optimal  terms of the number of edges between parts   hamiltonian  completion  hamiltonian  path problem  directed and undirected   longest path problem  maximum bipartite subgraph or especially with weighted edges maximum cut   maximum independent set  maximum induced path  graph intersection number  metric dimension  of a graph  minimum  k-cut  steiner tree or minimum  spanning tree for a subset of the vertices of a graph  the minimum  spanning tree for an entire graph is solvable in polynomial  time   modularity  maximization  pathwidth  set cover also called minimum  cover problem this is equivalent by transposing the incidence matrix to the hitting  set problem   set splitting  problem  shortest total path length  spanning tree  slope number two testing  treewidth  vertex cover  mathematical programming  -partition  problem  bin packing problem  knapsack problem quadratic knapsack problem and several variants  variations on the traveling salesman problem  the problem for graphs is np-complete if the edge lengths are assumed integers  the problem for points  on the plane is np-complete   with the discretized euclidean metric and rectilinear metric  the problem is known to be np-hard with the non-discretized euclidean metric   bottleneck traveling salesman  integer programming  the variant where variables are required to be  or  called zero-one linear programming  and several other variants are also np-complete  latin squares the problem of determining  if a partially  filled  square can be completed to form one  numerical -dimensional  matching  partition problem  quadratic assignment problem  quadratic programming np-hard in some cases p if convex  subset sum problem  formal languages and string processing  closest string  longest common subsequence problem  the bounded variant of the post correspondence problem  shortest common supersequence  string-to-string  correction problem                                                                                                                                              games and puzzles  battleship  bulls and cows marketed as master mind certain optimisation problems but not the game itself   eternity ii  generalized freecell  fillomino  hashiwokakero  heyawake  generalized instant insanity  kakuro cross sums  kuromasu also known as kurodoko  lemmings with a polynomial  time limit  light up  masyu  minesweeper consistency problem but see scott stege  van rooij  nimber or grundy number of a directed graph   point being there are  a lot of them   numberlink  nonograms  nurikabe  rubik's cube solved optimally  samegame  generalized set   slither link  on a variety of grids  generalized sudoku  problems related to tetris  verbal arithmetic  other  art gallery problem and its variations   berth allocation problem  betweenness  assembling an optimal  bitcoin  block    and the map visitation  problem which is np-complete  isn't even on this list  boolean satisfiability problem sat  there are many variations that are also np-complete  an important variant is where each clause has exactly three literals sat since it   is used in the proof of many other np-completeness results   conjunctive  boolean query  cyclic ordering  circuit satisfiability problem  uncapacitated facility location  problem  flow shop scheduling  problem  generalized assignment problem  upward planarity testing  hospitals-and-residents problem with couples  some problems related to job-shop scheduling  monochromatic triangle  minimum  maximal  independent set a k a  minimum  independent dominating  set  np-complete special cases include the minimum  maximal matching problem  which is essentially  equal to the edge dominating  set problem see above   maximum common subgraph isomorphism  problem  minimum  degree spanning tree  minimum  k-spanning tree  metric k-center  maximum -satisfiability  modal logic  s-satisfiability  some problems related to multiprocessor scheduling  maximum volume  submatrix  problem of selecting the best conditioned  subset of a larger m x n matrix  this class of problem is associated with rank revealing qr factorizations   and d optimal  experimental design   minimal  addition  chains for sequences  the complexity of minimal  addition  chains for individual  numbers is unknown   non-linear univariate polynomials  over gfn n the length of the input  indeed over any gfqn   open-shop scheduling  pathwidth or equivalently  interval thickness and vertex separation number  pancake sorting distance problem for strings  k-chinese postman  subgraph isomorphism  problem  variations of the steiner tree problem  specifically  with the discretized euclidean metric rectilinear metric  the problem is known to be np-hard with the non-discretized   euclidean metric   set packing  serializability of database histories  scheduling  to minimize  weighted completion  time  sparse approximation  block sorting  sorting  by block moves  second order instantiation  treewidth  testing whether a tree may be represented as euclidean minimum  spanning tree  three-dimensional ising model  vehicle routing  problem  map visitation problem mvp   so you're at your job and your supervisor tells you to write an   efficient poly-time algo to solve the mvp in the general case not  just special cases of it  what do you do multiple choice   use a minimum-spanning tree approach    use an all-pairs shortest paths approach    have a long conversation with your supervisor about wasting better uses of   your time  options  and  won't work but before you  do option  you should know you're right and np-completeness can help  input integer k number of robots   weighted undirected graph g  ve map for visitation    depots dv  vk starting points for each robot  output min-max length of the paths for visiting all nodes in g  given starting depots d  example     robots  start here        cs --     managing np-completeness  np-completeness is everywhere how do we deal with it   focus on special cases that we can efficiently solve   a lot of important problems fall into this category   can work on approximation algorithms instead of exact solutions   use intractability to your benefit   example cryptography   keep trying to prove p  np   good luck  thanks to httpswww cs princeton eduwaynecslecturesnp-complete  headlines  coming up on a recap of cs   what's the fastest sorting algorithm   is it quicksort    the answer might surprise you or it might not   this is a lot  thank you for your  work this semester   all the hottest fashion trends for programmers most important   complexity classes for programmers  with essential algos from each one   common myths about recursion debunked   some of the answers here actually might surprise you   how to make an algorithm not just a little faster but a lot faster   could your next problem be np-complete  and how would you know   plus language  nlp applications a little peek into what a compiler    interpreter does and more  cs --     