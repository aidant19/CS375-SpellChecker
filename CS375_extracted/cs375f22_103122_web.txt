cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   grading update  ps in progress   expect ps out in next couple of days   due no sooner than  week after it's assigned   project    first part due already   other parts due nov     please note some restrictions on my schedule      i will not be available for dress rehearsals tuesday or later  i expect to be traveling on nov   and probably won't be on email or able to  answer questions after noon on that day so please plan accordingly  cs --     business   some notes on grading of projects   grading on projects is in part as might be expected similar to grading of   other papers in other non-cs courses   overall for both presentations and write-ups more credit will be given to   submissions that demonstrate   greater scope of work completed   greater depth of insight in the work completed   greater command of relevant concepts  this is related to the idea  that not all improvements to  your exhaustive search algo are of equal value as noted  on the project assignment   greater clarity completeness and effective communication of the work  this is meant to be intuitive what you'd expect to get credit for but  please let me know if there are any questions about grading criteria  business   some notes on grading of projects   grading on projects is in part as might be expected similar to grading of   other papers in other non-cs courses   as expected credit will be given for work your team has done   as always be sure to cite  credit every source of assistance including your prof    tas textbook and online sources   be specific about contributions from other sources so your audience can be certain   about what work your team has done i e  as opposed to work taken from other sources   as expected credit is given for work done by your team presenting others' work or   ideas earns credit for the presentation but not for creating the work  ideas of others   as always please feel free to ask me grading-related questions as you do   your work on projects  it's best to direct project-oriented questions to me rather than to tas tas do not always  have the context that will best help you complete the project as intended  expected  cs --     cs --     zen and the art of  algorithm design   a couple of generally good ideas principles to help you   design your algorithms and their implementations    the foundations i e  relevant definitions and data   structures should be as simple as possible while still  providing all needed functionality    let the foundations guide the development and analysis   of algorithms based on them   i might restate principle  as keep your foundations simple   i might restate principle  as let your definitions tell you what to do   let's apply this to binary trees  cs --   definition   note this definition may  show up on hw too  of our intbintree data structure   throughout cs we will sometimes refer to an intbintree   data structure representing a binary tree of integers    in english we'd say an intbintree is  either empty   or    an int called val  is this a good definition consider principle   keep your foundations simple    and two subtrees called left and right that are also intbintrees   programmers might be used to seeing it more like this  definition intbintree empty or int val  the int value not empty intbintree left  the left subtree intbintree right  the right subtree  is this definition equivalent  to the english one above  the fact that a tree could be  empty is often implicit in  many specifications  definition   note this definition may  show up on hw too  of our intbintree data structure    in english we'd say an intbintree is  we'll call them ibts for short   either empty   or    an int called val   and two subtrees called left and right that are also intbintrees   to be unambiguous and consistent with functional   programming about how we work with ibts these will be  the primitive functions defined on ibts  valt returns the val element of an ibt t  for cs these are the  only ways to access val  left right  so something  like t val is not permitted    leftt returns the left subtree of an ibt t   rightt returns the right subtree of an ibt t  important note valt leftt and rightt are functions that  return values  they are not fields of an object  because of this we cannot assign values  to them e g  valt   is not permitted     correctness of recursive   algorithms inductive arguments   when arguing the correctness of a recursive algorithm the   general form is that of an inductive argument   the explanation follows the structure of the algorithm   show that the algorithm's base case returns correct output   show that the recursive cases return correct output  under the assumption that all recursive calls return correct output  just like when creating recursive code we assume recursive calls work in the  recursive case   here how would that work   how would we explain the  base case the recursive case  algorithm levelst input intbintree t output integer number of levels in t  if t is empty  return   else   return maxlevelsleftt levelsrightt    correctness of recursive   algorithms inductive arguments   when arguing the correctness of a recursive algorithm the   general form is that of an inductive argument   the explanation follows the structure of the algorithm   show that the algorithm's base case returns correct output   show that the recursive cases return correct output  under the assumption that all recursive calls return correct output  just like when creating recursive code we assume recursive calls work in the  recursive case   as part of explaining recursive  cases also explain how we  know the algo terminates   show arguments in recursive  calls get closer to base case  algorithm levelst input intbintree t output integer number of levels in t  if t is empty  return   else   return maxlevelsleftt levelsrightt    cs --     another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere   in an intbintree   how would we write the problem specification for ibtsearch   what would be the input   what would be correct output  definition intbintree empty or  int val  int value intbintree left  left subtree intbintree right  right subtree   how would we design an   algorithm to solve it  would the algorithm be iterative or recursive   how would we argue its correctness  another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere   in an intbintree   how would we write the problem specification for ibtsearch   input an int i and an intbintree t   output true exactly when i is in t  false otherwise  definition intbintree empty or  int val  int value intbintree left  left subtree intbintree right  right subtree  algorithm ibtsearchi t input int i intbintree t output true exactly when i is in t false otherwise  cs --     another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere   in an intbintree   how would we write the problem specification for ibtsearch   input an int i and an intbintree t   output true exactly when i is in t  false otherwise  definition intbintree empty or   int val  int value intbintree left  left subtree intbintree right  right subtree  algorithm ibtsearchi t input int i intbintree t output true exactly when i is in t false otherwise  if t  empty return false  else   if valt  i return true  else  return ibtsearchileftt or ibtsearchirightt  the last line uses the  boolean operator or  which is inclusive it is  true when either or  both operands are true  another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere   in an intbintree   how would we argue correctness for ibtsearch inductively   base case if t is empty  algorithm ibtsearchi t input int i intbintree t output true exactly when i is in t false otherwise  if t  empty return false  else   if valt  i return true  else  return ibtsearchileftt or ibtsearchirightt  definition intbintree empty or   int val  int value intbintree left  left subtree intbintree right  right subtree  some people might view this as  having two base cases   the definition of intbintree  however has one base case  empty tree  i view the algo as  following that definition   cs --     another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere   in an intbintree   how would we argue correctness for ibtsearch inductively   recursive case for non-empty t if i is in t   it's either at the root in left or in right  by defn that's all there is in a tree  so  definition intbintree empty or   int val  int value intbintree left  left subtree intbintree right  right subtree  algorithm ibtsearchi t input int i intbintree t output true exactly when i is in t false otherwise  if t  empty return false  else   if valt  i return true  else  return ibtsearchileftt or ibtsearchirightt  some people might view this as  having two base cases   the definition of intbintree  however has one base case  empty tree  i view the algo as  following that definition   another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere   in an intbintree   how would we argue correctness for ibtsearch inductively   does the algo terminate i e  does input get   closer to a base case with each recursive  call hint yes  it's always a subtree   definition intbintree empty or   int val  int value intbintree left  left subtree intbintree right  right subtree  algorithm ibtsearchi t input int i intbintree t output true exactly when i is in t false otherwise  if t  empty return false  else   if valt  i return true  else  return ibtsearchileftt or ibtsearchirightt  some people might view this as  having two base cases   the definition of intbintree  however has one base case  empty tree  i view the algo as  following that definition   cs --     cs --     break it down again    in general different ways of breaking down a problem into  subproblems can lead to different algorithms   e g  mergesort vs    any other sort basically   different data structures by their definitions suggest different   natural ways to break problems into subproblems  how would a binary tree suggest breaking a problem into   subproblems    how would a node-based linked list suggest breaking a problem into   subproblems    how about for an array  this isn't to say that for any given data structure some approach is always applied   this is just looking for common approaches and what makes them natural in context   break it down again    in general different ways of breaking down a problem into  subproblems can lead to different algorithms   e g  mergesort vs    any other sort basically   different data structures by their definitions suggest different   natural ways to break problems into subproblems  how would a binary tree suggest breaking a problem into   subproblems subproblems on sub-trees kinda one half at a time   how would a node-based linked list suggest breaking a problem into   subproblems subproblems on lists one element shorter   how about for an array subproblems involve changing indices and   iterating over indexed ranges index access is central to arrays  in all of these cases the foundations the definitions of the underlying   structure suggest that approach to breaking into subproblems  break it down again    in general different ways of breaking down a problem into  subproblems can lead to different algorithms   e g  mergesort vs    any other sort basically   different data structures by their definitions suggest different   natural ways to break problems into subproblems  how would a binary tree suggest breaking a problem into   subproblems subproblems on sub-trees kinda one half at a time   how would a node-based linked list suggest breaking a problem into   subproblems subproblems on lists one element shorter  in a very broad sense these represent the two major ways of thinking about recursion  size of subproblems either divided from tree or subtracted from list original input size  in all of these cases the foundations the definitions of the underlying   structure suggest that approach to breaking into subproblems  cs --     cs --     list algorithms   we've seen how the definition of a binary tree can guide the   design of algorithms on binary trees   many common algorithms are written on lists   how does the definition of a list guide the designs of those algorithms  what are some difference between arrays and lists in this context  list algorithms   we've seen how the definition of a binary tree can guide the   design of algorithms on binary trees   many common algorithms are written on lists   how does the definition of a list guide the designs of those algorithms  what are some difference between arrays and lists in this context   among the significant differences between an array and a list   arrays are stored as contiguous blocks of memory lists when not   simply extensions of arrays are node-based linked lists   arrays have direct constant-time indexed access to any element lists  require traversing a list to reach an element which is not constant-time   because lists are node-based it can be constant-time to access the sub-  list of all but the first element as a distinct object  list algorithms   we've seen how the definition of a binary tree can guide the   design of algorithms on binary trees   many common algorithms are written on lists   how does the definition of a list guide the designs of those algorithms  what are some difference between arrays and lists in this context   for example consider the search problem on lists  input item i and list l  output true if i is an element of l   false otherwise   there are multiple ways to approach designing an algorithm   for this how might you design one  what can you say about the complexity of your algorithm  cs --     list algorithms and recursion   lists as opposed to arrays can have node-based defintitions   as part of that a list type is commonly defined recursively   how would you write a recursive algorithm to solve the search   problem on lists  one possibility is shown here   how would we argue its  correctness    do you believe that it works  correctly   what can we say about its  complexity  input item i and list l  output true if i is an element of l   false otherwise  algorithm reclistsearchi l  see specification immediately above  if l     return false  else  if i is l  return true  else  this uses python- like list slicing  syntax to refer to  all but the first  element of l  return reclistsearchil  list algorithms and recursion   lists as opposed to arrays can have node-based defintitions   as part of that a list type is commonly defined recursively   how would you write a recursive algorithm to solve the search   problem on lists  one possibility is shown here   how would we argue its  correctness    do you believe that it works  correctly   what can we say about its  complexity   list slicing can't be assumed  to be constant time  input item i and list l  output true if i is an element of l   false otherwise  algorithm reclistsearchi l  see specification immediately above  if l     return false  else  if i is l  return true  else  this uses python- like list slicing  syntax to refer to  all but the first  element of l  return reclistsearchil  cs --     list algorithms  remove first occurrence of an element   consider the problem of removing the first occurrence of an   element from a sequence specified here for a list  input item i and list l  x  xn  output if i  xk and k is the smallest value for which i  xk   return x  xk- xk  xn  otherwise i e  when there is no k such that i  xk return l   how would you design an algorithm to solve this problem   iteratively on array-based lists   recursively on node-based lists   how would the complexity of this be different on a list i e  a linked   list than on an array  definition   note this definition may  show up on hw too  of our llist data structure   throughout cs we will sometimes refer to an llist data   structure representing a list of elements     in english we'd say an llist is  either empty   or    an element called first  is this a good definition consider principle   keep your foundations simple    and an llist called rest representing all the elements after first  is this consistent with your understanding of list structures that  is linked list structures which are typically node-based in  implementation  cs --     cs --   definition   note this definition may  show up on hw too  of our llist data structure    in english we'd say an llist is   either the empty list   or    an element called first   and an llist called rest representing all the elements after first   to be unambiguous about how we work with llists these   will be the primitive functions defined on llists  firstl returns value of the first element of an llist l   restl returns value of the rest sublist of an llist l   consvl a constructor function that takes an item v and an llist l   and returns a new llist l' such that    what do you think it might be  what do you think  the complexities of  these functions are    