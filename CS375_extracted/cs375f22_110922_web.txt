 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   notes regarding these slides for  nov      i was ill and needed to miss class on nov     i am sorry about that inconvenience it's not a deci sion i made lightly   dale skrien very generously agreed to cover class for me  thank you dale   these are some slides i was prepared to use if i had been there   i gave them to dale as an overview of what he coul d cover   these notes do not perfectly match what happened in class    but i think they might still be a useful accompan iment to our nov    class meeting so i'm posting them anyway   i hope they're useful for you   as always please be in touch with questions  cs --    time complexity of  remove first occurrence of an element   how would you analyze the time complexity of this algorithm  functions on llists - firstl returns first  - restl returns rest  - consvl creates new llist  with v as first and l as rest  assume all of these functions  are o they would be in  most implementations algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstlllremoveirestl this is something we haven't done before let's think it through  we analyze complexity as a function of input size as usual  let's let nstand for input size and tn stand for time complexity on input of size n we need to figure out what tn is    what foundati ons or definitions can we follow  zen principles to help us  well it's recursive     so let's look at the base case and recursive case sepa rately  cs --    recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   in the base case what is the input size                                                      and what is the runtime of the algo recall that firstl restl consvl functions are all o algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl  recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   in the base case what is the input size                                                      and what is the runtime of the algo recall that firstl restl consvl functions are all o algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl  base case  input size empty list n    runtime  do you see why  cs --    recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   in the base case what is the input size                                                      and what is the runtime of the algo recall that firstl restl consvl functions are all o algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl  base case  input size empty list n    runtime  do you see why so we'd say t   to  express the base case runtime  recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   base case t     how about the recursive case what is the input si ze and runtime algorithm llremovei l  if i  firstl  return restl  else  return consfirstl  llremoveirestl  recursive case we say input is size n as usual l has n elements  also  it does some work other than the recursive call comb ined  do you see why  all of its other runtime is in its recursive call  how would we represent th e runtime of  that particular recursive call let's just focus on the  recursive case for now  cs --    recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   base case t     how about the recursive case what is the input si ze and runtime algorithm llremovei l  if i  firstl  return restl  else  return consfirstl  llremoveirestl  recursive case we say input is size n as usual l has n elements  also  it does some work other than the recursive call comb ined  do you see why  all of its other runtime is in its recursive call   input size to recursive call n- a list of  less element than l do you see why  how do we express the runtime of that call use our definition of t let's just focus on the  recursive case for now  recurrences for time complexity  of recursive functions   as an example of analyzing time complexity of recu rsive functions  let's stay with llremove   complexity of function of input size n definition  let tn stand for runtime  of llremove on list of size n   now we figure out what is tn   because llremove is recursive let's                                                 look at the base case  recursive cases   base case t     recursive case tn  tn-   algorithm llremovei l  if i  firstl  return restl  else  return consfirstl  llremoveirestl  this may look unusual and recursive but it follows  cleanly from the previous slide  in the recursive case  it does some work other than the recursive call comb ined   do you see why  all of its other runtime is in its recursive call tn- let's just focus on the  recursive case for now  cs --    recurrences for time complexity  of recursive functions   putting all the pieces together so far there's more coming up  let's put the pieces together  for n   t    for n    tn  tn-    that is a full definition of the  complexity of this algorithm   both the base case and the  recursive case algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstlllremoveirestl let's let nstand for input size and tn stand for time complexity on input of size n we need to figure out what tn is    let's look at the base case and recursive case  separately  the base case prev  slide is t     what's the complexity in the recursive case  tn  tn-    the time taken by everything but the recursive call is just   do you see why   and the recursive call is on input of size n-  so by our definition of function t  complexity of the recursive call is tn-  do you see how this  characterization of tn  exactly fits our  llremovel algo solving a time complexity  recurrence   let's focus on our definition of runtime function tn and how to use it   important vocabulary   we say this definition of tn is a recurrence  it defines tn in terms of itself   note that it follows good design principles for re cursive definitions   it has a base case   its recursive case is defined in terms  of itself on smaller inputs   indeed the two parts together are  a complete definition of the runtime   but we're not done yet what's the  asymptotic complexity of llremove for n   t    for n   tn  tn-   algorithm llremovei l   see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl  cs --    solving a time complexity  recurrence   let's focus on our definition of runtime function tn and how to use it   important vocabulary   we say this definition of tn is a recurrence  it defines tn in terms of itself   to find the asymptotic complexity represented by t his recurrence we need  to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on  successively smaller arguments for n   t    for n   tn  tn-   we know tn  tn-   that's in the definition  but we similarly know from the definition what tn- is what is it  solving a time complexity  recurrence   let's focus on our definition of runtime function tn and how to use it   important vocabulary   we say this definition of tn is a recurrence  it defines tn in terms of itself   to find the asymptotic complexity represented by t his recurrence we need  to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on  successively smaller arguments for n   t    for n   tn  tn-   tn  tn-      what does tn- equal according to  the recursive case of the definition of  the recurrence above  cs --    solving a time complexity  recurrence   let's focus on our definition of runtime function tn and how to use it   important vocabulary   we say this definition of tn is a recurrence  it defines tn in terms of itself   to find the asymptotic complexity represented by t his recurrence we need  to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on  successively smaller arguments for n   t    for n   tn  tn-   tn  tn-     tn-      tn-        in this step we replaced tn- with its definitio n from the  recursive case from above  tn-  tn-   next step we'll continue unwinding by replacing tn-  solving a time complexity  recurrence   let's focus on our definition of runtime function tn and how to use it   important vocabulary   we say this definition of tn is a recurrence  it defines tn in terms of itself   to find the asymptotic complexity represented by t his recurrence we need  to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on  successively smaller arguments for n   t    for n   tn  tn-   tn  tn-     tn-      tn-     tn-       tn-          do you see a  pattern  in general unwinding stops at the base case of the  definition of tn     when will this recurrence's unwinding reach its bas e case  cs --    solving a time complexity  recurrence   let's focus on our definition of runtime function tn and how to use it   important vocabulary   we say this definition of tn is a recurrence  it defines tn in terms of itself   to find the asymptotic complexity represented by t his recurrence we need  to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on  successively smaller arguments for n   t    for n   tn  tn-   tn  tn-     tn-      tn-      tn-       tn-           t  n    what does this equal use the base case  definition above  solving a time complexity  recurrence   let's focus on our definition of runtime function tn and how to use it   important vocabulary   we say this definition of tn is a recurrence  it defines tn in terms of itself   to find the asymptotic complexity represented by t his recurrence we need  to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on  successively smaller arguments for n   t    for n   tn  tn-   tn  tn-     tn-      tn-      tn-       tn-           t  n     n    n so llremove is a tn  n  algorithm solved  cs --    time complexity of mergesort  using recurrences   mergesort is a classic recursive algo and recurrences are  an essential technique for time complexity analysis   what would a recurrence be that represents the time  complexity of mergesort so let's define runtime function tn  as a recurrence for mergesort recall that recurrences  give a base case for tn  give a recursive case for tn  are solved to get asymptotic  complexity for the recursive algo  let's start with the base case  what is the input s ize in the base case  for this mergesort algo and what is runtime on that  input  cs --    time complexity of mergesort  using recurrences   mergesort is a classic recursive algo and recurrences are  an essential technique for time complexity analysis   what would a recurrence be that represents the time  complexity of mergesort so let's define runtime function tn as a  recurrence for mergesort recall that recurrences  give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for  the recursive algo  base case p  r  when p  r input size is    t    time complexity of mergesort  using recurrences   mergesort is a classic recursive algo and recurrences are  an essential technique for time complexity analysis   what would a recurrence be that represents the time  complexity of mergesort so let's define runtime function tn as a  recurrence for mergesort recall that recurrences  give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for  the recursive algo  recursive case let n stand for the input size r- p  tn    what work is done in the recursive case recall th at merge is n  cs --    time complexity of mergesort  using recurrences   mergesort is a classic recursive algo and recurrences are  an essential technique for time complexity analysis   what would a recurrence be that represents the time  complexity of mergesort so let's define runtime function tn as a  recurrence for mergesort recall that recurrences  give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for  the recursive algo  recursive case let n stand for the input size r- p  tn   recursive calls  merge n  other stuff on lines     what work is done in the recursive case recall th at merge is n  time complexity of mergesort  using recurrences   mergesort is a classic recursive algo and recurrences are  an essential technique for time complexity analysis   what would a recurrence be that represents the time  complexity of mergesort so let's define runtime function tn as a  recurrence for mergesort recall that recurrences  give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for  the recursive algo  recursive case let n stand for the input size r- p  tn   recursive calls  merge n  other stuff on lines       recursive calls  n we're not done yet  how much work is done in the  recursive calls  cs --    time complexity of mergesort  using recurrences   mergesort is a classic recursive algo and recurrences are  an essential technique for time complexity analysis   what would a recurrence be that represents the time  complexity of mergesort so let's define runtime function tn as a  recurrence for mergesort recall that recurrences  give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for  the recursive algo  recursive case let n stand for the input size r- p  tn   recursive calls  merge n other stuff on lines       recursive calls  n  we'll simplify by assuming each recursive call is o n input size n  we'll use our definition of t to express the runt ime of each recursive call  time complexity of mergesort  using recurrences   mergesort is a classic recursive algo and recurrences are  an essential technique for time complexity analysis   what would a recurrence be that represents the time  complexity of mergesort so let's define runtime function tn as a  recurrence for mergesort recall that recurrences  give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for  the recursive algo  recursive case let n stand for the input size r- p  tn   recursive calls  merge n other stuff on lines       tn  n  we'll simplify by assuming each recursive call is o n input size n  we'll use our definition of t to express the runt ime of each recursive call  cs --    time complexity of mergesort  using recurrences   let's put all the pieces together  let's put the pieces together  for n   t    for n    tn  tn  n  that is a full definition of the  complexity of this algorithm   both the base case and the  recursive case let's let nstand for input size and tn stand for time complexity on input of size n we need to figure out what tn is    let's look at the base case and recursive case  separately  the base case prev  slide is t     what's the complexity in the recursive case  tn  tn  n  the time taken by everything but the  recursive calls is n  do you see why   and we simplify and say each recursive call is on input of size n  so by our definition of function t  complexity of each recursive call is tn  do you see how this tn  exactly fits our mergesort algo  cs --    solving recurrences   we'll cover three common techniques for solving  recurrences i e  getting  or o bounds on the solution  unwinding or backward substitution  unroll the recurrence  until it reaches a base case then count  analyze the cost  represented  recursion-tree method  represent costs as nodes in a tree and  analyze total cost  master method  solve recurrences of the form  tn  atnb  fn we already did an example of unwinding and we'll  do another one soon  unwinding   an example solve tn  tn  n this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow   this is a simplified version of the recursive case of our  recurrence for mergesort but it's close enough to  capture the algo's time complexity   we already know what the answer is do you  remember the complexity of mergesort  let's go through the steps of solving it by unwindi ng  cs --    unwinding   an example solve tn  tn  n  unwind the recurrence by plugging in the definition on  successively smaller arguments   from the definition tn  tn  n   by that same definition tn  tn  n   tn  n   so by plugging that in tn  tn  n   n   what would the next steps be in this unwinding p rocess   where would it stop this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow   what information is missing from this recurrence w hich we will  need to be able to solve it  unwinding   an example solve tn  tn  n  unwind the recurrence by plugging in the definition on  successively smaller arguments   from the definition tn  tn  n what information is missing from this recurrence w hich we will  need to be able to solve it  tn tn tn tn  tn  n  tn  n  tn  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                   do you see a pattern here and when does this unwin ding end this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow   cs --    unwinding   an example solve tn  tn  n   for a base case let's use t   or  if we want  unwind the recurrence by plugging in the definition on  successively smaller arguments   from the definition tn  tn  n  tn tn tn tn  tn  n  tn  n  tn  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                           kk kktn tn tn tn kk kk  kn   kn   kn   kn                  the k'th step shown here illustrates  the pattern that holds for any  relevant k  it can help with our  analysis to show this in our work this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow   unwinding   an example solve tn  tn  n   for a base case let's use t   or  if we want  unwind the recurrence by plugging in the definition on  successively smaller arguments   from the definition tn  tn  n  tn tn tn tn  tn  n  tn  n  tn  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                           kk kktn tn tn tn kk kk  kn   kn   kn   kn                    nt  lg nn  nt  lg nn  nt  lg nn  nt  lg nn      n lg n the lg n term comes because the  recurrence unwinds lg n times  before hitting the base case do  you see why this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow   cs --    recursion trees an overview   recursion trees can represent how a recursive algorithm   breaks input down into recursive calls on sub-prob lems   or equivalently  combines recursive calls into a solution on the o riginal  problem   here's an example from clrs mergesort   each node shows input size at that level of  recursive calls   here original input size  breaks into  sub-problems of size  etc   this example shows the recursion going  up the tree combining solutions  note that the input sizes at each node  would be the same for the recursion going  down the tree breaking into sub-problems  cs --    recursion trees for solving time- complexity recurrences   when using recursion trees to solve for time complexity  though we don't need quite that much information   we do need the structure showing how the algo divides and  re- combines its inputs   we do need the input size at each node   we do not need details about exactly what  the input is at each node   what we need for each node of the tree   input size at each node   a way to represent the work done i e  the runtim e at that node of  the tree  not including any other work done above or below i t recall asymptotic  complexity is in terms of  input size n not individual  inputs of a given size  let's do an example  recursion-tree method   an example  mergesort  tn   n    t n if  n tn  sorting both halves       n merging otherwise         what's the cost at each  tree-level i e  not  counting levels below it what's the recursion  tree structure  cs --    recursion-tree method   an example  mergesort  tn   n    t n if  n tn  sorting both halves       n merging otherwise         what's the cost at each  tree-level i e  not  counting levels below it what's the recursion  tree structure set up a tree to  total up the work  done by the  algorithm  tree structure for complexity analysis corresponds to tree of  recursive calls by the algorithm  total work by the algorithm sum of work at all lev els of the tree  recursion-tree method   an example  mergesort  tn  tn   tn  tn   tn   tn   tn  t   t   t   t   t   t   t   t  n tn   k n  n  k n   k n                 log n n log n    t n if  n tn  sorting both halves       n merging otherwise         recursion tree for algorithm  total work done 