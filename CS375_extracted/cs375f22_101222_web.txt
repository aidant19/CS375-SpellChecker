 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   thank you to those who participated last wednesday   i'll look over feedback and have a few words to sa y on monday   grading update   ps update grades probably returned by end of day f riday   project started grades probably not returned until  weekend   please let me know if you'd like feedback sooner    coming soon as cs assignments   sa likely out today due monday   ps out soon likely due date oct     proj out soon likely due date in early november   revisions on sa where applicable   this is foundational material   please get to them soon to help with learning for  the course  cs --    factorial-ish all permutations   write an algo to generate all permutations of an input list l   what are its input  output specifications   how does your algo solve the problem   what is its time  space complexity what loop invariant would be helpful to clarify  explain your algorithm design  this was your smaller assignment due by the beginn ing of today's class  what loop invariant did you use  let's look at some invariants and then use one of them to develop an  algo factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- cs --    factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant below   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant below   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- a sequence from a bigger  number to a smaller number  like s     s - is considered  empty containing no elements  cs --    factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant below   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-  psl  temppsl  what's the length of psl after this operation  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant below   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-   loop over all possible places to put siin pslj including before the first or after the last  psl  temppsl  what's the length of psl after this operation  cs --    factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant below   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-   loop over all possible places to put siin pslj including before the first or after the last  for k   to lenpslj  temps  deepcopypsl j   why deepcopy insert siinto temps at position k    note position lenpslj is after last elt of ps lj  add temps to list temppsl  psl  temppsl  what's the length of psl after this operation when siis  added it could  be before the  first element in  a previously  formed list or  after the last  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant below   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-   loop over all possible places to put siin pslj including before the first or after the last  for k   to lenpslj  temps  deepcopypsl j   why deepcopy insert siinto temps at position k    note position lenpslj is after last elt of ps lj  add temps to list temppsl  psl  temppsl  what's the length of psl after this operation let's go  through a  small  example  how does  this algo  work on  s  cs --    factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant below   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-   loop over all possible places to put siin pslj including before the first or after the last  for k   to lenpslj  temps  deepcopypsl j   why deepcopy insert siinto temps at position k    note position lenpslj is after last elt of ps lj  add temps to list temppsl  psl  temppsl  what's the length of psl after this operation what is the  space  complexity  of this algo factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant below   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-   loop over all possible places to put siin pslj including before the first or after the last  for k   to lenpslj  temps  deepcopypsl j   why deepcopy insert siinto temps at position k    note position lenpslj is after last elt of ps lj  add temps to list temppsl  psl  temppsl  what's the length of psl after this operation what is the  space  complexity  of this algo how much  space is  used at the  end  nn  it is beyond  the scope of  cs to get a  theta bound  cs --    factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that   what is its time  space complexity generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant below   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-   loop over all possible places to put siin pslj including before the first or after the last  for k   to lenpslj  temps  deepcopypsl j   why deepcopy insert siinto temps at position k    note position lenpslj is after last elt of ps lj  add temps to list temppsl  psl  temppsl  what's the length of psl after this operation what is the  time  complexity  of this algo at least  nn  because it  takes at least  one unit of  time to  access each  unit of space  it is beyond  the scope of  cs to get a  theta bound  using loop invariants in  algorithm design and explanations   loop invariants state properties known to be true for each iteration of a loop   can think of it as a property known to be true imm ediately before and  immediately after each iteration   in our examples we've understood loop invariants in terms of before and  after conditions  before  what is helpful and known to be true before a giv en iteration of the loop  after  what is helpful and known to be true after a give n iteration of the loop  which establishes the truth of the before condition before the next iteration  example the generate permutations algo from the previ ous slide   invariant  outer loop     psl contains all permutations formed from elts s  s i-      that is before index i psl contains all permutations formed from elts s  s i-    and after index i psl contains all permutations formed from elts s  si cs --    using loop invariants in  algorithm design and explanations   loop invariants state properties known to be true for each iteration of a loop   can think of it as a property known to be true imm ediately before and  immediately after each iteration   in our examples we've understood loop invariants in terms of before and  after conditions  before  what is helpful and known to be true before a giv en iteration of the loop  after  what is helpful and known to be true after a give n iteration of the loop  which establishes the truth of the before condition before the next iteration   you don't need to write down before  after condit ions unless a cs  assignment requires it but it can be helpful   key point loop invariant gives a property that's true after the loop is  finished that helps explain algo correctness  example let's use the invariant to help explain the correctness of our generate  permutations algo factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-   loop over all possible places to put siin pslj including before the first or after the last  for k   to lenpslj  temps  deepcopypsl j   why deepcopy insert siinto temps at position k    note position lenpslj is after last elt of ps lj  add temps to list temppsl  psl  temppsl  what's the length of psl after this operation how does the  invariant help  explain  correctness  that the algo  meets its  specifications  cs --    factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-   loop over all possible places to put siin pslj including before the first or after the last  for k   to lenpslj  temps  deepcopypsl j   why deepcopy insert siinto temps at position k    note position lenpslj is after last elt of ps lj  add temps to list temppsl  psl  temppsl  what's the length of psl after this operation the invariant  shows that  after the last  iteration when  i  n  psl  contains all  permutations of  all elts in l  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to  generate all permutations of l  let's write an algo that does that generate-all-permutationsl   input l a list of nelements     l  s s s sn-  output psl a list of all permutations     of input list l that is all the lists     resulting from all possible orderings     of all elements in input l generate-all-permutationsl  n  lenl  psl       note relation to invariant   invariant  outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permu tations formed from elts s  s i-    and after index i psl contains all permutation s formed from elts s  si for i   to n- temppsl     empty list will store permutations containing si m  lenpsl   inner loop loops over psl create new permutatio ns containing si for j   to m-   loop over all possible places to put siin pslj including before the first or after the last  for k   to lenpslj  temps  deepcopypsl j   why deepcopy insert siinto temps at position k    note position lenpslj is after last elt of ps lj  add temps to list temppsl  psl  temppsl  what's the length of psl after this operation the invariant  shows that  after the last  iteration when  i  n  psl  contains all  permutations of  all elts in l   and that's  exactly what  the  specifications  say is needed  so if the  invariant  always holds  the algo is  correct  cs --    exponential-ish generate all subsets   to search through all subsets of a set s something first needs to  generate all subsets of s  let's write an algo that does that   what is its time  space complexity generate-all-subsetss   input s a set of nelements     s  s s s s n-    probably implemented as a list     but with no repeated elements so     it can be treated as a set by     ignoring the elements' ordering   output l a set of all subsets of s generate-all-subsetss  n  lens  l       note relation to invariant below   invariant  outer loop     l contains all subsets formed from elts s  s i-     before index i l contains all subsets formed f rom elts s  s i-    after index i l contains all subsets formed fr om elts s  si for i   to n- templ     empty list will store subsets containing si m  lenl  inner loop loops over l create new subsets cont aining si for j   to m-  temps  deepcopyl j   why deepcopy add sito temps  add temps to list templ   what's the length of templ here when it's fully f illed in  add all of templ to l   what's the length of l after this operation what is the  time  space  complexity  of this algo what can  you give as a  lower bound  bound  cs --    exponential-ish generate all subsets   to search through all subsets of a set s something first needs to  generate all subsets of s  let's write an algo that does that   what is its time  space complexity generate-all-subsetss   input s a set of nelements     s  s s s s n-    probably implemented as a list     but with no repeated elements so     it can be treated as a set by     ignoring the elements' ordering   output l a set of all subsets of s generate-all-subsetss  n  lens  l       note relation to invariant below   invariant  outer loop     l contains all subsets formed from elts s  s i-     before index i l contains all subsets formed f rom elts s  s i-    after index i l contains all subsets formed fr om elts s  si for i   to n- templ     empty list will store subsets containing si m  lenl  inner loop loops over l create new subsets cont aining si for j   to m-  temps  deepcopyl j   why deepcopy add sito temps  add temps to list templ   what's the length of templ here when it's fully f illed in  add all of templ to l   what's the length of l after this operation what is the  time  space  complexity  of this algo lower bound  of  n n it is beyond  the scope of  cs to get a  theta bound  exponential-ish generate all subsets   to search through all subsets of a set s something first needs to  generate all subsets of s  let's write an algo that does that   what is its time  space complexity generate-all-subsetss   input s a set of nelements     s  s s s s n-    probably implemented as a list     but with no repeated elements so     it can be treated as a set by     ignoring the elements' ordering   output l a set of all subsets of s generate-all-subsetss  n  lens  l       note relation to invariant below   invariant  outer loop     l contains all subsets formed from elts s  s i-     before index i l contains all subsets formed f rom elts s  s i-    after index i l contains all subsets formed fr om elts s  si for i   to n- templ     empty list will store subsets containing si m  lenl  inner loop loops over l create new subsets cont aining si for j   to m-  temps  deepcopyl j   why deepcopy add sito temps  add temps to list templ   what's the length of templ here when it's fully f illed in  add all of templ to l   what's the length of l after this operation how does the  invariant help  explain  correctness  that the algo  meets its  specifications  hint it's very  similar to what  we just did for  the permutations  algorithm  cs --    using loop invariants in  algorithm design and explanations   loop invariants state properties known to be true for each iteration of a loop   can think of it as a property known to be true imm ediately before and  immediately after each iteration   in our examples we've understood loop invariants in terms of before and  after conditions  before  what is helpful and known to be true before a giv en iteration of the loop  after  what is helpful and known to be true after a give n iteration of the loop  which establishes the truth of the before condition before the next iteration   key point loop invariant gives a property that's true after the loop is  finished that helps explain algo correctness  to informally use loop invariants to help explain  algo correctness  explain how the invariant is true before the first iteration of the loop  explain how the invariant is true after each follow ing iteration  explain how the invariant property shows that the a lgo meets its  specifications  a logical digression  logical reasoning about empty stuff   how does it work if we're asked if something is tr ue for all elements of an  empty structure   examples   say l is a list of strings and l is empty  is it true that every string on the list  has length greater than    say s is a set of numbers and s is empty  is it t rue that every number in s is  equal to   brace yourselves until you get used to them you ma y not like  the answers to these questions  cs --    a logical digression  logical reasoning about empty stuff   how does it work if we're asked if something is tr ue for all elements of an  empty structure   examples   say l is a list of strings and l is empty  is it true that every string on the list  has length greater than    say s is a set of numbers and s is empty  is it t rue that every number in s is  equal to    the answer to these questions is yes it is true   we say it is vacuously true    part of the way propositional logic works is that when we ask if some  property is true of every element in some empty structure    the answer is always yes because there are no el ements to reason  about we can vacuously say anything is true of anything in that empty set  this follows from the same idea that once it is sho wn that false  true  the system is incoherent so we can say anything is  true in that system  a logical digression  vacuous truth   how does it work if we're asked if something is tr ue for all elements of an  empty structure   more examples   say l is a list of numbers and l is empty  is it true that l is in sorted order    say l is a list of numbers and l is empty  is it true that l is out of sorted  order    the answer to these questions is yes they are vacuously true  it's completely understandable if you're not feelin g totally happy about this dealing  with logical incoherence is tricky  it turns out though this convention of vacuous tr uth can be really useful and it  gets very intuitive after a while this can be useful as part of using loop invariants  especially when showing  a property is true in some boundary case either before the first iteration of  a loop or after the last iteration of a loop  cs --    example of reasoning with vacuous truth  loop invariants and bubble sort   yes bubble sort is the actual name of this sorting algorithm   in pseudocode   do you understand how the algo works try it on a   how do we use loop invariants to show correctness i e  that  it sorts a in non-decreasing order bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- what's the time complexity of this algorithm  example of reasoning with vacuous truth  loop invariants and bubble sort  on   loop invariant for outer loop   use invariant to show correctness    show invariant is true before first loop iteratio n how    show pseudocode ensures invariant is true after e ach successive iteration  assuming that it's true at the start of the iterati on how    show when loop is done algorithm meets specifica tions how bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n cs --    example of reasoning with vacuous truth  loop invariants and bubble sort  on   loop invariant for outer loop   use invariant to show correctness    show invariant is true before first loop iteratio n how bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n before the first iteration iis set to   for the invariant we look at a  i-   a     by convention a   is an empty array    so it vacuously contains the i- smallest values of a in sorted order  example of reasoning with vacuous truth  loop invariants and bubble sort  on   loop invariant for outer loop   use invariant to show correctnessbubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n super important note  show that the entire invariant is true not just part of it  a   vacuously contains the i- smallest values of a in sorted order   we still need to explain how a  n consists of th e remaining values of a no  constraint on order but that's not that difficult  cs --    explaining correctness  loop invariants and bubble sort  on   loop invariant for outer loop   use invariant to show correctness    show invariant is true before first loop iteratio n done    show pseudocode ensures invariant is true after e ach successive iteration  assuming that it's true at the start of the iterati on how    show when loop is done algorithm meets specifica tions how bubblesorta    for i   to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n explaining correctness step   loop invariants and bubble sort  on   loop invariant for outer loop    show pseudocode ensures invariant is true after e ach successive iteration  assuming that it's true at the start of the iterati on bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n there are many right ways to do this step it's all a bout explaining how the algo works  refer directly to the pseudocode in your explanatio n citing specific lines of pseudocode  doing this step will be part of a smaller assignmen t due next monday  cs --    explaining correctness step   loop invariants and bubble sort  on   loop invariant for outer loop    show when loop is done algorithm meets specifica tions bubblesorta    for i    to a length     for j  a length downto i    if aj  aj-    swap aj with aj- subarray a  i- consists of the i- smallest val ues of  a in sorted order and ai  n consists of the rem aining  values of a no constraint on order sorting problem  input sequence of   numbers a   a n output permutation  reordering b    bn of the input  sequence perhaps  leaving them  unchanged such  that b  b     b n there are many right ways to do this step too  refer directly to the invariant property and to the  specifications in your explanation  referring to specifications is essential for showin g algo correctness  doing this step will also be part of a smaller assi gnment due next monday  algorithm correctness and loop invariants  a recap   to explain correctness of iterative algos look at the loop   loop invariants can help three steps to using loop invariants    show the invariant is true before the first itera tion    show the invariant stays true after each successi ve iteration  assuming it was true before that iteration    show the algo meets specifications using what the  invariant says is  true after the loop is done see clrs    these three steps correspond to three parts mention ed in our clrs textbook    initialization property is true before the first iteration    maintenance if a property is true before an iteration it is tr ue after that iteration  before the next  iteration    termination when the loop terminates the property is useful in  showing algorithm correctness  you do not need to use these three terms from clrs for cs when discussing invariants although  you can if you want to i just wanted to connect our approach in this slides to our textbook 