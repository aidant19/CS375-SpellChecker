cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   grading update   sa returned   ps extended  unusual deadline   due pm today   project    first part due already   other parts due nov     please schedule dress rehearsals with me for friday  saturday   i will not be available for them next tuesday or later  cs --     cs --   business project    project  out due nov     parts of project   have you read through proj yet  would you have preferred the assignment sheet  to be broken up into separate documents    design exhaustive search algorithms your team will collectively design   exhaustive search algorithms for  problems     improve time efficiency your team will pick one of the problems and make   your exhaustive search algorithm more efficient     reduction for the same problem chosen for part   above you will reduce that problem to one of the  other seven problems from part       create and give a presentation your team will  present work from the previous three parts of the  assignment using loop invariants where  appropriate to explain correctness   hint your team may  want to be strategic  about which of the   problems you choose to  focus on for your  improvements  reduction and  presentation  pick a  problem for which you  can do good work    common myths about recursion   debunked   what impressions do you have about recursion   here are some things i've heard paraphrased slightly   admittedly i've mostly heard them in the context of a student saying   i used to think this was true but now i don't anymore    but still i've heard them or something very much like them   recursion is basically just a party trick  it's actually very useful   recursive design is just trial and error   there are methods to use   recursion is slow compared to iteration  well sort of  it can be  but it's not as bad as it used to be  and related concepts can enable some very fast code   people don't really use recursion  people really do it can be very natural to use  if there's anything you'd like to add to this list let me know  a functional digression  the functional programming paradigm   some important features of pure functional programming   immutable data    stateless functions everything self-contained  no side effects   uses recursion for iteration rather than loops   supports parallel computation recall applications to data science   code can be easier to show correct  debug  for those of us who like to think about programming languages at the theory  and design level it may be interesting to note that the last three of the above  five features kinda follow from the first two  this is subtle and well beyond the scope of cs but please feel free to  talk with me more about it outside of class if you'd like  cs --     zen and the art of  algorithm design   a couple of generally good ideas principles to help you   design your algorithms and their implementations    the foundations i e  relevant definitions and data   structures should be as simple as possible while still  providing all needed functionality    let the foundations guide the development and analysis   of algorithms based on them   i might restate principle  as keep your foundations simple   i might restate principle  as let your definitions tell you what to do   let's apply this to binary trees  binary trees a review   remember binary trees from cs  this figure from clrs illustrates that binary trees could in principle  contain the same data in different tree structures parts a and b   part c shows external nodes the null fields in a typical implementation  of a binary tree  they can be thought of as empty sub-trees in context   external nodes are hidden in parts a and b   cs --     binary trees a review   remember binary trees from cs  application binary search trees bst's  just as a reminder of where  you've seen binary trees  before both of these are  examples of a binary search  tree a specific kind of  binary tree   in our work over the several  slides we'll talk not about  bst's but about binary  trees in general   what's a good definition of a binary tree  note this isn't asking about the definition of a bst but  about the more general data structure of a binary tree  one possible definition of   binary tree   often an implementation of a binary tree is based on two classes a   node class and a tree class as well as a type t of data to store   nodet class has fields   item t  the data stored at the node a value of type t   left node  the left sub-tree represented by its root node   right node  the right sub-tree represented by its root node    and perhaps others    treet class has fields  is this a good definition consider principle   keep your foundations simple    root nodet  the root node which represents the tree    and perhaps others such as    size int  the number of nodes in the tree   if we wanted a data structure just to be a binary tree of integers  for example would we need all of this structure  cs --     cs --   definition   note this definition may  show up on hw too  of our intbintree data structure   throughout cs we will sometimes refer to an intbintree   data structure representing a binary tree of integers    in english we'd say an intbintree is  either empty   or    an int called val  is this a good definition consider principle   keep your foundations simple    and two subtrees called left and right that are also intbintrees   programmers might be used to seeing it more like this  definition intbintree empty or int val  the int value not empty intbintree left  the left subtree intbintree right  the right subtree  is this definition equivalent  to the english one above  the fact that a tree could be  empty is often implicit in  many specifications  definition   note this definition may  show up on hw too  of our intbintree data structure    in english we'd say an intbintree is  we'll call them ibts for short   either empty   or    an int called val   and two subtrees called left and right that are also intbintrees   to be unambiguous and consistent with functional   programming about how we work with ibts these will be  the primitive functions defined on ibts  valt returns the val element of an ibt t  for cs these are the  only ways to access val  left right  so something  like t val is not permitted    leftt returns the left subtree of an ibt t   rightt returns the right subtree of an ibt t  important note valt leftt and rightt are functions that  return values  they are not fields of an object  because of this we cannot assign values  to them e g  valt   is not permitted     intbintrees an exercise   design an algorithm to return the number of levels in an   intbintree  definition intbintree empty or  int val  int value intbintree left  left subtree intbintree right  right subtree  as intbintrees we would say   -  -  tree a has  levels and  tree b has  levels   what design paradigm will we use for this algorithm    will it be iterative or recursive  consider principle  let your definitions tell you what to do   how does our definition of an intbintree tell us what to do here  intbintrees an exercise   design an algorithm to return the number of levels in an   intbintree  definition intbintree empty or  int val  int value intbintree left  left subtree intbintree right  right subtree  as intbintrees we would say   -  -  tree a has  levels and  tree b has  levels   because the definition of intbintree is recursive it makes   sense that algorithms over it would be recursive  in fact because an intbintree is defined recursively in terms of two intbintrees it might make sense for an algo over intbintree to have two recursive calls that's an example of principle  letting definitions tell us what to do   cs --     a review of recursive design  divide and conquer   every recursive algorithm has the following components  base cases one or more small cases for which it is easy to   identify or compute and return a solution   recursive cases one or more cases in which the algorithm calls   itself on a smaller instance of its input   divide the algorithm must break the original problem input  down into smaller sub-problems sub-inputs on which the algo  can be called recursively   conquer the algorithm must solve each of the sub-  problems   combine the algorithm must combine  employ the solutions   of sub-problems into a solution of the original problem   recursive cases bring input closer to terminating in a base case  it's really important that  recursions terminate  intbintrees an exercise   design an algorithm to return the number of levels in an   intbintree  reminder in english an intbintree   is either empty or  an int and two subtrees  definition intbintree empty or  int val  int value intbintree left  left subtree intbintree right  right subtree   for our recursive algorithm to compute the number of levels   what are the input and output   what input does the base case check for   what's the intended output for the base case   how many recursive calls will the algorithm make    how do we use output from   recursive calls to compute  the output on the given input  it can be helpful to write down  a problem specification with  input and output types   cs --     intbintrees an exercise   design an algorithm to return the number of levels in an   intbintree  reminder in english an intbintree   is either empty or  an int and two subtrees  definition intbintree empty or  int val  int value intbintree left  left subtree intbintree right  right subtree   our recursive algorithm to compute the number of levels  algorithm levelst input intbintree t output integer number of levels in t  if t is empty  return   else   return maxlevelsleftt levelsrightt     how would we explain this algorithm's correctness  correctness of recursive   algorithms inductive arguments   when arguing the correctness of a recursive algorithm the   general form is that of an inductive argument   the explanation follows the structure of the algorithm   show that the algorithm's base case returns correct output   show that the recursive cases return correct output  under the assumption that all recursive calls return correct output  just like when creating recursive code we assume recursive calls work in the  recursive case   here how would that work   how would we explain the  base case the recursive case  algorithm levelst input intbintree t output integer number of levels in t  if t is empty  return   else   return maxlevelsleftt levelsrightt    cs --     correctness of recursive   algorithms inductive arguments   when arguing the correctness of a recursive algorithm the   general form is that of an inductive argument   the explanation follows the structure of the algorithm   show that the algorithm's base case returns correct output   show that the recursive cases return correct output  under the assumption that all recursive calls return correct output  just like when creating recursive code we assume recursive calls work in the  recursive case   as part of explaining recursive  cases also explain how we  know the algo terminates   show arguments in recursive  calls get closer to base case  algorithm levelst input intbintree t output integer number of levels in t  if t is empty  return   else   return maxlevelsleftt levelsrightt    another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere   in an intbintree   how would we write the problem specification for ibtsearch   what would be the input   what would be correct output  definition intbintree empty or  int val  int value intbintree left  left subtree intbintree right  right subtree   how would we design an   algorithm to solve it  would the algorithm be iterative or recursive   how would we argue its correctness  cs --     another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere   in an intbintree   how would we write the problem specification for ibtsearch   input an int i and an intbintree t   output true exactly when i is in t  false otherwise  definition intbintree empty or  int val  int value intbintree left  left subtree intbintree right  right subtree  algorithm ibtsearchi t input int i intbintree t output true exactly when i is in t false otherwise  another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere   in an intbintree   how would we write the problem specification for ibtsearch   input an int i and an intbintree t   output true exactly when i is in t  false otherwise  definition intbintree empty or   int val  int value intbintree left  left subtree intbintree right  right subtree  algorithm ibtsearchi t input int i intbintree t output true exactly when i is in t false otherwise  if t  empty return false  else   if valt  i return true  else  return ibtsearchileftt or ibtsearchirightt  the last line uses the  boolean operator or  which is inclusive it is  true when either or  both operands are true  cs --     