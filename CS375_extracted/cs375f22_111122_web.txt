cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   apologies for missing class i really didn't want to   project  grading update   in progress but will be slow catching up from illness may take a   while   please meet with me if you'd like prompt feedback on any part of   project    ps due pm today   expect ps out soon   due no sooner than  week after it's assigned   project  out   will discuss today   due nov   deadline may be slightly extended  cs --     cs --   for proj  evaluating expressions   how do we as people evaluate an arithmetic expression like       do we read left to right not really   for proj  evaluating expressions   how do we as people evaluate an arithmetic expression like       do we read left to right not really    there are lots of components to that and we first evaluate each   component and then combine them to evaluate the entire expression    for proj  evaluating expressions   how do we as people evaluate an arithmetic expression like       do we read left to right not really    there are lots of components to that and we first evaluate each   component and then combine them to evaluate the entire expression    it's as if we had an evaluate function   and applied it recursively we use it on each component then   combine to get our end result  for proj  evaluating expressions   how do we as people evaluate an arithmetic expression like       do we read left to right not really    there are lots of components to that and we first evaluate each   component and then combine them to evaluate the entire expression    it's as if we had an evaluate function   and applied it recursively we use it on each component then   combine to get our end result   evaluating propositional logic expressions works the same   way in general  let's get formally introduced to propositional logic  cs --     propositions   defn proposition  a statement that has the   property of truth or falsity   propositions are the key elements to represent   analyze or explain declarative knowledge  propositions  washington d c  is the capital  of the usa   waterville is the capital of  maine               the first and third  of these are true  the second and  fourth are false   non-propositions  what time is it   pass the salt   x      xy  z  presuming  values for x  y z are not  given  known  propositional operators   recall proposition  a statement that has the property of   truth or falsity  often we use propositional letters or variables to represent   propositions e g  p stands for poughkeepsie is the capital of ny   there are several operators sometimes called boolean  operators that can construct new propositions from old ones  negation not if p is a proposition not p is a proposition  conjunction and p and q   disjunction or p or q  implication if  then if p then q  cs --     propositional operator negation   whatever the value of p true or false the value of   proposition not p written p is the opposite   if p is today is monday p is it is not the case that   today is monday or more simply today is not monday    negation can be expressed with a truth table  p  t  f  p  f  t  proposition  truth values  propositional operator conjunction   conjunction the and operator   whatever the values of propositions p q conjunction p and   q written p  q or p  q is also a proposition   if p is today is monday and q is it is snowing today  then p  q is today is monday and it is snowing today   p  q is true on snowy mondays and false on any day that is not   monday and on any day that is monday but not snowing   conjunction values as a truth table   p  t  t  f  f  q  t  f  t  f  pq  t  f  f  f  cs --     cs --   propositional operator disjunction   disjunction the or operator   whatever the values of propositions p q disjunction p or q written p v  q or p  q is also a proposition   if p is today is monday and q is it is snowing today then p v q is   today is monday or it is snowing today    p v q is true on any day that is a monday or on which it is snowing   including snowy mondays it is not exclusive  and false only on days that  are not mondays on which it is not snowing   disjunction values as a truth table   the non-exclusive sense of  or can be a bit subtle  p  t  t  f  f  q  t  f  t  f  p v q  t  t  t  f  exercise what would the  exclusive-or operator's truth  table look like   it turns out there is such an  operator and it's commonly  used in logic the english  word or is a complicated  thing to understand  propositional operator implication    implication the ifthen operator also called conditional  whatever the values of propositions p q implication if p then q   written p  q is also a proposition   if p is today is monday and q is it is snowing today then p  q is   if today is monday then it is snowing today    vocabulary in p  q p is called the hypothesis or antecedent and q is   called the conclusion or consequent     implication values as a truth table   p  t  t  f  f  q  t  f  t  f  p  q  t  f  t  t  really these are the  truth values for  implication   they look like the values  for p v q exercise  check for yourselves    sounds if-y  material implication   meaning for implication   symbol  in propositional  logic is referred to as  material implication  it says that pq is false   exactly when p is true and q is false   not the same as every   meaning of ifthen in  english but it's what's used  in logic  p  t  t  f  f  q  t  f  t  f  p  q  t  f  t  t  examples of material implication  and natural language usage  politician says if i am elected  then i will fix the environment  false if the speaker is  elected and doesn't fix the  environment  true if e g  the speaker  doesn't get elected  if today is friday then       true no matter what day it is  if today is friday then       true except on fridays even  though      is false  exercise evaluating propositional   logic expressions   defn propositions are   boolean-valued  expressions i e  their  values are either true or  false   propsotional expressions   are evaluated like any  other mathematical  expressions  examples let p  true q   false r  true  what do  the following expressions  evaluate to     p  r     q v false     p  q     r v p  q     p v r  p v q  r     true  r  cs --     for proj satisfiability and assignments   of truth values to variables   an assignment of values to variables  is what you think it is something  like p  true q  false r  true is as assignment of truth values to  the variables p q r   we say a propositional logic   expression ple p is satisfiable if  there is an assignment of truth values  to the variables in p so that p evaluates to true  examples let p  true q   false r  true  what do  the following expressions  evaluate to     p  r     q v false     p  q     r v p  q     p v r  p v q  r     true  r  business project    project  out due nov     deadline may be slightly extended  have you read through proj yet  please note the separate supplementary  document about truth tables   parts of project     recursive algorithm to evaluate propositional logic expressions your   team will create an algorithm to do the kind of thing a programming language  does evaluate propositional logic boolean expressions     exhaustive search algorithm for satisfiability the satisfiability problem   sat for short asks if there is a way for a propositional logic expression to be  made true  your team will create an exhaustive search algorithms to solve this  problem     improvements your team will improve upon your exhaustive search   algorithm      create and give a presentation your team will present work from the   previous three parts of the assignment using recurrences and inductive  arguments loop invariants where appropriate   cs --     cs --     solving recurrences   we'll cover three common techniques for solving   recurrences i e  getting  or o bounds on the solution   unwinding or backward substitution unroll the recurrence   until it reaches a base case then count  analyze the cost  represented  we already did an example of unwinding and we'll  do another one soon   recursion-tree method represent costs as nodes in a tree and   analyze total cost   master method solve recurrences of the form   tn  atnb  fn  unwinding  this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow    an example solve tn  tn  n  what information is missing from this recurrence which we will  need to be able to solve it   unwind the recurrence by plugging in the definition on   successively smaller arguments  from the definition tn  tn  n   by that same definition tn  tn  n  tn  n   so by plugging that in tn  tn  n  n   what would the next steps be in this unwinding process   where would it stop  unwinding  this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow    an example solve tn  tn  n  what information is missing from this recurrence which we will  need to be able to solve it   unwind the recurrence by plugging in the definition on   successively smaller arguments  from the definition tn  tn  n  tn   tn  n tn   tn  n  tn  n tn  tn   tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n               do you see a pattern here and when does this unwinding end  cs --     unwinding  this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow    an example solve tn  tn  n   for a base case let's use t   or  if we want   unwind the recurrence by plugging in the definition on   successively smaller arguments  from the definition tn  tn  n  tn   tn  n tn   tn  n tn  tn   tn  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                  kkkktn tnkkkk  kn   kn tn tn   kn   kn               the k'th step shown here illustrates  the pattern that holds for any  relevant k  it can help with our  analysis to show this in our work  unwinding  this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow    an example solve tn  tn  n   for a base case let's use t   or  if we want   unwind the recurrence by plugging in the definition on   successively smaller arguments  from the definition tn  tn  n  tn   tn  n tn   tn  n  tn  n tn  tn   tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                  kkkktn tnkkkk  kn   kn tn tn   kn   kn                     nt  lg nn  nt  lg nn  nt  lg nn  nt  lg nn     n lg n  the lg n term comes because the  recurrence unwinds lg n times  before hitting the base case do  you see why  cs --     cs --     recursion trees an overview  recursion trees can represent how a recursive algorithm   breaks input down into recursive calls on sub-problems   or equivalently combines recursive calls into a solution on the original   problem   here's an example from clrs mergesort   each node shows input size at that level of   recursive calls  here original input size  breaks into   sub-problems of size  etc    this example shows the recursion going   up the tree combining solutions    note that the input sizes at each node   would be the same for the recursion going  down the tree breaking into sub-problems  recursion trees for solving time-  complexity recurrences   when using recursion trees to solve for time complexity   though we don't need quite that much information  we do need the structure showing how the algo divides and re-  combines its inputs   we do need the input size at each node   we do not need details about exactly what   the input is at each node  recall asymptotic  complexity is in terms of  input size n not individual  inputs of a given size   what we need for each node of the tree   input size at each node   a way to represent the work done i e  the runtime at that node of   the tree not including any other work done above or below it  let's do an example  recursion-tree method   an example  mergesort             t n             t n            sorting both halves    n   merging  if   n    otherwise  tn  n  what's the recursion   tree structure  what's the cost at each   tree-level i e  not   counting levels below it  cs --     recursion-tree method   an example  mergesort             t n             t n            sorting both halves    n   merging  if   n    otherwise   set up a tree to   total up the work  done by the  algorithm  tn  n  what's the recursion   tree structure  what's the cost at each   tree-level i e  not   counting levels below it   tree structure for complexity analysis corresponds to tree of   recursive calls by the algorithm   total work by the algorithm sum of work at all levels of the tree  recursion-tree method   an example  mergesort             t n             t n            sorting both halves    n   merging  if   n    otherwise  tn  tn  tn  tn  tn  tn  tn  logn  tn  k  t  t  t  t  t  t  t  t  recursion tree for algorithm  n  n  n        k n  k        n   n logn  total work done  cs --     recursion tree exercises   use the recursion-tree method to solve the following   recurrences for n    tn  tn  n if n    if n    assume n is a power of    tn  tn  n if n    if n    assume n is a power of    tn  tn  n if n    if n   assume n is a power of    tn  tn  n if n    if n   assume n is a power of   keep in mind the formula for the sum of a geometric series  from appendix a    in ci  cn    c-  for constant c neq   recursion tree exercises   use the recursion-tree method to solve the following   recurrences for n    tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     those last three examples illustrate three different cases    the amount of work per level increases with the most work done   at the leaves of the tree  in fact it increases geometrically this means see me for a proof if  you'd like the total amount of work is work done at leaves  cs --     recursion tree exercises   use the recursion-tree method to solve the following   recurrences for n    tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     those last three examples illustrate three different cases    the amount of work per level increases with the most work done   at the leaves of the tree    the amount of work per level decreases with the most work   done at the root  in fact it decreases geometrically this means see me for a proof if  you'd like the total amount of work is work done at root  recursion tree exercises   use the recursion-tree method to solve the following   recurrences for n    tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n    note these three cases  are important we'll  come back to them on a  later slide   those last three examples illustrate three different cases    the amount of work per level increases with the most work done   at the leaves of the tree    the amount of work per level decreases with the most work   done at the root    the amount of work per level is constant and there are              lg n   levels in the tree  there are lg n   levels in all three cases  really but it's of particular importance here  cs --     