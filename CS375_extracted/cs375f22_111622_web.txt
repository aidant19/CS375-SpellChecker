CS   CS   Analysis of Algorithms Professor Eric Aaron Lecture  M W pm Lecture Meeting Location Davis  Business  SA due Monday Nov   SA out today also due Monday Nov   PSLookahead out today  Please get started on it  PS due Nov   Project  out due pm Monday Nov   Yes thats a lot due Nov  would you prefer something due earlier  Project  Grading update  Please meet with me if youd like prompt feedback on any part of Project How many of you wont be here for Mondays class CS   How to make an algorithm not just a little faster but a LOT faster  Making algorithms a little fasterchanging the leading constant or handling special casesis good Keep doing it  Making algorithms a LOT faster can be even better  Well discuss one important technique dynamic programming  Primarily used when theres a recursive definition  at the center of an algorithm and its slowing things down  Dynamic programming speeds things up by getting ri d of redundant work without changing the main ideas of the algorithm  Can turn algos from exponential time into polynomial time Illustrative Example Fibonacci Numbers  Consider divideandconquer and dynamic programming approaches to calculating the Fibonacci numbers  Fibonacci definition  F   F    Fn  Fn  Fn for n    Straightforward topdown recursive approach RFibonacci n   if n   or n   then return n  else return RFibonaccin  RFibonaccin Note There are two base cases Having more than one base case is not uncommon with recursive definitions CS   Even More Illustrative Example Fibonacci Numbers  Straightforward topdown recursive approach RFibonacci n    if n   or n   then return n   else return RFibonaccin  RFibonaccin  Where are its inefficiencies  One possible dynamic programming approach a memoized recursive  approachuses an auxiliary table to store results MFibonaccin   How would we write a memoized recursive Fibonacci function This is an exponential algorithm See CLRS pg  for some of the math behind that and see me for the rest Even More Illustrative Example Fibonacci Numbers  Memoized version of Fibonacci method  Example of a timememory or timespace tradeoff  Whats the time complexity  What would a bottomup Fibonacci approach look like MFibonaccin  let Fn be a new array  F    if n    F    for j  n  Fj   or other sentinel  return MFibAuxFnMFibAuxFn if Fn    return Fn  else  Fn  MFibAuxFn  MFibAuxFn  return Fn CS   Even More Illustrative Example Fibonacci Numbers  Straightforward topdown recursive approach RFibonacci n    if n   or n   then return n   else return RFibonacci n  RFibonacci n Even more efficient bottomup approach Fibonaccin  f   f   for  i    n  fi  fi  fi  return fn  Could we do even better In what ways In what ways is this more efficient What is the time complexity of this method The space complexity Even More Illustrative Example Fibonacci Numbers  Straightforward topdown recursive approach RFibonacci n    if n   or n   then return n   else return RFibonacci n  RFibonacci nEven more efficient  bottomup approach Fibonaccin  f   f   for  i    n  temp  f  f  f  f f  temp  return temp In what ways is this more efficient What is the time complexity of this method The space complexity CS   Dynamic Programming  The inefficient Fibonacci algorithms had a lot of recursive calls  With a lot of redundant workthe same calculations were done many times eg calculate Fib as part of calculating Fib Dynamic programming techniques can be more efficient for problems that have overlapping subproblems  Divideandconquer methods recursively solve subp roblems then combine subsolutions into a solution  When there are overlapping repeating subproblem s some of this work can be redundant  Dynamic programming methods can solve each subpro blem once store results in a table O lookup and use the table  for later solutions For the Most Part The efficient Fibonacci methods used a characteristic technique of dynamic programming  Results stored in a table or similar used to im prove efficiency  Dynamic programming solutions can be either topdown or bottomup  But most of the time in practice when people tal k about a dynamic programming solution they mean a bottomup solutio n  In general when looking for a dynamic programming solution  Try recursive topdown approach with overlapping subproblems  Consider a memoized version  Then try bottomup iterative approach based on s ubproblems  Then try to improve on space complexity of botto mup method CS   For the Most  Part   Dynamic programming is often applied to optimization problems  to find a solution with an optimal minimal or maximal value Often for optimization problems it is or seems  necessary to consider all subsets of a set   so if were looking at a set of size n whats the time complexity of such an algorithm  Characteristic structure for dynamic programming a lgorithms  Overlapping subproblems as previously seen Optimal substructure  an optimal solution is built from the optimal sol utions of subproblems This makes total sense if you think about it for a while If there isnt redundant work in the algo or if optimal solutions arent based on o ptimal solutions to subproblems then why would we store solutions to subproblemsFor the Most  Part   Dynamic programming is often applied to optimization problems  to find a solution with an optimal minimal or maximal value Often for optimization problems it is or seems  necessary to consider all subsets of a set   so if were looking at a set of size n whats the time complexity of such an algorithm  Characteristic structure for dynamic programming a lgorithms  Overlapping subproblems as previously seen Optimal substructure  an optimal solution is built from the optimal sol utions of subproblems  Steps in developing a dynamic programming algorith m  Characterize the structure of an optimal solution  in words  Recursively define the value of an optimal soluti on  Compute the value of an optimal solution from the bottom up  Construct an optimal solution from computed information These are on CLRS pg  Well focus on steps  and  leading to step  This makes total sense if you think about it for a while If there isnt redundant work in the algo or if optimal solutions arent based on o ptimal solutions to subproblems then why would we store solutions to subproblemsCS   Sequences and Subsequences  Another category of problems involves sequences and subsequences  Definition  Given sequence X  x  x   x m another sequence Z  z  z    z k is a subsequence of X if   there exists a strictly increasing sequence  iiik of indices of X st for all j in k x ij  z j ie elements of X preserving order  Example  Definition  If X  ABACAB and Y  ABBA   then AA AB BA BB ABA ABB and others are all subsequences of  both X and Yie they are common subsequences CS   Longest Common Subsequence  If X  ABCBDAB and Y  BDCABA then BCA is a common subsequence but not a longest common subsequence LCS  BCBA and BCAB are both longest common subsequences of X Y  there is no common subsequence of length   The Longest Common Subsequence problem   Given X   x  x   xm and Y  y  y  yn find a longest common subsequence LCS of X and Y  Whats the brute force way to solve this Whats its time complexity And what can we do about that Dynamic Programming to the Rescue  The LCS problem seems like a candidate for a dynam ic programming solution Does it look like a recursive definition of LCS wo uld be helpful Hint Yes  Is there optimal substructure Can the LCS of two sequences X and Y be built from the LCS of subsequences Divide and con quer  Are there overlapping subproblems Are there redu ndant calculations in a recursive solution  As part of a recursive  divideandconquer defini tion well refer to the ith prefix of a sequence Definition  Notation  Given a sequence X  x  x   xm the ith prefix for i in m is X i x  x   x i So in our notation see prev slide X   x  x   xm  Xmand Y  y  y  yn  YnCS   LCS A Recursive Solution  Let X  x x  xmand Y  y y  ynbe sequences and let Z  z z  zkbe any LCS of X and Y  How does Z relate to LCSs of X and Y Or to LCSs of prefixes of X and Y  How does this lead to a recursive solution for the length of an LCS What subproblems need to be solved LCS A Recursive Solution  Let X  x x  x mand Y  y y  y nbe sequences and let Z  z z  z kbe any LCS of X and Y  How does Z relate to LCSs of X and Y Or to LCSs of prefixes of X and Y  Case   If x m  y n then z k x m y nand Z kis an LCS of X mand Y n Case   If x m  y n then if z k x mthen Z is an LCS of X mand Y  Case   If x m  y n then if z k y nthen Z is an LCS of X and Y n How does this lead to a recursive solution for the length of an LCS What subproblems need to be solved Do you see overlapping subproblems from this formul ation CS   LCS A Recursive Solution  Next step recursively find the length of the longest common subsequence of X Y  How can we do that based on our three cases  Case   If x m  y n then z k x m y nand Z kis an LCS of X mand Y n Case   If x m  y n then if z k x mthen Z is an LCS of X mand Y  Case   If x m  y n then if z k y nthen Z is an LCS of X and Y n Note We need to track lengths of LCSs of various subproblems  Use Cij to store the length of LCS of X i Y jGoal compute Cmn Whats the base case for this recursion The recursion is over sequences whats the smallest sequence we might consider LCS A Recursive Solution  Next step recursively find the length of the longest common subsequence of X Y  How can we do that based on our three cases  Case   If x m  y n then z k x m y nand Z kis an LCS of X mand Y n Case   If x m  y n then if z k x mthen Z is an LCS of X mand Y  Case   If x m  y n then if z k y nthen Z is an LCS of X and Y n Note We need to track lengths of LCSs of various subproblems  Use Cij to store the length of LCS of X i Y j Recursive formulation  Base case Cj   and Ci   for all i j  Recursive  step to compute Cij where ij    If x i y j Cij  Cij    If x i  y j Cij  maxCij Cij Goal compute Cmn This reflects  uses the three subproblems noted above CS   LCS A Recursive Solution  Recursively find the length of the LCS of X Y  Base case Cj   and Ci   for all i j  Recursive  step to compute Cij where ij    If x i yj Cij  Cij    If x i  yj Cij  maxCij Cij  Straightforward recursive code  Initialize Ci  Cj   for i in m j i n n  Initialize Cij  NIL for i in m j in n  LCSi j  i j are indices  this is for a particular i j   if Ci j  NIL  could use other sentinel value        then if x i y j                   then Ci j  LCSi j    one less of both XY                    else Ci j  maxLCS i j LCS i j   return Ci j ie one less elt of either X or Y ie one less elt of both X and Y Initialize C including the base cases For the Most Even More  Recall steps to developing a dyn prog algorithm  Characterize the structure of an optimal solution  in words  Recursively define the value of an optimal soluti on  Compute the value of an optimal solution from the bottom up  Construct an optimal solution from computed information  Weve done the first two Now  How to compute the value of an optimal solution ie the length of a longest common subsequence with bottomup design i nstead of topdown recursion Perhaps using a table to avoid red undant work  What additional information would support construc ting a solutionan actual longest common subsequencefrom the computati on of the optimal value Stay with the same basic ideas just expressed in a  different design CS   Bottomup Computation of Optimal LCS Value  Need mbyn matrix C to store lengths  To compute Cij need values of Cij when  x i yj and Ci j and Ci j when x iyjLCSX Y  input sequences X Y   m  lengthX   n  lengthY   for i   to m do  Ci       in first col of each row   for j   to n  do  C j     in first row of each col   for i   to m do       for j   to n do     process row by row            if xi yjthen Ci j  Ci j              else Ci j  max Ci j Ci j   return Cm n What is the optimal lengththe length of an LCS of full sequences  X and Y What is the time complexity of this algorithm Actually mbyn to include the  case too Recall our recursive definition    Base case Cj   and Ci   for all i j Recursive  step to compute Cij for ij    If xi yj Cij  Cij   If xi  yj Cij  maxCij Cij Bottomup Computation of An Optimal LCS  To find an LCS also store which symbols indices of symbols are actually part of the LCS as its being built  ie  which table elements have optimal subprobl em values  if x i y j  answer came from the upper left diagonal of curr ent element  if x iyjthe answer came from above or to the left whicheve r is larger if equal we can choose above by convention LCSX Y   m  lengthX   n  lengthY   for i   to m do  Ci     for j   to n  do  C j    for i   to m do       for j   to n do  if xi y j then Ci j  Ci j    Bi j  UpLeft      else  if Ci   j   Ci j   then  Ci j  Ci   j             Bi j  Up one less elt of X  else Ci  j  Ci j    Bi j  Left one less elt of Y ie one less elt of both X and Y ie  either X or Y CS    LCS example LCS of X  ABCBDAB and Y  BDCABA The algorithm finds an LCS BCBA Are there others And finallyFinding a Solution from the Values  That bottomup method gives us the information from which we can get an optimal value and the associated indices  To actually find  print the longest common subsequence start at the bottomleft of the table and follow the arrows Print LCS BXij  if i   or j   then return   if Bij  UpLeft        then PrintLCSBXij                 print x i  else if Bij  Up        then PrintLCSBXij   else PrintLCSBXij Initial call has i  m ie lengthX j  n lengthY   B is the arrow table from the previous slide 