 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   ps due dec     sa returned   ps grading update   project  due pm monday dec    important admin notes   change to syllabus to be counted for credit all pss and sas  including revisions must be submitted by pm sunday dec    extended from dec     final ta hours of semester thursday dec     additions to our schedule   make-up lecture friday dec   at pm davis     office hours monday dec   am  acknowledgment some ideas in today's notes are inf luenced by  httpswww cs princeton eduwaynecslectures np-complete  cs --    which is easier pt     which is easier finding a solution or checking  verifying a  solution   consider the problem of checking if a number is composite  i e  not a prime number   input integer n   output yes if n is composite if there exists some number   c  n  such that n is a multiple of c no otherwise i e   n is prime   which is easier   finding if n   is composite or   checking that c   is a factor of n this kind of thing can be useful in  cryptography applications  thanks to httpswww cs princeton eduwaynecs lecturesnp-complete it's useful to think of this  as solving the problem  when you're given a  solution  and all you  have to do is confirm it  which is easier pt     which is easier finding a solution or checking  verifying a  solution   consider the problem of checking if a number is composite  i e  not a prime number   input integer n   output yes if n is composite if there exists some number   c  n  such that n is a multiple of c no otherwise i e   n is prime   which is easier   finding if n   is composite or   checking that c   is a factor of n this kind of thing can be useful in  cryptography applications  thanks to httpswww cs princeton eduwaynecs lecturesnp-complete vocabulary certificate  we call the possible  solution that was given  to us to be checked a  certificate  here  is a certificate  cs --    which is easier pt     which is easier finding a solution or checking  verifying a  solution   a clique in an undirected graph gve is a subset v 'v  s t  each pair in v' is connected by an edge in e   i e  a clique corresponds to a complete subgraph of g   the clique problem   input graph g and integer k   output yes if there is a clique of  size k in g no otherwise   which is easier   finding a clique of size  in a graph g or   checking that vertices uvxy are a clique of s ize  in graph g  vocab review here the set uvxy would be a certificate  which is easier pt     which is easier an optimization problem or its related  decision problem   consider the optimization problem of finding a minimum  spanning tree mst of a graph   compare that to the related decision problem mst-d ecision  given a graph g and a number w does g have an mst with total  weight at most w  cs --    which is easier pt     which is easier an optimization problem or its related  decision problem   consider the optimization problem of finding a minimum  spanning tree mst of a graph   compare that to the related decision problem mst-d ecision  given a graph g and a number w does g have an mst with total  weight at most w  some observations    if it's easy fast to solve the optimization pro blem it's easy fast to solve the  decision problem just use the optimization problem a nswer    it's not true the other way around if it's easy fast to solve the decision problem  for a particular value of w it's not necessarily e asy to solve the optimization  problem you might have to check a lot of different v alues of w  which is easier pt     which is easier an optimization problem or its related  decision problem   consider the optimization problem of finding a minimum  spanning tree mst of a graph   compare that to the related decision problem mst-d ecision  given a graph g and a number w does g have an mst with total  weight at most w  some observations    if it's easy fast to solve the optimization pro blem it's easy fast to solve the  decision problem just use the optimization problem a nswer    it's not true the other way around if it's easy fast to solve the decision problem  for a particular value of w it's not necessarily e asy to solve the optimization  problem you might have to check a lot of different v alues of w    so if the decision problem can't be solved easil y we know the optimization  problem can't be solved easily either this is subtle let's think about it   cs --    map visitation problem mvp   so you're at your job and your supervisor tells you to write an  efficient poly-time algo to solve the mvp in the general ca se not  just special cases of it  what do you do multiple choice    use a minimum-spanning tree approach    use an all-pairs shortest paths approach    have a long conversation with your supervisor abo ut wasting better uses of  your time  input integer knumber of robots  weighted undirected graph g  ve map for visitation    depots dv   vkstarting points for each robot  output min-max length of the paths for visiting al l nodes in g  given starting depots d      robots  start here example options  and  won't work but before you  do option  you should know you're right  cs --    review reductions  subroutines and time complexity   in general and in these specific examples key to using a  subroutine is to meet its specifications   structure your algorithm to give subroutine the pr oper input   structure your algorithm to use subroutine's outpu t to solve the original  problem   in these cases can reduce one problem a to another problem  b where there's already a subroutine  algorithm for b   algorithm that does the reducing can be called a  reduction  important but maybe obvious note   complexity of resulting algorithm depends on compl exity of subroutine  this is not surprising the complexity of every algor ithm depends  on the complexity of its parts  i'm just making tha t point explicit here  because we'll use it again later   graph problems clique   a clique in an undirected graph gve is a subset v 'v s t   each pair in v' is connected by an edge in e   i e  a clique corresponds to a complete subgraph of g   the clique problem   input graph g and integer k   output yes if there is a clique of size k in g n o otherwise  on project  someone on your team  designed a brute force algorithm for  clique that was not polynomial time  poly time  for short    can you design a poly time algorithm  for clique we'll be considering decision problems from here on  out unless otherwise specified  cs --    graph problems vertex cover   a vertex cover of an undirected graph gve is a subset v 'v s t  if  uv is in e then at least one of u or v is in v'  that is if a vertex covers its incident edges a vertex cover is a set that  covers all of e   the size of a vertex cover is the number of vertic es in it   the vertex cover problem   input graph g and integer k   output yes if there is a vertex cover of g with s ize k no otherwise  graph for which vertex set w z is a vertex  cover of size   also called network cover on project   graph problems and subroutines   reductions   recall focusing only on decision problems   the clique problem   input graph g and integer k  output yes if there is a clique of size k in g  no otherwise   the vertex cover problem   input graph g and integer k  output yes if there is a vertex cover of g with si ze k  no otherwise   how could we use a solution for one of these as a subroutine to solve the  other   for example assume we had a solution for vertex c over  how  could we use that to create a solution for clique   cs --    reduction from clique to  vertex cover   for a graph gve we can consider the complement of g gve   that is the complement of g consists of the same vertices as in g and all the  edges pairs of vertices unordered not in g   given an instance g ck c of clique construct instance g vc k vc  of  vertex cover where   gvc is the complement of g c  kvc is v - kc that is the number of vertices not in the possible clique for the  clique instance  is this a polynomial time reduction  what does this reduction say about the  complexity of vertex cover   assume that clique cannot be solved in polynomial time   then because we can reduce clique to vertex  cover in poly time   we know vertex cover cannot be poly time either   how do we know argument by contradiction   if vertex cover could be solved in poly time we'd  use that poly  time algorithm as our subroutine   then we'd be able to solve clique in poly time by this reduction   but clique by assumption at the beginning of this  slide can't be  poly time so our assumption that vertex cover coul d be poly  time must be false this is a huge assumption note that we're not just  saying one algorithm  is not poly time  we're saying every algorithm is not poly time we're  talking about the complexity of the problem  not just of an algorithm   this is deep   and useful   cs --    tractability and complexity   tractability   it is generally accepted that a problem is tractable solvable in practice  not just in theory if there is a polynomial-time algorithm for it    i e  in class onk for some constant k   if a problem requires an exponential time solution  or worse it is  considered intractable without an efficient solution  goal classify problems by how efficiently they can be solved   big-o or theta classes relatively fine-detail d istinctions   tractability distinctions based in larger classes  p problems solvable in polynomial time hence the name p  np problems with solutions verifiable in polynomial time   pspace  problems solvable in polynomial space no  restriction on time   exptime problems solvable in exponential time   expspace problems solvable in exponential space etc  etc  etc   more about  verifiability  coming soon  cs --    the class np  a quick introduction   np the class of problems solvable in nondeterministic  polynomial time hence the name np   somewhat loosely that means that a problem is in np if it can be  verified in polynomial time   could think of it as if we were given a certificate of a solution  essentially a potential solution  we could check it for correctness    is it actually a solution in polynomial time in input size   could think of it as if given a correct certifi cate we could solve  the problem in polynomial time   note that if a solution to a problem can be found in polynomial  time that problem can be verified in polynomial ti me   what does this say about the relationship between p and np   for more about nondeterminism in computation see  cs recall this is about decision problems not relat ed optimization problems  clique is in np   a clique in an undirected graph gve is a subset v 'v s t   each pair in v' is connected by an edge in e   i e  a clique corresponds to a complete subgraph of g   the clique problem   input graph g and integer k   output yes if there is a clique of size k in g n o otherwise we'll focus on  v'    do  you see why  clique is in np  what would a poly-time verification algorithm  take as input  -what would the certificate be  -what would the verification algorithm do  using the certificate  cs --    hamiltonian cycle is in np   consider the hamiltonian cycle problem   a hamiltonian cycle of a connected directed graph gve is a simple cycle  that contains each vertex in v though perhaps not every edge in e   the hamiltonian cycle problem given connected dig raph g does g contain a  hamiltonian cycle  example  is there a hamiltonian cycle  in this graph in some sources hamiltonian  is capitalized but not in clrs  historical note hamiltonian cycle isn't named  after that hamilton   less historical note i have a great idea for an  np-completeness musical  lin-manuel call me also called hamiltonian tour on project   although nobody knows for sure experts  believe that an np-completeness musical  would run for a very very long time  hamiltonian cycle is in np   consider the hamiltonian cycle problem   a hamiltonian cycle of a connected directed graph gve is a simple cycle  that contains each vertex in v though perhaps not every edge in e   the hamiltonian cycle problem given connected dig raph g does g contain a  hamiltonian cycle  example  is there a hamiltonian cycle         in this graph in some sources hamiltonian  is capitalized but not in clrs  hamiltonian cycle is in np  what would a poly-time verification algorithm  take as input  -what would the certificate be  -what would the verification algorithm do  using the certificate  cs --    which is easier pt     recall the hamiltonian cycle problem   a h amiltonian cycle of a connected directed graph gve is a simple  cycle that contains each vertex in v though perhap s not every edge in e   the hamiltonian cycle problem given connected dig raph g does g contain  a hamiltonian tour   consider the euler tour problem   an euler tour of a connected directed graph is a cycle that uses  each edge  exactly once though it can visit vertices multiple  times   the euler tour problem given connected digraph g  does g contain an euler  tour   how long what complexity would it take to    solve each of these problems    verify that a possible solution was correct if w e were given one   and is there a meaningful difference in tractabili ty between the problems  cs --    p np and np-completeness   we know p np because if a solution can be found in polynomia l time  one can be checked in polynomial time   is np p good question  one of the best around actually   extra credit exercise prove or disprove np p  you would get an a for  this course  oh and also  at least  real ly    it is generally believed that p np problems in p are tractable and np- problems not in p are thought to be intractable   thus it's important to determine if a problem is in np or at least as hard as a  problem that is in np and not known to be in p   complexity class npc  class of np-complete problems   a problem is np-complete if a it is in np and b  it is at least as hard as  every problem in np   so if one np-complete  problem is tractable all problems in np are tractable no joke this is an exceptionally important slide   npc problems are the hardest problems in  np thus they're presumed intractable  using reductions to show  intractability   if we know problem b has no polynomial time algori thm then consider a  reduction from b to a   takes an instance  of b   transforms it in polynomial time into an instance  of a    such that a decision on  would give us a decision on    then if a could be solved in polynomial time b c ould also   thus by contradiction a must not be solvable in polynomial time   more generally a is at least as hard to solve in poly time as b   a similar procedure will be used to show np-completeness   if b is np-complete a must be at least as difficult to solve  in poly time so a is a candidate for being np-complete   this is a common use of polynomial-time reductions at least we think  they're intractable  cs --    np-completeness   more formally  concisely here's what we mean by  np-completeness complexity class npc   l npc iff    l np    for every l' in np  l' reduces to l  an implication   if l is np-complete and l is in p then  if l satisfies   it is called np- hard    if l is np-hard and also in np   then it's np-complete   np-completeness   more formally  concisely here's what we mean by  np-completeness complexity class npc   l npc iff    l np    for every l' in np  l' reduces to l  an implication   if l is np-complete and l is in p then p  np  so  if p np then if l is np-complete l is not in p  we think p np  so we believe all np-complete problems are  not possible to solve in poly time  but we don't kn ow for sure if l satisfies   it is called np- hard    if l is np-hard and also in np   then it's np-complete   cs --    which of these represents something  possible about p and np  list of np-complete problems  partial list from wikipedia   graphs and hypergraphs   graphs occur frequently in everyday  applications  examples include  biological or social networks which  contain hundreds thousands and even  billions of nodes in some cases e g   facebook or linkedin    -planarity   -dimensional matching   bipartite dimension   capacitated minimum spanning  tree   route inspection problem also  called chinese postman problem for  mixed graphs having both directed and  undirected edges  the program is  solvable in polynomial time if the graph  has all undirected or all directed edges   games and puzzles   battleship   bulls and cows marketed as master  mind certain optimisation problems  but not the game itself    eternity ii   generalized freecell   fillomino   hashiwokakero   heyawake   generalized instant insanity   kakuro cross sums   kuromasu also known as  kurodoko   lemmings with a polynomial time  limit   light up httpsen   wikipedia   orgwikili  stofnp- complete  problems  cs --    list of np-complete problems  partial list from wikipedia   graphs and hypergraphs   graphs occur frequently in everyday applications  examples include biological or social networks whi ch contain hundreds thousands and even billions of  nodes in some cases e g   facebook or linkedin    -planarity   -dimensional matching   bipartite dimension   capacitated minimum spanning tree   route inspection problem also called chinese post man problem for mixed graphs having both directed  and undirected edges  the program is solvable in p olynomial time if the  graph has all undirected or all directed edges  var iants include the rural postman problem    clique problem   complete coloring a k a  achromatic number   domatic number   dominating set a k a  domination number   np-complete special cases include the edge dominat ing set problem i e  the dominating set problem i n line graphs  np-complete variants include the con nected dominating set  problem and the maximum leaf spanning tree problem     bandwidth problem   clique cover problem   rank coloring a k a  cycle rank   degree-constrained spanning tree   exact cover problem  remains np-complete for -set s  solvable in polynomial time for -sets this is a matching    feedback vertex set   feedback arc set   graph homomorphism problem   graph coloring   graph partition into subgraphs of specific types  triangles isomorphic subgraphs hamiltonian subgra phs forests perfect matchings are known np-compl ete  partition into cliques is  the same problem as coloring the complement of the given graph  a related problem is to find a partiti on that is optimal terms of the number of edges bet ween parts    hamiltonian completion   hamiltonian path problem directed and undirected     longest path problem   maximum bipartite subgraph or especially with wei ghted edges maximum cut    maximum independent set   maximum induced path   graph intersection number   metric dimension of a graph   minimum k-cut   steiner tree or minimum spanning tree for a subse t of the vertices of a graph  the minimum spann ing tree for an entire graph is solvable in polynom ial time    modularity maximization   pathwidth   set cover also called minimum cover problem this  is equivalent by transposing the incidence matrix  to the hitting set problem    set splitting problem   shortest total path length spanning tree   slope number two testing   treewidth   vertex cover  mathematical programming   -partition problem   bin packing problem   knapsack problem quadratic knapsack problem and several variants   variations on the traveling salesman problem  the problem for graphs is np-complete if the edge lengt hs are assumed integers  the problem for points on the plane is np-complete  with the discretized euclidean metric and rectiline ar metric  the problem is known to be np-hard with the non-discretized euclidean metric    bottleneck traveling salesman   integer programming  the variant where variables a re required to be  or  called zero-one linear pr ogramming and several other variants are also np-c omplete   latin squares the problem of determining if a par tially filled square can be completed to form one   numerical -dimensional matching   partition problem   quadratic assignment problem   quadratic programming np-hard in some cases p if  convex   subset sum problem   formal languages and string processing   closest string   longest common subsequence problem   the bounded variant of the post correspondence pro blem   shortest common supersequence   string-to-string correction problem  games and puzzles   battleship   bulls and cows marketed as master mind certain o ptimisation problems but not the game itself    eternity ii   generalized freecell   fillomino   hashiwokakero   heyawake   generalized instant insanity   kakuro cross sums   kuromasu also known as kurodoko   lemmings with a polynomial time limit   light up   masyu   minesweeper consistency problem but see scott  stege  van rooij   nimber or grundy number of a directed graph    numberlink   nonograms   nurikabe   rubik's cube solved optimally   samegame   generalized set    slither link on a variety of grids   generalized sudoku   problems related to tetris   verbal arithmetic   other   art gallery problem and its variations    berth allocation problem   betweenness   assembling an optimal bitcoin block    boolean satisfiability problem sat  there are many variations that are also np-complete  an i mportant variant is where each clause has exactly t hree literals sat since it  is used in the proof of many other np-completeness results    conjunctive boolean query   cyclic ordering   circuit satisfiability problem   uncapacitated facility location problem   flow shop scheduling problem   generalized assignment problem   upward planarity testing   hospitals-and-residents problem with couples   some problems related to job-shop scheduling   monochromatic triangle   minimum maximal independent set a k a  minimum ind ependent dominating set   np-complete special cases include the minimum maxi mal matching problem which is essentially equa l to the edge dominating set problem see above    maximum common subgraph isomorphism problem   minimum degree spanning tree   minimum k-spanning tree   metric k-center   maximum -satisfiability   modal logic s-satisfiability   some problems related to multiprocessor scheduling  maximum volume submatrix  problem of selecting the  best conditioned subset of a larger m x n matrix  this class of problem is associated with rank revea ling qr factorizations  and d optimal experimental design    minimal addition chains for sequences  the com plexity of minimal addition chains for individual n umbers is unknown    non-linear univariate polynomials over gfn n t he length of the input  indeed over any gfqn    open-shop scheduling   pathwidth or equivalently interval thicknes s and vertex separation number   pancake sorting distance problem for strings   k-chinese postman   subgraph isomorphism problem   variations of the steiner tree problem  specifical ly with the discretized euclidean metric rectilin ear metric  the problem is known to be np-hard with the non-discretized  euclidean metric    set packing   serializability of database histories   scheduling to minimize weighted completion time   sparse approximation   block sorting sorting by block moves   second order instantiation   treewidth   testing whether a tree may be represented as eucli dean minimum spanning tree   three-dimensional ising model   vehicle routing problem httpsen   wikipedia   orgwikili  stofnp- complete  problems  point being there are  a lot of them    and the map visitation  problem which is np-complete  isn't even on this list  map visitation problem mvp   so you're at your job and your supervisor tells you to write an  efficient poly-time algo to solve the mvp in the general ca se not  just special cases of it  what do you do multiple choice    use a minimum-spanning tree approach    use an all-pairs shortest paths approach    have a long conversation with your supervisor abo ut wasting better uses of  your time  input integer knumber of robots  weighted undirected graph g  ve map for visitation    depots dv   vkstarting points for each robot  output min-max length of the paths for visiting al l nodes in g  given starting depots d      robots  start here example options  and  won't work but before you  do option  you should know you're right  and np-completeness can help  cs --    managing np-completeness  np-completeness is everywhere how do we deal with it   focus on special cases that we can efficiently solve   a lot of important problems fall into this categor y   can work on approximation algorithms instead of exact solutions   use intractability to your benefit   example cryptography   keep trying to prove p  np   good luck  thanks to httpswww cs princeton eduwaynecs lecturesnp-complete  headlines  coming up on a recap of cs what's the fastest sorting algorithm   is it quicksort   the answer might surprise you or it might not  all the hottest fashion trends for programmers most important  complexity classes for programmers   with essential algos from each one  common myths about recursion debunked   some of the answers here actually might surprise you  how to make an algorithm not just a little faster but a lot faster  could your next problem be np-complete  and how would you know  plus language  nlp applications  a little peek into what a compiler   interpreter does and more this is a lot  thank you for your  work this semester 