cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   grading update   sa returned already   ps grading update    i welcome feedback about grader feedback let's talk   problem set  due oct      see note about break statements please avoid them in cs   please get started early and ask questions early   project  due end of day today   please don't count on my availability for much help by email after i   leave the office this afternoon   another sa may be out soon i'll email if so  cs --     loop invariants a warmup  game description repeated from prev  slide   a problem-solving warmup consider the following game   an odd number of red balls and any number of green balls are put in a bag  an infinite supply   of green balls is available  a move consists of removing two balls from the bag and applying  the following rule if the balls are the same color they are both thrown away and a new green  ball is placed in the bag  if the balls are of different colors the red one is returned to the bag  and the green one is discarded  the game ends when it is no longer possible to pick two  balls from the bag    consider a one-player version where the player can look in the bag before removing  two balls from it         give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is green   give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is red    what useful loop invariant do you have in mind when designing    explaining your algorithm    maybe it involves the odd  even-ness the parity of the number of red or green balls   a loop invariant is something that's true about the variables every time the algo  goes through the loop every time so invariant   but is false once the loop ends in a way that gets to the problem's solution  loop invariants a warmup  game description repeated from prev  slide   a problem-solving warmup consider the following game   an odd number of red balls and any number of green balls are put in a bag  an infinite supply   of green balls is available  a move consists of removing two balls from the bag and applying  the following rule if the balls are the same color they are both thrown away and a new green  ball is placed in the bag  if the balls are of different colors the red one is returned to the bag  and the green one is discarded  the game ends when it is no longer possible to pick two  balls from the bag    consider a one-player version where the player can look in the bag before removing  two balls from it         give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is green   give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is red    what useful loop invariant do you have in mind when designing    explaining your algorithm    maybe it involves the odd  even-ness the parity of the number of red or green balls  loop invariant property every time through the game until there's one ball left  the overall number of balls decreases by  and  the number of red balls remains odd either decreases by  or by   cs --     cs --   loop invariants a warmup  game description repeated from prev  slide   a problem-solving warmup consider the following game   an odd number of red balls and any number of green balls are put in a bag  an infinite supply   of green balls is available  a move consists of removing two balls from the bag and applying  the following rule if the balls are the same color they are both thrown away and a new green  ball is placed in the bag  if the balls are of different colors the red one is returned to the bag  and the green one is discarded  the game ends when it is no longer possible to pick two  balls from the bag    consider a one-player version where the player can look in the bag before removing  two balls from it         give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is green   give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is red    what useful loop invariant do you have in mind when designing    explaining your algorithm    maybe it involves the odd  even-ness the parity of the number of red or green balls  loop invariant property every time through the game until there's one ball left  the overall number of balls decreases by  and  the number of red balls remains odd either decreases by  or by  how does this help you solve the problem    cs --   these are common complexity classes but there are many others  time complexity classes illustrated  what algos do you know in  each complexity class  do you have any favorites  complexity class  what we call it  o  olg n  on  constant  log time  linear  on lg n  n lg n  on  on  on  on  n-squared quadratic  n-cubed cubic  exponential  factorial  these are common complexity classes but there are many others  time complexity classes illustrated  complexity class  what we call it  example algorithms  objects  o  olg n  on  constant  log time  linear  on lg n  n lg n  n-squared quadratic  print hello world stack operations  and much much more be careful  binary search  exhaustive search of an array linear  search merge as used in mergesort  mergesort heapsort recall sorting can be done in n lg n  insertion  selection  bubble sort  several graph algos  on  on  on  on  n-cubed cubic  my favorite algorithm a graph algo  exponential  factorial  number of subsets of a set of size n  number of orderings  permutations of  elements of a list of length n    cs --   the green-shaded ones are examples of polynomial time classes upper bounded by nk for  some constant k  problems solvable in polynomial time are considered tractable  more  about this later in the semester  time complexity classes illustrated  complexity class  what we call it  example algorithms  objects  o  olg n  on  constant  log time  linear  on lg n  n lg n  n-squared quadratic  on  on  on  on  print hello world stack operations  and much much more be careful  binary search  exhaustive search of an array linear  search merge as used in mergesort  mergesort heapsort recall sorting can be done in n lg n  insertion  selection  bubble sort  several graph algos  n-cubed cubic  my favorite algorithm a graph algo  exponential  factorial  number of subsets of a set of size n  number of orderings  permutations of  elements of a list of length n    disclaimer there is no such tour  this is a gratuitous made-up example   but vai and grasso are both great guitar players that part is true  the cs guitar genius tour   guitarists steve vai and pasquale grasso both faves of your   cs prof  are finally going on tour together  there are n possible venues they could play on their tour   they could play any number of them from  to n  steve vai from cover of album inviolate  pasquale grasso  from video for it don't mean a thing  disclaimer there is no such tour  this is a gratuitous made-up example   but vai and grasso are both great guitar players that part is true  the cs guitar genius tour   guitarists steve vai and pasquale grasso both faves of your   cs prof  are finally going on tour together  there are n possible venues they could play on their tour   they could play any number of them from  to n   they have a list ordering of the n venues in mind the order in which it   makes sense to travel to them   so if the ordering is v v  vn from first to last they would never play   vy before vx if y  x  larger numbers are always later in the ordering    but they could skip or play any or all venues  cs --     disclaimer there is no such tour  this is a gratuitous made-up example   but vai and grasso are both great guitar players that part is true  the cs guitar genius tour   guitarists steve vai and pasquale grasso both faves of your   cs prof  are finally going on tour together  there are n possible venues they could play on their tour   they could play any number of them from  to n   they have a list ordering of the n venues in mind the order in which it   makes sense to travel to them   so if the ordering is v v  vn from first to last they would never play   vy before vx if y  x  larger numbers are always later in the ordering    but they could skip or play any or all venues   we want to figure out the best tour itinerary for   them  for now we'll use a brute force method of  checking all possible tour itineraries    how many possible itineraries are there  exhaustive search brute force   one common category of algorithm is called exhaustive   search  as just a couple of examples   find if an element is a member of a collection search problem   find the optimal element in a collection e g  most valuable item   or items to take as prizes optimization problem   find the best way of ordering all elements in a collection e g    best path through a network optimization problem   exhaustive search is a kind of brute force algorithm   design is straightforward   look through all elements in the collection see if they meet   criteria search optimality   cs --     exhaustive search brute force  notes about exhaustive search  brute force algos   applicable to a very wide variety of problems  see levitin  recommended  not required  textbook pg     it may be the only algo design paradigm where it's more difficult to find   problems to which it can't be applied than problems to which it can   for some important problems brute force algos are practical   efficient and commonly used with no limitation on input  linear search matrix multiplication etc    sometimes it's more expensive to design  implement    maintain a clever solution than to just use brute force  depends sometimes on how many times the algo  solution will be run  exhaustive search brute force  notes about exhaustive search  brute force algos   they're often not the most asymptotically efficient   solution we know of  but more times than you'd think they are   more about that later in the semester   because of their straightforward design   they're often easier than other algos to  understand and explain to others   reason about correctness  complexity   maintain  extend  alter   they can be a good first step   something to consider   when you're presenting  a non-brute force algo as  a preferred solution you  might  give reasons that it's  better than brute force   and say how much  better it is e g  by  asymptotic complexity  analysis  to a more efficient solution  more about that later in the semester too  cs --     cs --   exhaustive search brute force   how many subsets are there of a given set s    say for notation s has n elements  vocab the set of all  subsets of s is called  the power set of s   how many orderings or permutations are there of all   elements in a list l  a  an  the power set of a set s  consider set s of size n  how many subsets of s are there  as a small example consider s     n    what are all the  subsets           there are  of them   the set of all subsets of s is called the power set of s     recall the n entry in our table of common complexity classes  exponential time and the power set of a set s   when we think of exponential time or more generally   something of size  length n we often think of all subsets  of a set of size n  consider set s of size n  how many subsets of s are there  as a small example consider s     n    what are all the  subsets           there are  of them   the set of all subsets of s is called the power set of s   exhaustive search brute force   how many subsets are there of a given set s    say for notation s has n elements  vocab the set of all  subsets of s is called  the power set of s   the power set of s has n elements   what does this tell us about the asymptotic complexity of  an exhaustive search algorithm over all subsets of a set  remember exhaustive search implies that it looks at   all elements at least in worst case of a collection   will we describe complexity using big-o  or   cs --     