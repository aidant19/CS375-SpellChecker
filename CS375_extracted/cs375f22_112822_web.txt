 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   sa sa due already   sa out due pm dec     sa involves working through an example of the alg o we covered last  monday   ps due nov     no exercises beyond the lookahead   ps out nov   due dec     ps will be the final ps for the semester there m ay be other sas   ps sa sa grading update   project  out today   due pm monday dec     severe late penalties if turned in during exams i e   after pm dec     intended team size  but talk to me if you'd pre fer to work with a  smaller team size  cs --    all-pairs shortest paths  a vertex-based recursive solution    we're still considering shortest path p from i to j with  intermediate vertices in v k  what's the relationship between p and the set of s hortest paths from i to j  with intermediate vertices in v k-   depends on whether or not vertex k is an intermediate vertex  on path p   if not then p is also a shortest path i to j wi th intermediate vertices in v k-  if so then p can be broken down into sub-paths th at are shortest paths with  intermediate vertices in v k-   one sub-path is from i to k the other is from k to j   altogether if w is the weights matrix and           is the shortest path  value from i to j using only intermediate vertices numbered up to k   k ij d floyd-warshall algorithm  bottom-up all-pairs shortest paths  floyd-warshall algorithm for all-pairs shortest paths the bottom-up  method based on this decomposition   computes matrices d k           where each         is the shortest pa th  value from i to j using only intermediate vertices numbered up to k   what does this algorithm return what makes that a useful return value   what is the running time of this algorithm by the way which one's warshall   k ij d k ij d note this computes  shortest path values  not the paths  see  clrs pages -  about computing the  paths themselves   cs --    a floyd-warshall example   computes matrices dk           where each          is the shortest path value from i to j using only  intermediate vertices numbered up to k   what d matrices does it  compute for this  example graph   k ij d k ij d see clrs  ch     a floyd-warshall example   computes matrices dk           where each          is the shortest path value from i to j using only  intermediate vertices numbered up to k   what d matrices does it  compute for this  example graph   k ij d k ij d  cs --    and now for something completely  different  it's   cs --    change   consider the coin changing problem  given a number  non-negative integer nof cents make exactly that much  change using the smallest number of coins   assuming you have only pennies nickels dimes an d quarters to  work with what would your algorithm be   how would you explain correctness  optimality  and now for something completely different  well not that  kind of change  greedy algorithms greedy-choice  property and optimal substructure   it turns out the coin changing problem can be solved by a  greedy algorithm   choose the best option first keep doing that un til problem is solved   here choose the biggest coin say it has value c that could be  used for ncents change   then repeat that for the n-ccents in the remaining subproblem   for this greedy method to work   optimal substructure an optimal solution with kcoins is composed of  optimal solutions with k-coins for the relevant number of cents  greedy-choice property  by choosing locally the greedy choice first  and continuing this method we get globally an op timal solution actually also that kind of change  this makes sense it basically says if choosing gre edily won't help and optimal solutions  on subproblems won't help then don't use a greedy m ethod  cs --    the trees   a tree sometimes called a free tree  is an acyclic connected undirected  graph   we've seen rooted trees such as  binary trees before but from a more  general graph-oriented perspective trees do not ne ed to have roots   important properties of free trees the below stat ements are all  equivalent for undirected graph g  v e   g is a free tree   any two vertices in g are connected by a unique si mple path   g is connected but if any edge is removed the re sulting graph is disconnected   g is connected and e  v-  g is acyclic and e  v-  g is acyclic but if any edge is added to g the r esulting graph has a cycle a collection of possibly  disconnected trees is  called a forest   really  see clrs sec  b   and b    see also the rush album  hemispheres  which many  people may find even more  dense and inaccessible  than the clrs textbook   cs --    more trees   with rooted trees recall vocabulary   ancestor  descendant   parent  child  sibling   internal node  external node  leaf   depth  height of a node in the tree   given a connected undirected graph g  ve many  subgraphs of g are trees   consider an acyclic subgraph that connects all the  vertices in v   how do we know it's a tree   how many edges must it have  minimum spanning trees msts   given a connected undirected graph g  ve an acyclic  subgraph that connects all the vertices in v is a spanning tree of g   it's a tree and it covers spans all the verti ces of g   for network g represents unique connections  pat hs between each pair of  nodes in g   consider the minimum spanning tree mst problem given weighted  undirected connected graph g find a spanning tree  t with minimal  total weight over all edges in t   cs --    a generic mst algorithm  minimum spanning trees can be grown one edge at a time   some vocabulary   a cut sv-s of an undirected graph gve is a partiti on of v   an edge uv crosses a cut if u is in s and v is in v-s  a cut respects a set of edges if no edge in the set crosses the cu t   a light edge is a minimum-weight edge satisfying a property e g    a light edge that crosses a cut in the not too distant future  -- mst k  how can this vocab be used to  describe an mst algorithm safe here means an edge that  can be added without  violating the property that a  is a subgraph of an mst   digression how do we argue  correctness of the algorithm  greedy mst algorithms   greedy strategy for building msts add the best edge from  edge set e of graph g repeat until an mst is built   overall structure turn a forest some trees have only  node into a  tree by adding light edges connecting separate comp onents   question what is the best edge the greedy choice to add   a possibility pick the least-weight edge from e t hat connects two  separate components   possibly results in multiple trees growing        in the forest but all will be connected by the end  of the algorithm   i e  maintains a disjoint set of sub-trees invariant all subgraphs are  trees  how do we know 