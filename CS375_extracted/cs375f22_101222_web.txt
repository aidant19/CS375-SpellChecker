cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   thank you to those who participated last wednesday   i'll look over feedback and have a few words to say on monday   grading update   ps update grades probably returned by end of day friday   project started grades probably not returned until weekend    please let me know if you'd like feedback sooner   coming soon as cs assignments   sa likely out today due monday   ps out soon likely due date oct     proj out soon likely due date in early november   revisions on sa where applicable   this is foundational material   please get to them soon to help with learning for the course  cs --     factorial-ish all permutations   write an algo to generate all permutations of an input list l   what are its input  output specifications   how does your algo solve the problem  what loop invariant would be helpful to clarify  explain your algorithm design   what is its time  space complexity  this was your smaller assignment due by the beginning of today's class   what loop invariant did you use  let's look at some invariants and then use one of them to develop an   algo  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  cs --     factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl psl       note relation to invariant below  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl psl       note relation to invariant below  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  a sequence from a bigger  number to a smaller number  like s     s- is considered  empty containing no elements  cs --     factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl psl       note relation to invariant below  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-  psl  temppsl  what's the length of psl after this operation  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl psl       note relation to invariant below  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-   loop over all possible places to put si in pslj including before the first or after the last  psl  temppsl  what's the length of psl after this operation  cs --     factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl psl       note relation to invariant below  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-   loop over all possible places to put si in pslj including before the first or after the last for k   to lenpslj  temps  deepcopypsl j   insert si into temps at position k    note position lenpslj is after last elt of pslj add temps to list temppsl   why deepcopy  psl  temppsl  what's the length of psl after this operation  when si is  added it could  be before the  first element in  a previously  formed list or  after the last  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl psl       note relation to invariant below  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l  let's go  through a  small  example  how does  this algo work on  s   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-   loop over all possible places to put si in pslj including before the first or after the last for k   to lenpslj  temps  deepcopypsl j   insert si into temps at position k    note position lenpslj is after last elt of pslj add temps to list temppsl   why deepcopy  psl  temppsl  what's the length of psl after this operation  cs --     cs --   factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl psl       note relation to invariant below  what is the  space  complexity  of this algo  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-   loop over all possible places to put si in pslj including before the first or after the last for k   to lenpslj  temps  deepcopypsl j   insert si into temps at position k    note position lenpslj is after last elt of pslj add temps to list temppsl   why deepcopy  psl  temppsl  what's the length of psl after this operation  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   what is the  space  complexity  of this algo  how much  space is  used at the  end nn  it is beyond  the scope of  cs to get a  theta bound  generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl psl       note relation to invariant below  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-   loop over all possible places to put si in pslj including before the first or after the last for k   to lenpslj  temps  deepcopypsl j   insert si into temps at position k    note position lenpslj is after last elt of pslj add temps to list temppsl   why deepcopy  psl  temppsl  what's the length of psl after this operation    cs --   factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that   what is its time  space complexity  generate-all-permutationsl  n  lenl psl       note relation to invariant below  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l  what is the  time  complexity  of this algo  at least nn because it  takes at least  one unit of  time to  access each  unit of space  it is beyond  the scope of  cs to get a  theta bound   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-   loop over all possible places to put si in pslj including before the first or after the last for k   to lenpslj  temps  deepcopypsl j   insert si into temps at position k    note position lenpslj is after last elt of pslj add temps to list temppsl   why deepcopy  psl  temppsl  what's the length of psl after this operation  using loop invariants in   algorithm design and explanations   loop invariants state properties known to be true for each iteration of a loop   can think of it as a property known to be true immediately before and   immediately after each iteration    in our examples we've understood loop invariants in terms of before and  after conditions   before what is helpful and known to be true before a given iteration of the loop   after what is helpful and known to be true after a given iteration of the loop   which establishes the truth of the before condition before the next iteration  example the generate permutations algo from the previous slide  invariant outer loop     psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si    cs --   using loop invariants in   algorithm design and explanations   loop invariants state properties known to be true for each iteration of a loop   can think of it as a property known to be true immediately before and   immediately after each iteration    in our examples we've understood loop invariants in terms of before and  after conditions   before what is helpful and known to be true before a given iteration of the loop   after what is helpful and known to be true after a given iteration of the loop   which establishes the truth of the before condition before the next iteration   you don't need to write down before  after conditions unless a cs   assignment requires it but it can be helpful   key point loop invariant gives a property that's true after the loop is   finished that helps explain algo correctness  example let's use the invariant to help explain the correctness of our generate  permutations algo  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that  generate-all-permutationsl  n  lenl psl       note relation to invariant  how does the  invariant help  explain  correctness  that the algo meets its  specifications  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-   loop over all possible places to put si in pslj including before the first or after the last for k   to lenpslj  temps  deepcopypsl j   insert si into temps at position k    note position lenpslj is after last elt of pslj add temps to list temppsl   why deepcopy  psl  temppsl  what's the length of psl after this operation    cs --   factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   the invariant  shows that  after the last  iteration when  i  n psl  contains all  permutations of  all elts in l  generate all permutations of l  let's write an algo that does that  generate-all-permutationsl  n  lenl psl       note relation to invariant  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-   loop over all possible places to put si in pslj including before the first or after the last for k   to lenpslj  temps  deepcopypsl j   insert si into temps at position k    note position lenpslj is after last elt of pslj add temps to list temppsl   why deepcopy  psl  temppsl  what's the length of psl after this operation  factorial-ish generate all permutations   to search through all permutations of a list l something first needs to   generate all permutations of l  let's write an algo that does that  generate-all-permutationsl  n  lenl psl       note relation to invariant  generate-all-permutationsl  input l a list of n elements    l  ssssn-   output psl a list of all permutations    of input list l that is all the lists     resulting from all possible orderings     of all elements in input l  the invariant  shows that  after the last  iteration when  i  n psl  contains all  permutations of  all elts in l   and that's  exactly what  the  specifications  say is needed  so if the  invariant  always holds  the algo is  correct   invariant outer loop    psl contains all permutations formed from elts s  si-      that is before index i psl contains all permutations formed from elts s  si-    and after index i psl contains all permutations formed from elts s  si for i   to n-  temppsl     empty list will store permutations containing si m  lenpsl  inner loop loops over psl create new permutations containing si for j   to m-   loop over all possible places to put si in pslj including before the first or after the last for k   to lenpslj  temps  deepcopypsl j   insert si into temps at position k    note position lenpslj is after last elt of pslj add temps to list temppsl   why deepcopy  psl  temppsl  what's the length of psl after this operation    cs --   exponential-ish generate all subsets   to search through all subsets of a set s something first needs to   generate all subsets of s  let's write an algo that does that   what is its time  space complexity  generate-all-subsetss  n  lens l       note relation to invariant below  what is the  time  space complexity  of this algo  what can  you give as a  lower bound   bound  generate-all-subsetss  input s a set of n elements    s  ssssn-    probably implemented as a list     but with no repeated elements so     it can be treated as a set by     ignoring the elements' ordering  output l a set of all subsets of s   invariant outer loop    l contains all subsets formed from elts s  si-     before index i l contains all subsets formed from elts s  si-    after index i l contains all subsets formed from elts s  si for i   to n-  templ     empty list will store subsets containing si m  lenl  inner loop loops over l create new subsets containing si for j   to m-  temps  deepcopyl j    why deepcopy add si to temps add temps to list templ   what's the length of templ here when it's fully filled in add all of templ to l     what's the length of l after this operation    cs --   exponential-ish generate all subsets   to search through all subsets of a set s something first needs to   what is the  time  space complexity  of this algo  lower bound  of  nn  it is beyond  the scope of  cs to get a  theta bound  generate all subsets of s  let's write an algo that does that   what is its time  space complexity  generate-all-subsetss  n  lens l       note relation to invariant below  generate-all-subsetss  input s a set of n elements    s  ssssn-    probably implemented as a list     but with no repeated elements so     it can be treated as a set by     ignoring the elements' ordering  output l a set of all subsets of s   invariant outer loop    l contains all subsets formed from elts s  si-     before index i l contains all subsets formed from elts s  si-    after index i l contains all subsets formed from elts s  si for i   to n-  templ     empty list will store subsets containing si m  lenl  inner loop loops over l create new subsets containing si for j   to m-  temps  deepcopyl j    why deepcopy add si to temps add temps to list templ   what's the length of templ here when it's fully filled in add all of templ to l     what's the length of l after this operation  exponential-ish generate all subsets   to search through all subsets of a set s something first needs to   generate all subsets of s  let's write an algo that does that   what is its time  space complexity  generate-all-subsetss  n  lens l       note relation to invariant below  generate-all-subsetss  input s a set of n elements    s  ssssn-    probably implemented as a list     but with no repeated elements so     it can be treated as a set by     ignoring the elements' ordering  output l a set of all subsets of s  how does the  invariant help  explain  correctness  that the algo meets its  specifications  hint it's very  similar to what  we just did for  the permutations  algorithm   invariant outer loop    l contains all subsets formed from elts s  si-     before index i l contains all subsets formed from elts s  si-    after index i l contains all subsets formed from elts s  si for i   to n-  templ     empty list will store subsets containing si m  lenl  inner loop loops over l create new subsets containing si for j   to m-  temps  deepcopyl j    why deepcopy add si to temps add temps to list templ   what's the length of templ here when it's fully filled in add all of templ to l     what's the length of l after this operation    using loop invariants in   algorithm design and explanations   loop invariants state properties known to be true for each iteration of a loop   can think of it as a property known to be true immediately before and   immediately after each iteration    in our examples we've understood loop invariants in terms of before and  after conditions   before what is helpful and known to be true before a given iteration of the loop   after what is helpful and known to be true after a given iteration of the loop   which establishes the truth of the before condition before the next iteration   key point loop invariant gives a property that's true after the loop is   finished that helps explain algo correctness  to informally use loop invariants to help explain algo correctness  explain how the invariant is true before the first iteration of the loop  explain how the invariant is true after each following iteration  explain how the invariant property shows that the algo meets its   specifications  a logical digression  logical reasoning about empty stuff   how does it work if we're asked if something is true for all elements of an   empty structure   examples   say l is a list of strings and l is empty  is it true that every string on the list   has length greater than    say s is a set of numbers and s is empty  is it true that every number in s is   equal to   brace yourselves until you get used to them you may not like  the answers to these questions  cs --     a logical digression  logical reasoning about empty stuff   how does it work if we're asked if something is true for all elements of an   empty structure   examples   say l is a list of strings and l is empty  is it true that every string on the list   has length greater than    say s is a set of numbers and s is empty  is it true that every number in s is   equal to    the answer to these questions is yes it is true  we say it is vacuously true    part of the way propositional logic works is that when we ask if some   property is true of every element in some empty structure     the answer is always yes because there are no elements to reason   about we can vacuously say anything is true of anything in that empty set  this follows from the same idea that once it is shown that false  true  the system is incoherent so we can say anything is true in that system  a logical digression  vacuous truth   how does it work if we're asked if something is true for all elements of an   empty structure   more examples   say l is a list of numbers and l is empty  is it true that l is in sorted order    say l is a list of numbers and l is empty  is it true that l is out of sorted   order    the answer to these questions is yes they are vacuously true  this can be useful as part of using loop invariants especially when showing  a property is true in some boundary case either before the first iteration of  a loop or after the last iteration of a loop  it's completely understandable if you're not feeling totally happy about this dealing  with logical incoherence is tricky  it turns out though this convention of vacuous truth can be really useful and it  gets very intuitive after a while  cs --     cs --   example of reasoning with vacuous truth  loop invariants and bubble sort      yes bubble sort is the actual name of this sorting algorithm  in pseudocode  what's the time complexity of this algorithm  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-   do you understand how the algo works try it on a   how do we use loop invariants to show correctness i e  that   it sorts a in non-decreasing order   example of reasoning with vacuous truth loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b   use invariant to show correctness    show invariant is true before first loop iteration how    show pseudocode ensures invariant is true after each successive iteration   assuming that it's true at the start of the iteration how    show when loop is done algorithm meets specifications how    cs --   example of reasoning with vacuous truth loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b   use invariant to show correctness    show invariant is true before first loop iteration how   before the first iteration i is set to   for the invariant we look at a  i-  a     by convention a   is an empty array    so it vacuously contains the i- smallest values of a in sorted order  example of reasoning with vacuous truth loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b   use invariant to show correctness  super important note show that the entire invariant is true not just part of it  a   vacuously contains the i- smallest values of a in sorted order   we still need to explain how a  n consists of the remaining values of a no   constraint on order but that's not that difficult    cs --   explaining correctness  loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta     for i          to a length    for j  a length downto i  if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b   use invariant to show correctness    show invariant is true before first loop iteration done    show pseudocode ensures invariant is true after each successive iteration   assuming that it's true at the start of the iteration how    show when loop is done algorithm meets specifications how  explaining correctness step   loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b    show pseudocode ensures invariant is true after each successive iteration   assuming that it's true at the start of the iteration   there are many right ways to do this step it's all about explaining how the algo works  refer directly to the pseudocode in your explanation citing specific lines of pseudocode  doing this step will be part of a smaller assignment due next monday    cs --   explaining correctness step   loop invariants and bubble sort on   loop invariant for outer loop  subarray a  i- consists of the i- smallest values of  a in sorted order and ai  n consists of the remaining  values of a no constraint on order  sorting problem  input sequence of   numbers a  an  bubblesorta   for j  a length downto i    for i    to a length          if aj  aj-  swap aj with aj-  output permutation  reordering b   bn of the input  sequence perhaps  leaving them  unchanged such  that b      bn   b    show when loop is done algorithm meets specifications   there are many right ways to do this step too  refer directly to the invariant property and to the specifications in your explanation   referring to specifications is essential for showing algo correctness   doing this step will also be part of a smaller assignment due next monday  algorithm correctness and loop invariants   a recap  see clrs     to explain correctness of iterative algos look at the loop   loop invariants can help three steps to using loop invariants    show the invariant is true before the first iteration    show the invariant stays true after each successive iteration   assuming it was true before that iteration    show the algo meets specifications using what the invariant says is   true after the loop is done  these three steps correspond to three parts mentioned in our clrs textbook     maintenance if a property is true before an iteration it is true after that iteration  before the next   initialization property is true before the first iteration  iteration    termination when the loop terminates the property is useful in showing algorithm correctness you do not need to use these three terms from clrs for cs when discussing invariants although  you can if you want to i just wanted to connect our approach in this slides to our textbook    