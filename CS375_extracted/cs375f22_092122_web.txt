cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   practice with graphs and   asymptotic complexity notation   consider a graph g  ve with n nodes i e  vn     how many edges might it have in edge set e    what can we say about its number of edges using asymptotic   complexity notation o    cs --     practice with graphs and   asymptotic complexity notation   consider a graph g  ve with n nodes i e  vn     how many edges might it have in edge set e    what can we say about its number of edges using asymptotic   complexity notation o    any edge has the form vi vj where both vi vj are in v   how many possible edges could there be they may not all  be in e we're just seeing what's possible  there are n possible choices for vi  n possible vertices  nodes similarly for each of those n choices there are n choices for vj  so there are nn  n possible pairs that is n possible edges   try it where g has   nodes we see   possible edges  including self-loops  from a node to itself  in asymptotic complexity notation then there are  edges  what can we say here  practice with graphs and   asymptotic complexity notation   consider a graph g  ve with n nodes i e  vn     how many edges might it have in edge set e    what can we say about its number of edges using asymptotic   complexity notation o    any edge has the form vi vj where both vi vj are in v   how many possible edges could there be they may not all  be in e we're just seeing what's possible  there are n possible choices for vi  n possible vertices  nodes similarly for each of those n choices there are n choices for vj  so there are nn  n possible pairs that is n possible edges   try it where g has   nodes we see   possible edges  including self-loops  from a node to itself  in asymptotic complexity notation then there are on edges   we cannot make any statement using  or  notation we only have enough  information for an upper bound  cs --     cs --     business   grading update   sa grading not before the weekend    another sa may be out soon i'll email if so   problem set  due already    ps out soon perhaps tonight or perhaps friday   i'll email when it's out   but you have things to work on in the meantime such as   project  due sept     please direct project-specific questions to me rather than to tas   questions about general concepts that show up on the project e g    theta notation though rather than specifics can go to tas  business pt     class will be cancelled monday sept     will be an optional make-up class later in the semester   general grading notes   if we leave a note see prof  if you'd like it's recommended   if we leave a note see prof  please see me i think it's important    if you come to office hours please let me know you're there  even if i'm with another student please say hi and let me know   it gives me info so i can multitask efficiently and help more people  a tiny bit about the course the remix   some main ideas   recall important elements for any course on algorithms   classic algorithms which you might use or adapt for your work   algorithm design techniques and paradigms   creating and working with algorithm specifications   analyzing and explaining an algorithm's correctness   analyzing and explaining an algorithm's complexity   we'll spend a lot of the semester on these important elements  design  paradigm  analysis  complexity efficiency  correctness  counting  iterative  counting number of operations    loop invariants  amount of space used  recursive  solving recurrences  induction  cs --     problem-solving warmup   a problem-solving warmup consider the following game   an odd number of red balls and any number of green balls are put in a   bag  an infinite supply of green balls is available  a move consists of  removing two balls from the bag and applying the following rule if the  balls are the same color they are both thrown away and a new green  ball is placed in the bag  if the balls are of different colors the red one  is returned to the bag and the green one is discarded  the game ends  when it is no longer possible to pick two balls from the bag    consider a one-player version where the player can look in the bag   before removing two balls from it     give a method strategy  algorithm so that when the game is over   there is one ball left in the bag and it is green   problem-solving warmup   a problem-solving warmup consider the following game   an odd number of red balls and any number of green balls are put in a   bag  an infinite supply of green balls is available  a move consists of  removing two balls from the bag and applying the following rule if the  balls are the same color they are both thrown away and a new green  ball is placed in the bag  if the balls are of different colors the red one  is returned to the bag and the green one is discarded  the game ends  when it is no longer possible to pick two balls from the bag    consider a one-player version where the player can look in the bag   before removing two balls from it     give a method strategy  algorithm so that when the game is over   there is one ball left in the bag and it is green     give a method strategy  algorithm so that when the game is over   there is one ball left in the bag and it is red   cs --     loop invariants a warmup  game description repeated from prev  slide   a problem-solving warmup consider the following game   an odd number of red balls and any number of green balls are put in a bag  an infinite supply   of green balls is available  a move consists of removing two balls from the bag and applying  the following rule if the balls are the same color they are both thrown away and a new green  ball is placed in the bag  if the balls are of different colors the red one is returned to the bag  and the green one is discarded  the game ends when it is no longer possible to pick two  balls from the bag    consider a one-player version where the player can look in the bag before removing  two balls from it         give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is green   give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is red    what useful loop invariant do you have in mind when designing    explaining your algorithm    maybe it involves the odd  even-ness the parity of the number of red or green balls   a loop invariant is something that's true about the variables every time the algo  goes through the loop every time so invariant   but is false once the loop ends in a way that gets to the problem's solution  loop invariants a warmup  game description repeated from prev  slide   a problem-solving warmup consider the following game   an odd number of red balls and any number of green balls are put in a bag  an infinite supply   of green balls is available  a move consists of removing two balls from the bag and applying  the following rule if the balls are the same color they are both thrown away and a new green  ball is placed in the bag  if the balls are of different colors the red one is returned to the bag  and the green one is discarded  the game ends when it is no longer possible to pick two  balls from the bag    consider a one-player version where the player can look in the bag before removing  two balls from it         give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is green   give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is red    what useful loop invariant do you have in mind when designing    explaining your algorithm    maybe it involves the odd  even-ness the parity of the number of red or green balls  loop invariant property every time through the game until there's one ball left  the overall number of balls decreases by  and  the number of red balls remains odd either decreases by  or by   cs --     cs --   loop invariants a warmup  game description repeated from prev  slide   a problem-solving warmup consider the following game   an odd number of red balls and any number of green balls are put in a bag  an infinite supply   of green balls is available  a move consists of removing two balls from the bag and applying  the following rule if the balls are the same color they are both thrown away and a new green  ball is placed in the bag  if the balls are of different colors the red one is returned to the bag  and the green one is discarded  the game ends when it is no longer possible to pick two  balls from the bag    consider a one-player version where the player can look in the bag before removing  two balls from it         give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is green   give a method strategy  algorithm so that when the game is over there is one ball left in the bag  and it is red    what useful loop invariant do you have in mind when designing    explaining your algorithm    maybe it involves the odd  even-ness the parity of the number of red or green balls  loop invariant property every time through the game until there's one ball left  the overall number of balls decreases by  and  the number of red balls remains odd either decreases by  or by  how does this help you solve the problem    log it  questions about exponents   when solving equations we may want to know the value of   an exponent  e g  in equation x we might want to ask what value of x makes   that true   how does this come up in analyzing algorithm complexity   imagine an algo that takes input of size n and then goes through a loop or  recursion getting rid of half the remaining input each time until there's only  left   how many iterations until input of size   input of size n on iteration  n on iteration  n on iteration    on iteration k input is of size nk do you see that pattern   so how many iterations until it reaches   log it  questions about exponents   when solving equations we may want to know the value of   an exponent  e g  in equation x we might want to ask what value of x makes   that true   how does this come up in analyzing algorithm complexity   imagine an algo that takes input of size n and then goes through a loop or  recursion getting rid of half the remaining input each time until there's only  left   how many iterations until input of size   input of size n on iteration  n on iteration  n on iteration    on iteration k input is of size nk do you see that pattern  so reaches   nn on iteration k when nk   so how many iterations until it reaches   cs --     log it  questions about exponents   when solving equations we may want to know the value of   an exponent  e g  in equation x we might want to ask what value of x makes   that true   how could we even phrase that question  recall one of our cs pro tips if you want to talk about something give yourself a word  name for it  e g  declaring a variable rather than recomputing something repeatedly  so this question what's the exponent is something we want to ask repeatedly  we need to have a word  function for it  log it  questions about exponents   when solving equations we may want to know the value of   an exponent  e g  in equation x we might want to ask what value of x makes   that true   how could we even phrase that question   the logarithm function lets us ask the question   so for x   we'd say x  log  read as log base  of   examples log    log    log      logarithms are exponents so rules of exponentiation apply   e g  logb mn  logb m  logb n  if bx  m and by  n  then bxby  bxy  mn  cs --     log it  getting back to where we left  off a couple of slides ago  questions about exponents   when solving equations we may want to know the value of   an exponent  e g  in equation x we might want to ask what value of x makes   that true  notation x  log   how does this come up in analyzing algorithm complexity   imagine an algo that takes input of size n and then goes through a loop or  recursion getting rid of half the remaining input each time until there's only  left   how many iterations until input of size   input of size n on iteration  n on iteration  n on iteration    on iteration k input is of size nk do you see that pattern  so reaches   nn on iteration k when nk   so how many iterations until it reaches   log it  getting back to where we left  off a couple of slides ago  questions about exponents   when solving equations we may want to know the value of   an exponent  e g  in equation x we might want to ask what value of x makes   that true  notation x  log   how does this come up in analyzing algorithm complexity   imagine an algo that takes input of size n and then goes through a loop or  recursion getting rid of half the remaining input each time until there's only  left   how many iterations until input of size   input of size n on iteration  n on iteration  n on iteration    on iteration k input is of size nk do you see that pattern  so reaches   nn on iteration k when nk   so how many iterations until it reaches   log n   notation  this is not  log n  cs --     log it  getting back to where we left  off a couple of slides ago  questions about exponents   when solving equations we may want to know the value of   an exponent  e g  in equation x we might want to ask what value of x makes   that true  notation x  log   how does this come up in analyzing algorithm complexity   imagine an algo that takes input of size n and then goes through a loop or  recursion getting rid of half the remaining input each time until there's only  left   how many iterations until input of size   input of size n on iteration  n on iteration  n on iteration    on iteration k input is of size nk do you see that pattern  so reaches   nn on iteration k when nk   so how many iterations until it reaches   log n    watch for off-by-one errors  log it  questions about exponents   when solving equations we may want to know the value of   an exponent  e g  in equation x we might want to ask what value of x makes   that true  notation x  log   how does this come up in analyzing algorithm complexity   imagine an algo that takes input of size n and then goes through a loop or  recursion getting rid of half the remaining input each time until there's only  left   how many iterations until input of size   input of size n on iteration  n on iteration  n on iteration    on iteration k input is of size nk do you see that pattern  so reaches   nn on iteration k when nk  that is log n   iterations watch for off-by-one errors   can you think of an algo that works like this on its input  cs --     cs --   log it  questions about exponents   when solving equations we may want to know the value of   an exponent  e g  in equation x we might want to ask what value of x makes   that true  notation x  log   how does this come up in analyzing algorithm complexity   imagine an algo that takes input of size n and then goes through a loop or  recursion getting rid of half the remaining input each time until there's only  left   how many iterations until input of size   input of size n on iteration  n on iteration  n on iteration    on iteration k input is of size nk do you see that pattern  so reaches   nn on iteration k when nk  that is log n   iterations watch for off-by-one errors  exercise if input size was n n n   then how many iterations until input size     cs --   these are common complexity classes but there are many others  time complexity classes illustrated  what algos do you know in  each complexity class  do you have any favorites  complexity class  what we call it  o  olg n  on  constant  log time  linear  on lg n  n lg n  on  on  on  on  n-squared quadratic  n-cubed cubic  exponential  factorial  these are common complexity classes but there are many others  time complexity classes illustrated  complexity class  what we call it  example algorithms  objects  o  olg n  on  constant  log time  linear  on lg n  n lg n  n-squared quadratic  print hello world stack operations  and much much more be careful  binary search  exhaustive search of an array linear  search merge as used in mergesort  mergesort heapsort recall sorting can be done in n lg n  insertion  selection  bubble sort  several graph algos  on  on  on  on  n-cubed cubic  my favorite algorithm a graph algo  exponential  factorial  number of subsets of a set of size n  number of orderings  permutations of  elements of a list of length n    