CS   CS   Analysis of Algorithms Professor Eric Aaron Lecture  M W pm Lecture Meeting Location Davis  Business  SA SA due already  Full PS out due Nov   No exercises beyond the Lookahead  Small modification to Late Problem Set Policy from Syllabus  If you have  PSs submitted more than  week late  any additional PSs submitted more than  week late will be a  deduc tion  Please turn in PS and PS on time  Project  out due pm Monday Nov   PS grading update  Project   Will be out next Monday Nov   Will be due no sooner than  weeks after that  Intended team size  but talk to me if youd pre fer to work with a smaller team size CS   For the Most Part The efficient Fibonacci methods used a characteristic technique of dynamic programming  Results stored in a table or similar used to im prove efficiency  Dynamic programming solutions can be either topdown or bottomup  But most of the time in practice when people tal k about a dynamic programming solution they mean a bottomup solutio n  In general when looking for a dynamic programming solution  Try recursive topdown approach with overlapping subproblems  Consider a memoized version  Then try bottomup iterative approach based on s ubproblems  Then try to improve on space complexity of botto mup method For the Most  Part   Dynamic programming is often applied to optimization problems  to find a solution with an optimal minimal or maximal value Often for optimization problems it is or seems  necessary to consider all subsets of a set   so if were looking at a set of size n whats the time complexity of such an algorithm  Characteristic structure for dynamic programming a lgorithms  Overlapping subproblems as previously seen Optimal substructure  an optimal solution is built from the optimal sol utions of subproblems  Steps in developing a dynamic programming algorith m  Characterize the structure of an optimal solution  in words  Recursively define the value of an optimal soluti on  Compute the value of an optimal solution from the bottom up  Construct an optimal solution from computed information These are on CLRS pg  Well focus on steps  and  leading to step  This makes total sense if you think about it for a while If there isnt redundant work in the algo or if optimal solutions arent based on o ptimal solutions to subproblems then why would we store solutions to subproblemsCS   Bottomup Computation of Optimal LCS Value  Need mbyn matrix C to store lengths  To compute Cij need values of Cij when  x i yj and Ci j and Ci j when x iyjLCSX Y  input sequences X Y   m  lengthX   n  lengthY   for i   to m do  Ci       in first col of each row   for j   to n  do  C j     in first row of each col   for i   to m do       for j   to n do     process row by row            if xi yjthen Ci j  Ci j              else Ci j  max Ci j Ci j   return Cm n What is the optimal lengththe length of an LCS of full sequences  X and Y What is the time complexity of this algorithm Actually mbyn to include the  case too Recall our recursive definition    Base case Cj   and Ci   for all i j Recursive  step to compute Cij for ij    If xi yj Cij  Cij   If xi  yj Cij  maxCij Cij CS   Bottomup Computation of An Optimal LCS  To find an LCS also store which symbols indices of symbols are actually part of the LCS as its being built  ie  which table elements have optimal subprobl em values  if x i y j  answer came from the upper left diagonal of curr ent element  if x iyjthe answer came from above or to the left whicheve r is larger if equal we can choose above by convention LCSX Y   m  lengthX   n  lengthY   for i   to m do  Ci     for j   to n  do  C j    for i   to m do       for j   to n do  if xi y j then Ci j  Ci j    Bi j  UpLeft      else  if Ci   j   Ci j   then  Ci j  Ci   j             Bi j  Up one less elt of X  else Ci  j  Ci j    Bi j  Left one less elt of Y ie one less elt of both X and Y ie  either X or Y  LCS example LCS of X  ABCBDAB and Y  BDCABA The algorithm finds an LCS BCBA Are there others CS   And finallyFinding a Solution from the Values  That bottomup method gives us the information from which we can get an optimal value and the associated indices  To actually find  print the longest common subsequence start at the bottomleft of the table and follow the arrows Print LCS BXij  if i   or j   then return   if Bij  UpLeft        then PrintLCSBXij                 print x i  else if Bij  Up        then PrintLCSBXij   else PrintLCSBXij Initial call has i  m ie lengthX j  n lengthY   B is the arrow table from the previous slide CS   Graphs  Graphs commonly represent connections among relate d elements  An undirected graph G  VE is  A set V of vertices nodes and  A set E of edges linked pairs of nodes                                                   which are bidirectional  A directed graph or digraph  G  VE is  A set V of vertices nodes and  A set E of unidirectional edges typically represe nted as arrows Note that selfloopsedges from a node to itselfare possible  Convention For algorithm analysis we may use V f or V and E for E See Sec B a Directed  graph b Undirected graph So in undirected graphs edges are unordered pairs of vertices whereas in digraphs edges are ordered pairs By convention in an undirected graph G  VE we consider uv and vu to be the same edge so at most one of those pairs will be in E More Graph Vocabulary  Graphs with the same number of vertices can have d ifferent numbers of edges Whats the most edges a graph can have i n terms of V  A sparse graph is one in which E is much less than V  A dense graph is one in which E is close to V  In a digraph a path v  v   v k forms a cycle if  v  v kand the path contains at least one edge  A cycle is simple if v  v   v kare distinct  A directed graph with no cycles is a directed acyclic graph  or DAG a b cdfeg hSo we can talk about more graphs See CLRS pg  Why not include v in this CS   Adjacency List Representations  A graph can be represented as an adjacency list  For each vertex v theres a list of all nodes adj acent to v  Represented as an array of V  n lists  Complexity  Storage space OV  E  For what kinds of graphs is this an efficient sto rage representation  Whats the time complexity to find if an edge is i n a graph a b cd efabcdef e dc fa fb ea cb dExample  An undirected graph Read CLRS Sec  Adjacency List Representations  A graph can be represented as an adjacency list  For each vertex v theres a list of all nodes adj acent to v  Represented as an array of V  n lists a b cd efabcdef e dab eaExample a digraph For digraphs only outgoing edges are in E thus in the lists CS   Graphs Adjacency Matrix Representations  A graph can be represented as an adjacency matrix  A VbyV matrix  For each pair ij of vertices  entry ij in the matrix is  if ij in E and  otherwise  Complexity  Storage space OV  Whats the time complexity to find if an edge is i n a graph There is no spoon next to anything  from The Adjacency Matrix a b cd eg f                                          abcdefga  b  c   d  e  f  g Example An undirected graph For directed graphs only outgoing edges are in E  thus in the matrix Weighted Graphs and Shortest Paths  Graphs can be weighted  Given GVE there is a weight function wthat maps each edge in E to a realvalued weight  For weighted graphs an adjacency matrix can store  the weight of an edge in E rather than just  or   Given such a w we say the weight of a path wp for p  v  v   vk is the sum of the weights of the edges on that pa th ie v  v  v  v   v k v k  We then say the shortest path weight uv from vertex u to vertex v is the least weight of any path in G from u to v  A shortest path from u to v is any path from u to v in G with that weight Weighted Graphs and Shortest Paths could be the a lbum title for a collaboration between xkcd and Death Cab For Cutie Well it could be CS   Shortest Path Problems  Kinds of graph problems based on finding shortest paths by convention presume weighted directed graphs  Singlesource shortest paths  Various algorithms for cases of it eg Dijkstra  Singledestination shortest paths  If we have a singlesource shortest paths algorithm how could we solve this  Singlepair shortest path  How does this relate to the singlesource variantAllpairs shortest paths Well talk more about this soon  Note To represent a shortest path in solving s uch a problem each vertex is presumed to have a predecessor field which stor es its predecessor on the path being considered Properties of Shortest Paths  Optimal substructure of shortest paths  Is each subpath of a shortest path itself a short est path  Whats the argument for  counterargument to that   Can a shortest path in a weighted graph have a cycle  Be sure to consider graphs with negative edges w hich could have negative weight cycles as well as graphs with posi tive weight cycles CS   AllPairs Shortest Paths  The AllPairs Shortest Paths Problem  Given weighted graph GV E with no negative we ight cycles find the shortest path from u to v for every u v  in V  Solutions can be based on dynamic programming and an adjacency matrix representation of G  Recall Adjacency matrix W contains weight of each  edge in E  By convention diagonal of  W is all s  How might we break this down into subproblems for a recursive solution AllPairs Shortest Paths A VertexBased Recursive Solution  Solve allpairs shortest path problem in terms of the intermediate vertices that can appear on any shortest path Intermediate vertex of a simple path p  v  v   vz is any vertex on p other than v or vz For graph G call vertices V    n and consi der subsets Vk    k of V  Then for any two vertices i j in V consider all  paths from i to j with intermediate vertices drawn only from Vk In particular consider  a shortest path p from i t o j with intermediate vertices in Vk Whats the relationship between p and the set of shortest paths from i to j with intermediate vertice s in V kAlso is p a simple path How do we know one way o r another A simple path is a path with all distinct vertices CS   AllPairs Shortest Paths A VertexBased Recursive Solution   Were still considering shortest path p from i to j with intermediate vertices in V k Whats the relationship between p and the set of s hortest paths from i to j with intermediate vertices in V k  Depends on whether or not vertex k is an intermediate vertex on path p  If not then p is also a shortest path i to j wi th intermediate vertices in V k If so then p can be broken down into subpaths th at are shortest paths with intermediate vertices in V k  one subpath is from i to k the other is from k to j  Given this how could we recursively define the sh ortest path lengths between all pairs of vertices How do we know we can decompose p that way ie t hat both subpaths are shortest paths using only vertices numbe red up to k AllPairs Shortest Paths A VertexBased Recursive Solution   Were still considering shortest path p from i to j with intermediate vertices in V k Whats the relationship between p and the set of s hortest paths from i to j with intermediate vertices in V k  Depends on whether or not vertex k is an intermediate vertex on path p  If not then p is also a shortest path i to j wi th intermediate vertices in V k If so then p can be broken down into subpaths th at are shortest paths with intermediate vertices in V k  one subpath is from i to k the other is from k to j  Altogether if W is the weights matrix and           is the shortest path value from i to j using only intermediate vertices numbered up to k  kij dCS   FloydWarshall Algorithm Bottomup AllPairs Shortest Paths FloydWarshall algorithm for allpairs shortest paths the bottomup method based on this decomposition  Computes matrices D k           where each         is the shortest pa th value from i to j using only intermediate vertices numbered up to k  What does this algorithm return What makes that a useful return value  What is the running time of this algorithm By the way which ones Warshall  kij d kij dNote This computes shortest path values not the paths See CLRS pages  about computing the paths themselves A FloydWarshall Example  Computes matrices Dk           where each         is the shortest path value from i to j using only intermediate vertices numbered up to k  What D matrices does it compute for this example graph  kij d kij dSee CLRS Ch  CS   A FloydWarshall Example  Computes matrices Dk           where each         is the shortest path value from i to j using only intermediate vertices numbered up to k  What D matrices does it compute for this example graph  kij d kij d