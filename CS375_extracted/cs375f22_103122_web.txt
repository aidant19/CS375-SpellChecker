 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   grading update   ps in progress   expect ps out in next couple of days   due no sooner than  week after it's assigned   project    first part due already   other parts due nov     please note some restrictions on my schedule   i will not be available for dress rehearsals tuesd ay or later   i expect to be traveling on nov   and probably wo n't be on email or able to  answer questions after noon on that day so please plan accordingly  cs --    business  some notes on grading of projects   grading on projects is in part as might be expect ed similar to grading of  other papers in other non-cs courses   overall for both presentations and write-ups mor e credit will be given to  submissions that demonstrate   greater scope of work completed   greater depth of insight in the work completed   greater command of relevant concepts   greater clarity completeness and effective commu nication of the work  this is meant to be intuitive what you'd expect to g et credit for but  please let me know if there are any questions about  grading criteria this is related to the idea  that not all improvements to  your exhaustive search algo  are of equal value as noted  on the project assignment  business  some notes on grading of projects   grading on projects is in part as might be expect ed similar to grading of  other papers in other non-cs courses   as expected credit will be given for work your team has done  as always be sure to cite  credit every source of  assistance including your prof   tas textbook and online sources   be specific about contributions from other sources  so your audience can be certain  about what work your team has done i e  as oppose d to work taken from other sources   as expected credit is given for work done by your  team presenting others' work or  ideas earns credit for the presentation but not fo r creating the work  ideas of others   as always please feel free to ask me grading-rela ted questions as you do  your work on projects  it's best to direct project-oriented questions to m e rather than to tas tas do not always  have the context that will best help you complete t he project as intended  expected  cs --    zen and the art of  algorithm design   a couple of generally good ideas principles to help you  design your algorithms and their implementations   i might restate principle  as  keep your foundations simple   i might restate principle  as  let your definitions tell you what to do   let's apply this to binary trees   the foundations i e  relevant definitions and dat a  structures should be as simple as possible while sti ll  providing all needed functionality    let the foundations guide the development and ana lysis  of algorithms based on them  cs --    definition  of our intbintree data structure   throughout cs we will sometimes refer to an intbintree  data structure representing a binary tree of integers   in english we'd say an intbintree is   either empty   or   an int called val   and two subtrees called left and right  that are also intbintrees   programmers might be used to seeing it more like this  definition intbintree empty or  int val  the int value not empty  intbintree left  the left subtree  intbintree right  the right subtree is this a good definition consider principle   keep your foundations simple  note this definition may  show up on hw too  is this definition equivalent  to the english one above  the fact that a tree could be  empty is often implicit in  many specifications  definition  of our intbintree data structure   in english we'd say an intbintree is   either empty   or   an int called val   and two subtrees called left and right  that are also intbintrees   to be unambiguous  and consistent with functional  programming  about how we work with ibts these will be  the primitive functions defined on ibts   val t returns the val element of an ibt t  left t returns the left subtree of an ibt t  right t returns the right subtree of an ibt tnote this definition may  show up on hw too  we'll call them ibt s for short  important note valt leftt and rightt are functions that return values  they are not fields of an object  because of this we cannot assign values  to them e g  valt   is not permitted for cs these are the  only ways to access val  left right   so something  like t val is not permitted   cs --    correctness of recursive  algorithms inductive arguments   when arguing the correctness of a recursive algorithm the  general form is that of an inductive argument   the explanation follows the structure of the algorithm   show that the algorithm's base case returns correc t output   show that the recursive cases return correct outpu t  under the assumption that all recursive calls retur n correct output   here how would that work   how would we explain the  base case the recursive case just like when creating recursive code we assume rec ursive calls work in the  recursive case  algorithm levelst  input intbintree t output integer number of levels in t  if t is empty  return   else  return maxlevelsleftt levelsrightt    correctness of recursive  algorithms inductive arguments   when arguing the correctness of a recursive algorithm the  general form is that of an inductive argument   the explanation follows the structure of the algorithm   show that the algorithm's base case returns correc t output   show that the recursive cases return correct outpu t  under the assumption that all recursive calls retur n correct output   as part of explaining recursive  cases also explain how we  know the algo terminates   show arguments in recursive  calls get closer to base case just like when creating recursive code we assume rec ursive calls work in the  recursive case  algorithm levelst  input intbintree t output integer number of levels in t  if t is empty  return   else  return maxlevelsleftt levelsrightt    cs --    another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere  in an intbintree   how would we write the problem specification for ibtsearch   what would be the input   what would be correct output   how would we design an  algorithm to solve it   would the algorithm be iterative or recursive   how would we argue its correctness definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere  in an intbintree   how would we write the problem specification for ibtsearch   input an int i and an intbintree t  output true exactly when iis in t false otherwise definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  algorithm ibtsearchi t  input int i intbintree t output true exactly when iis in t false otherwise  cs --    another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere  in an intbintree   how would we write the problem specification for ibtsearch   input an int i and an intbintree t  output true exactly when iis in t false otherwise definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  algorithm ibtsearchi t  input int i intbintree t output true exactly when iis in t false otherwise  if t  empty  return false  else  if valt  i  return true  else  return ibtsearchileftt or ibtsearchirightt  the last line uses the  boolean operator or   which is inclusive  it is  true when either or  both operands are true  another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere  in an intbintree   how would we argue correctness for ibtsearch  inductively   base case if tis empty  some people might view this as  having two base cases   the definition of intbintree  however has one base case  empty tree  i view the algo as  following that definition  definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  algorithm ibtsearchi t  input int i intbintree t output true exactly when iis in t false otherwise  if t  empty  return false  else  if valt  i  return true  else  return ibtsearchileftt or ibtsearchirightt   cs --    another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere  in an intbintree   how would we argue correctness for ibtsearch  inductively   recursive case for non-empty t if i is in t  it's either at the root in left  or in right   by defn that's all there is in a tree   so  some people might view this as  having two base cases   the definition of intbintree  however has one base case  empty tree  i view the algo as  following that definition  definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  algorithm ibtsearchi t  input int i intbintree t output true exactly when iis in t false otherwise  if t  empty  return false  else  if valt  i  return true  else  return ibtsearchileftt or ibtsearchirightt   another intbintrees exercise  search   the search problem on intbintrees asks if an int is anywhere  in an intbintree   how would we argue correctness for ibtsearch  inductively   does the algo terminate i e  does input get  closer to a base case with each recursive  call hint yes  it's always a subtree   some people might view this as  having two base cases   the definition of intbintree  however has one base case  empty tree  i view the algo as  following that definition  definition intbintree empty or  int val  int value  intbintree left  left subtree  intbintree right  right subtree  algorithm ibtsearchi t  input int i intbintree t output true exactly when iis in t false otherwise  if t  empty  return false  else  if valt  i  return true  else  return ibtsearchileftt or ibtsearchirightt   cs --    break it down again   in general different ways of breaking down a problem into  subproblems can lead to different algorithms   different data structures by their definitions suggest different  natural ways to break problems into subproblems   how would a binary tree suggest breaking a problem  into  subproblems   how would a node-based linked list suggest breakin g a problem into  subproblems   how about for an array e g  mergesort vs    any other sort basically  this isn't to say that for any given data structur e some approach is always applied  this is just looking for common approaches and wha t makes them natural in context   cs --    break it down again   in general different ways of breaking down a problem into  subproblems can lead to different algorithms   different data structures by their definitions suggest different  natural ways to break problems into subproblems   how would a binary tree suggest breaking a problem  into  subproblems subproblems on sub-trees kinda one half at a time   how would a node-based linked list suggest breakin g a problem into  subproblems subproblems on lists one element shorter   how about for an array subproblems involve changing indices and  iterating over indexed ranges index access is centra l to arrays e g  mergesort vs    any other sort basically  in all of these cases the foundations the definitio ns of the underlying  structure suggest that approach to breaking into sub problems  break it down again   in general different ways of breaking down a problem into  subproblems can lead to different algorithms   different data structures by their definitions suggest different  natural ways to break problems into subproblems   how would a binary tree suggest breaking a problem into  subproblems subproblems on sub-trees kinda one half at a time   how would a node-based linked list suggest breaking a problem into  subproblems subproblems on lists one element shorter e g  mergesort vs    any other sort basically  in all of these cases the foundations the definitio ns of the underlying  structure suggest that approach to breaking into sub problems in a very broad sense these represent the two major ways of thinking about recursion  size of subproblems either divided from tree or subtracted from list original input size  cs --    list algorithms   we've seen how the definition of a binary tree can guide the  design of algorithms on binary trees   many common algorithms are written on lists   how does the definition of a list guide the design s of those algorithms  what are some difference between arrays and lists in this context  cs --    list algorithms   we've seen how the definition of a binary tree can guide the  design of algorithms on binary trees   many common algorithms are written on lists   how does the definition of a list guide the design s of those algorithms   among the significant differences between an array and a list   arrays are stored as contiguous blocks of memory lists when not  simply extensions of arrays are node-based  linked lists   arrays have direct constant-time indexed access to any element lists  require traversing a list to reach an element whic h is not constant-time   because lists are node-based it can be constant-t ime to access the sub- list of all but the first element as a distinct object what are some difference between arrays and lists in this context  list algorithms   we've seen how the definition of a binary tree can guide the  design of algorithms on binary trees   many common algorithms are written on lists   how does the definition of a list guide the design s of those algorithms   for example consider the search problem on lists   there are multiple ways to approach designing an algorithm  for this how might you design one   what can you say about the complexity of your algo rithm input item i and list l  output true if i is an element of l  false otherwise what are some difference between arrays and lists in this context  cs --    list algorithms  and recursion   lists as opposed to arrays can have node-based defintitions   as part of that a list type is commonly defined recursively   how would you write a recursive algorithm to solve the search  problem on lists   one possibility is shown here   how would we argue its  correctness   do you believe that it works  correctly   what can we say about its  complexity input item i and list l  output true if i is an element of l  false otherwise  algorithm reclistsearchi l   see specification immediately above  if l     return false  else  if i is l  return true  else  return reclistsearchil this uses python- like list slicing  syntax to refer to  all but the first  element of l  list algorithms  and recursion   lists as opposed to arrays can have node-based defintitions   as part of that a list type is commonly defined recursively   how would you write a recursive algorithm to solve the search  problem on lists   one possibility is shown here   how would we argue its  correctness   do you believe that it works  correctly   what can we say about its  complexity   list slicing can't be assumed  to be constant time input item i and list l  output true if i is an element of l  false otherwise  algorithm reclistsearchi l   see specification immediately above  if l     return false  else  if i is l  return true  else  return reclistsearchil this uses python- like list slicing  syntax to refer to  all but the first  element of l  cs --    list algorithms  remove first occurrence of an element   consider the problem of removing the first occurrence of an  element from a sequence specified here for a list   how would you design an algorithm to solve this problem   iteratively on array-based lists   recursively on node-based lists   how would the complexity of this be different on a  list i e  a linked  list than on an array input item i and list l  x   x n output if i x kand k is the smallest value for which i x k  return x   x k- x k   x n otherwise i e  when there is no k such that i x k return l  definition  of our llist data structure   throughout cs we will sometimes refer to an llist data  structure representing a list of elements   in english we'd say an llist is   either empty   or   an element called first   and an llist called rest representing all the elements after first is this a good definition consider principle   keep your foundations simple  note this definition may  show up on hw too  is this consistent with your understanding of list structures that  is linked list structures which are typically node-based in  implementation  cs --    definition  of our llist data structure   in english we'd say an llist is   either the empty list   or   an element called first   and an llist called rest representing all the elements after first   to be unambiguous about how we work with llists these  will be the primitive functions defined on llists   firstl returns value of the first element of an llist l   restl returns value of the rest sublist of an llist l   consvl a constructor function that takes an item v and an llist l  and returns a new llist l' such that   what do you think it might be note this definition may  show up on hw too  what do you think  the complexities of  these functions are 