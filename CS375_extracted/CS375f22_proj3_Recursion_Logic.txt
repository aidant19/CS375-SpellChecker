analysis of algorithms  cs  fall   project   due by pm on saturday nov    project  recursion and logic  in this assignment you'll work in teams of four to design algorithms for working with propo- sitional logic expressions and to use inductive arguments and recurrences to explain the correctness and complexity of recursive algorithms  the goals of this project are   to give you practice designing recursive algorithms and working with recursive defini-  tions   to give you practice using inductive arguments and recurrences to explain correctness  and complexity of recursive algorithms   to give you practice thinking about and working with propositional logic   to give you practice creating and giving a technical presentation and   to give you practice working with other students as a team   the project assignment  here are the parts of this assignment    propositional logic evaluation programming languages as part of their work have algorithms to evaluate boolean expressions  now it's your turn your team will design and explain an algorithm to evaluate propositional logic expressions     the satisfiability problem the satisfiability problem or sat for short is a classic cs problem given a boolean expression is there any way to assign true or false to its variables to satisfy the expression that is to make it evaluate to true your team will write an exhaustive search algorithm to solve this problem     improvements your team will improve upon your exhaustive search algorithm for  sat     create and give a presentation your team will present your work including  explanations of correctness and complexity of your algorithms   the project involves working with recursive algorithms so your correctness and complex- ity arguments will involve inductive arguments and recurrences  there are things to do for each part of the assignment as described individually below   as usual in cs excessively inefficient or clunky algorithms may not receive full credit  that doesn't mean all algorithm designs must be optimally efficient but if your algorithm does substantially more work than a straightforward brute force approach might it may not earn full credit  please feel free to ask me clarifying questions about this if you'd like     propositional logic evaluation  programming languages need definitions of arithmetic and boolean logic expressions so that a compiler or interpreter can check expressions for type correctness and evaluate them as part of computation  the structures and definitions underlying this work are typically recursive e g  grammars that define what a valid arithmetic or boolean expression could be  for this part of your project you'll be given a recursive definition for propositional logic expressions expressions that evaluate to true or false and you'll create a recursive algorithm to evaluate these expressions    our definition of propositional logic expressions  propositional logic expressions or ples for short are combinations of variables and log- ical operators such that if we assign a value of either true or false to every variable the expression would evaluate to either true or false  for examples   any variable that we define as a propositional variable a boolean in many programming languages is a valid ple  if we have a propositional variable p and assigned it the value true for instance it will evaluate to true    an expression such as p and q is a valid ple  for instance if we assign p the value true and q the value true p and q should evaluate to true because both p and q are true    an expression built from smaller ples such as p and q or not r and q would evaluate to either true or false depending on the values assigned to variables p q and r  see below  for this project we'll use four propositional operations to build ples from variables not and or and implies sometimes also called if-then  it is common to use truth tables to describe what propositional operations do on their input arguments i e  the semantics of these operations  for this project those standard descriptions and truth tables are pre- sented as part of a supplementary document about truth tables available from our course's project assignments website   here's an extremely important note  it is essential that you understand the material on truth tables as part of this project  as always please see me with any questions i recommend that you read and understand that document before continuing with the project      recursive definition of ple syntax  the truth tables describe what our four propositional operators mean in terms of what values they evaluate to but to specify what your algorithm might take as input we also need to define the full syntax of all possible expressions that might be evaluated by your algorithm  here's a recursive definition of the syntax for valid propositional logic expressions ples    base case given an initial set of propositional variables e g  p q r       all elements of that set are valid ples  important note in this context we will use any single lowercase letter as a propositional variable   recursive  inductive cases let's say that the uppercase letters p and q stand for ples  that is p and q each stand for some syntactic expression e g  not q or p unlike the lowercase letters that are variables within ples  then the following are also ples    not p    p and q   p or q   p implies q  note that the parentheses are part of what's needed for valid syntax  so for example p implies q and not r or p is a syntactically correct ple  that would be determined by following the recursive definition with these steps    r and p are both valid ples because they are propositional variables and the base  case of our definition says they are ples     because r and p are both ples recursive case  of our definition above says that  r or p is a ple     because r or p is a ple recursive case  says that not r or p is a ple     because q is a ple because it's a propositional variable thus a ple by the base case and not r or p is a ple recursive case  says that q and not r or p is a ple     because p is a ple shown above and q and not r or p is a ple recursive case   says that p implies q and not r or p is a ple   this is the kind of thing that compilers  interpreters for programming languages do  please see me if you'd like to go over that chain of reasoning     an algorithm for evaluating propositional logic expressions  for this part of the project you will create an algorithm for evaluating ples using the syntax and semantics given in the sections above  here are the input and output specifications that your algorithm must meet  input a ple p  and a dictionary-like data structure m that assigns a truth value i e  either true or false to every propositional variable that appears in p   each variable is assigned exactly one value  output if p is a propositional variable return the truth value assigned to it in m   otherwise return the truth value to which p evaluates in accord with the propositional operation truth tables and treating every variable appearing in p as evaluating to the value associated with it in m      as a very small example if m assigns p  true q  true then variables p and q evaluate to true and ple p and q evaluates to true  for more examples of evaluating a ple in accord with our truth tables and an assignment of truth values to variables please see the some example exercises section at the end of our supplementary document about truth tables and semantics and see section  below in this document  and as always please feel free to see me with any questions about evaluating ples  your algorithm must be recursive following the two zen principles in lecture  the base case of your algorithm should correspond to the base case of the definition of the syntax of ples your recursive cases should correspond to the recursive cases of the definition of ples  if your team would like to employ any other design structure for your recursive algorithm please discuss it with me very early in your process it might not earn full credit on this project   you may assume that you have the following functions to use in creating your algorithm   the function var valvm that returns the truth value assigned to propositional vari-  able v in m     the function is varp that takes a single ple p as input and returns true if p is a  propositional variable false otherwise    the functions is notp is andp is orp and is impliesp each of which takes a single ple p as its only input argument and returns true if ple p is formed by ap- plying the appropriate operation not and or implies respectively to its arguments these functions return false otherwise  examples    is varp and q or r returns false because p and q or r is not a proposi-  tional variable     is andp and q or r returns true because ple p and q or r is formed as the result of the and operation on two arguments the first is p and the second is q or r     is orp and q or r returns false because p and q or r is the result of the and operation on two arguments  the or operation in that expression is nested within one of the arguments to the and operation so p and q or r is not formed by or of two arguments   as usual you will give an english description and pseudocode of your algorithm along  with correctness and worst-case complexity arguments    for correctness because this is a recursive algorithm be sure to give an inductive argu- ment that concisely and convincingly explains that your algorithm is correct including termination on all inputs that meet the input specifications    for complexity because this is a recursive algorithm be sure to set up and solve a recurrence that correctly expresses the worst case complexity of your algorithm  you will have multiple choices about what n stands for in your complexity argument and you will want to choose one that allows you to set up a recurrence that is relatively easy to solve you may well not want it to stand for the length of the input as a number of characters but instead stand for some other quantity that helpfully represents the size of the input you should then explain for a full-credit complexity argument why    the asymptotic complexity you get using that n is the same that you'd get if you used the entire size of the input hint explain that the differences will be covered by the leading constant in the asymptotic definition   choosing the quantity to represent by n may require some thought  if you have some options in mind but aren't sure which to choose feel free to discuss them with me  hint for students who want to code this up in an actual programming language       go for it but you might want to start by creating your own new recursive data type that corresponds to the recursive syntactic definition of ples above  for people who aren't comfortable with recursion it might be tempting to just treat a ple as a string but please do not do so here this project is focused on building your toolkits for thinking about recursive definitions and algorithms  besides which it might be harder to do this if you treat ples as strings  in general for programming languages compilers have components that do lexing and parsing to translate from the original string of text of a program into the definitions that underlie the programming language we won't write those components here   the satisfiability problem  the satisfiability problem or sat for short is a classic cs problem given a proposi- tional logic expression is there any way to assign true or false to its variables to satisfy the expression that is to make it evaluate to true this problem has a wide range of applications it can be applied for playing games or solving puzzles such as sudokus and it has a role in the theoretical foundations of algorithm complexity which we'll get to later in the semester and as part of this project you'll write an exhaustive search algorithm to solve this problem  as some useful terminology for any ple p  we'll say that a satisfying assignment is a way of assigning truth values true or false to every propositional variable in p such that p then evaluates to true  if it helps you can think of it as a dictionary-like data structure like the one called m in the input specifications given in section   above under the further restriction that p must evaluate to true for that m to be a satisfying assignment for p   for examples   for ple p  p and q the assignment p  true q  true is a satisfying assign- ment  moreover no other assignment of truth values to variables would be a satisfying assignment for that p   do you see why please ask me questions if it isn't clear to you   for ple p  p implies q and not r or p the assignment p  true q  true r   false is not a satisfying assignment for p  because as described in our supplementary document about truth tables p evaluates to false under that assignment    for the same ple p  p implies q and not r or p the assignment p  false q   true r  false is a satisfying assignment r or p evaluates to false so not r or p evaluates to true so q and not r or p evaluates to true and finally p implies q and not r or p evaluates to true     i didn't go through the steps in the individual evaluations of ples above they're the same idea as in our supplementary document about truth tables but please see me if there are any questions about them  here are the input and output specifications that your algorithm for the sat problem  must meet  input a ple p   output true if there exists some way of assigning truth values to all propo- sitional variables in p such that p evaluates to true following the evaluation described by our truth tables false otherwise   because you are creating an exhaustive search algorithm as in your previous project project  loop invariants exhaustive search and beyond please assume once again that you can use algorithms to create the relevant lists of all subsets or all permutations to use in your exhaustive search with the given time and space complexities   generate-all-subsets you may use a generate-all-subsetss algorithm that  has time complexity n  n and space complexity n  n on input s of size n    generate-all-permutations you may use a generate-all-permutationsl al- gorithm that has time complexity n  n and space complexity n  n on input l of size n   please see project  for the input  output specifications of these algorithms   as usual you will give an english description and pseudocode of your algorithm for sat  along with correctness and worst-case complexity arguments    for correctness use the appropriate technique to explain correctness where needed  if all or part of your exhaustive search algorithm is recursive give an inductive argument if all or part of your algorithm is iterative you do not need to specify and formally use a loop invariant but your correctness argument should nonetheless be based on what we know to be true each time through the main loop of your algorithm    for complexity again use the appropriate technique to explain correctness where needed  if all or part of your exhaustive search algorithm is recursive you do not necessarily need to solve a recurrence but you should give a concise and convinc- ing complexity argument that is based on a recurrence that correctly expresses the worst case complexity if all or part of your algorithm is iterative give a concise and convincing correctness argument based on its structure as usual   your algorithm and explanation should have enough details to make it clear that your team fully understands all work needed for your solution  that may include writing and explaining algorithms for the following subroutines which would be part of your sat algorithm   a subroutine that returns a list of all propositional variables in a ple p     a subroutine that creates an assignment of truth values to all variables in p such that  some specified ones are assigned the value true and the rest are assigned false   these are not primitive functions so if you want to use that functionality be sure to write algorithms and input  output specifications for functions that give you that functionality    important note if your team decides not to create and use these two subroutines but instead to try a different approach for a sat algorithm please discuss that with me as soon as possible   you may however assume that you are given functions for use in your algorithm that do standard operations on lists and dictionary-like data structures e g  creating and adding pairs to dictionaries adding elements to lists appending  extending lists as in python  you may also assume that those functions have reasonable time and space complexities but in your complexity arguments be clear to say what the complexities are of all functions relevant to the complexity of your algorithm for sat   hint be sure that you understand what your algorithm is doing an exhaustive search over  the input  output specifications are helpful that way you are given a ple p  so you're not looking for a ple p that is true instead you're looking for a satisfying assignment for the ple p that you're given     improvements  as you did in project  after your team has worked together to arrive at a good exhaustive search algorithm in your work for part  of this project your next step will be to improve upon that exhaustive search solution   please see project  section  for suggestions about how to think of improving algorithm efficiency  once again your team is especially encouraged not to restrict yourself to only the first or second of the three ways listed there special-case improvements can be very helpful even on very simple-seeming special cases  your team should propose one or two algorithms or modifications that improve upon your exhaustive search sat algorithm  there are no fixed criteria for this project about exactly how much your improvements must improve upon your initial exhaustive search al- gorithm your team will earn more credit on this part of the project for improvements that show more depth of thought about the problem and its solutions achieve greater efficiency have greater impact for important special cases e g  make it very efficient when used to solve sudokus apply more broadly to possible inputs and are more thoroughly and help- fully analyzed and described  as with project  i hope these criteria make intuitive sense to you and as always please feel free to ask me questions  hint you are advised not to try to come up with polynomial-time solutions for the general case of sat    presentation  for project  you were part of a team that gave a presentation  minutes in length  for this project you will instead give a presentation that is  minutes in length  as many of us who frequently give presentations believe making a -minute presentation is different from making a -minute presentation and it's important to be able to do both  your team will give a technical presentation about the algorithms you've created for this project  as you did for project  create slides in powerpoint google slides or some    other application of your choice for your presentation hints and suggestions for technical presentations from project  also apply here  with only  minutes available for this presentation however you may need to be selective about how many slides you create and how much material they contain  for an effective presentation your audience should have time to read and process every slide presented to them so spending too little time on a slide may well result in an ineffective presentation  for full credit your team must make an effective presentation lasting between  minutes anything outside that range may not receive full credit  if you think your talk will be longer or shorter than that please discuss that with me i will be happy to help you find a good balance for your presentation   you should assume that your audience is at the level of cs students who are familiar with recursive design the general form of inductive arguments and recurrences but who are not yet experts with them  for example assume that your audience knows what an inductive argument is and how it relates to recursion and what a recurrence is an how it relates to time complexity of recursive algorithms but would need to be walked through details involving setting up and solving a particular recurrence or how an inductive argument applies to a particular algorithm  to the extent that you are explaining iterative algorithms please make the same assumptions about your audience's familiarity with those concepts as you did for project  see the project  assignment for details if needed  you should also assume your audience has no previous knowledge of your algorithms or any problems involved and they may not quickly grasp any subtleties   your presentation should describe at least the following   our definition of ples    your algorithm for evaluating ples and how it works  consider including at least part of a short example with enough context and content to fully illuminate how your algorithm works for your audience  see note below about including examples    your algorithm for sat and how it works including anything you think is particularly interesting about your approach to the problem  consider including at least part of a short example with enough context and content to fully illuminate how your algorithm works for your audience  see note below about including examples    at least one proposed improvement from section  above   include a high-level de- scription of the improvement and a comparison that shows how much this improves upon the exhaustive search algorithm  consider including enough of a short example to illuminate how it differs from your original exhaustive search algorithm  see note below about including examples    complexity and correctness results for your algorithms  there may not be time in your presentation for full correctness and complexity arguments for every algorithm but to ensure that your presentation is authoritative for your audience include at least the following    one correctness argument showing command of inductive arguments     one complexity argument showing command of recurrences and solving them     a correctness and complexity result not necessarily a full argument accompa- nied by a very brief high-level explanation if not a longer explanation for each algorithm presented     don't worry about space complexity for your presentation unless you feel it is important to understand interesting elements of your algorithms   in a -minute presentation there will likely not be time to go into deep details on anything all explanations will need to be high-level focusing on the essential details for enabling your audience to understand your work  your write-up document should contain additional details enabling your team to show full command of your work and describe important components   note about including examples in this presentation  it is expected that your presentation will have one or more illustrative examples to enable your audience to under- stand your algorithms  you may need to be judicious in choosing your examples due to time constraints however perhaps using one example to illustrate multiple components of your work  in  minutes there may not be time to include all the examples you might like as with the previous project this is a team presentation and a class assignment so ideally the entire team would learn about all parts of the topic being presented and not only would the workload be balanced among team members but it would also appear balanced to viewers  for that reason your presentation should consist of each person presenting for roughly  minutes at a time followed by a different teammate so for example in a  minute presentation each person on a four-person team would take one shift of presenting for roughly  minutes each  this structure might require a conceptual topic to be split among multiple individuals in the presentation due to the impositions of time limits but that's part of the pedagogical benefit of this it encourages more people to engage with more different parts of the topic being presented  important note presentations not following this structure will not receive full credit for this assignment  if there are questions about what's expected in terms of the division among teammates of time spent presenting please let me know  the default expectation is that you will record your presentation as a screen recording in zoom  if you believe another option would be better for your team please see me about it as soon as possible  your accompanying write-up in addition to the presentation itself your team will create an accompanying write-up document which should enable your audience to fully understand the work done for this project if they do not see your talk  this document must be typed submitted in pdf and contain all important details especially those that you did not have time to include in your talk itself  it should contain at least the minimum needed for a presentation of algorithms   pseudocode and english descriptions of every algorithm including separate pseudocode  english descriptions for each improvement  for each improvement include  sen- tences about how your team came up with the ideas behind that proposed improvement    concise and convincing high-level correctness arguments and complexity analyses  please use inductive arguments and recurrences when analyzing recursive algorithms  for your team's proposed improvements you may not need to give a separate correct- ness argument for each improvement but if an improvement significantly affects the inductive arguments previously used to show correctness of the exhaustive search al- gorithm you do need to show that the improvement also solves the problem correctly which could involve a modified inductive argument     as mentioned in section  above to explain complexity for recursive algorithms for this project you may not necessarily need to solve a recurrence but you should give a concise and convincing complexity argument that is based on a recurrence that correctly expresses the worst case complexity  for explaining complexity of iterative components of algorithms give a concise and convincing explanation based on its structure as usual   overall please include everything needed to concisely demonstrate your command of relevant analytical techniques and other concepts including recursive design inductive arguments and recurrences  including relevant examples can also be helpful in communicating your work to your audience your write-up may allow you to include components in examples that time constraints prohibited you from including in your presentation   as would be expected your grade will depend on the clarity readability and complete- ness of your write-up enabling readers to understand your work and demonstrating your command of key concepts  depending on the margins  font size  etc  of your document your write-up should probably be  pages in length  please keep it as concise as it can be while still containing all relevant information  if your write-up is running longer or shorter than that range please see me to check whether it contains unneeded material or too little material write-ups that are much too long or too short are not maximally effective and may not receive full credit   overall for both the presentation and the write-up more credit will as expected be given to submissions that demonstrate greater scope of work completed greater depth of insight in the work completed and more correct and effective presentations of the work  although no dress rehearsal is required for this project you are welcome to consult with me about a draft of your presentation or write-up i will be happy to give you feedback about the level of detail in the draft      submission instructions  deadline pm nov   a designated submitter from each team should submit three items by emailing them to me eaaroncolby edu   a pdf file with all of the slides used for the presentation  please put two slides per  page as is done for cs course lecture notes and name the file cs proj slides team initials pdf    the write-up document that accompanies your presentation which should be a pdf  file called cs proj writeup team initials pdf    a video file or link to it of your presentation  please put it in your google drive  space if it's too large to simply include in an email  please name the file cs proj presentation team initials mp  as usual initials is to e replaced by the initials of the team members in the group in the team assignments  e g  if eric aaron and stephanie taylor were the teammates a file from that team would be called cs proj slides team ea st pdf   note the preferred mp format  please let me know as soon as possible  if for any reason you cannot submit an mp video  lateness policy to keep pace with the project assignments in cs it is important that this assignment be turned in promptly and it is more important than usual with this project being due near the end of the semester for this project there will be a deduction of   for each day late i e    deduction for submitting up to  hours late   deduction for submitting more than  hours late up to  hours etc up to a  deduction for submitting up to  days  hours late  after  days late submissions will receive a  deduction  please submit your work promptly  as always extenuating circumstances will be considered please contact me as soon as  possible if any extenuating circumstances are impeding your work on this project    