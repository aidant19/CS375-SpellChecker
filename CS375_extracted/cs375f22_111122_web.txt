 cs --    cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   business   apologies for missing class i really didn't want to   project  grading update   in progress but will be slow catching up from il lness may take a  while   please meet with me if you'd like prompt feedback on any part of  project    ps due pm today   expect ps out soon   due no sooner than  week after it's assigned   project  out   will discuss today   due nov   deadline may be slightly extended  cs --    for proj  evaluating expressions   how do we as people evaluate an arithmetic expression like       do we read left to right not really   for proj  evaluating expressions   how do we as people evaluate an arithmetic expression like       do we read left to right not really    there are lots of components to that and we first  evaluate each  component and then combine them to evaluate the en tire expression  cs --    for proj  evaluating expressions   how do we as people evaluate an arithmetic expression like       do we read left to right not really    there are lots of components to that and we first  evaluate each  component and then combine them to evaluate the en tire expression   it's as if we had an evaluate  function    and applied it recursively  we use it on each component then  combine to get our end result  for proj  evaluating expressions   how do we as people evaluate an arithmetic expression like       do we read left to right not really    there are lots of components to that and we first  evaluate each  component and then combine them to evaluate the en tire expression   it's as if we had an evaluate  function    and applied it recursively  we use it on each component then  combine to get our end result   evaluating propositional logic expressions works the same  way in general   let's get formally introduced to propositional logic  cs --    propositions   defn proposition  a statement that has the  property of truth or falsity   propositions are the key elements to represent  analyze or explain declarative knowledge  propositions  washington d c  is the capital  of the usa   waterville is the capital of  maine              non-propositions  what time is it  pass the salt   x      xy  z presuming  values for x  y z are not  given  known the first and third  of these are true  the second and  fourth are false   propositional operators   recall proposition  a statement that has the property of  truth or falsity   often we use propositional letters or variables  to represent  propositions e g  pstands for poughkeepsie is the capital of ny   there are several operators sometimes called boolean  operators  that can construct new propositions from old ones  negation  not if pis a proposition not p is a proposition  conjunction and p and q  disjunction or p or q  implication if  then if p then q  cs --    propositional operator negation   whatever the value of p true or false the value of  proposition not p written p is the opposite   if pis today is monday pis it is not the case that  today is monday or more simply today is not monday    negation can be expressed with a truth table  p p proposition  truth values t ff t propositional operator conjunction   conjunction the and operator   whatever the values of propositions p q conjunction p and  q written p  q or p  q  is also a proposition   if pis today is monday and qis it is snowing today  then p  q is today is monday and it is snowing today   p  q is true on snowy mondays and false on any day that is not  monday and on any day that is monday but not snowi ng   conjunction values as a truth table  p q t t f ft f t ft f f fpq  cs --    propositional operator disjunction   disjunction the or operator   whatever the values of propositions p q disjunction p or q written p v qor p  q  is also a proposition   if pis today is monday and qis it is snowing today then p vqis  today is monday or it is snowing today   p vq is true on any day that is a monday or on which it is snowing  including snowy mondays it is not exclusive   and false only on days that  are not mondays on which it is not snowing   disjunction values as a truth table  p q t t f ft f t ft t t fp vqthe non-exclusive sense of  or can be a bit subtle  exercise  what would the  exclusive-or operator's truth  table look like  it turns out there is such an  operator and it's commonly  used in logic the english  word or is a complicated  thing to understand  propositional operator implication   implication the ifthen operator also called conditional   whatever the values of propositions p q implication if p then q  written p q is also a proposition   if pis today is monday and qis it is snowing today then p qis  if today is monday then it is snowing today    vocabulary in p q pis called the hypothesis or antecedent  and qis  called the conclusion or consequent    implication values as a truth table  p q t t f ft f t ft f t tp qreally these are the  truth values for  implication  they look like the values  for  p v q  exercise   check for yourselves  cs --    sounds if-y  material implication   meaning for implication  symbol in propositional  logic is referred to as  material implication   it says that pqis false  exactly when pis true and q is false   not the same as every  meaning of ifthen in  english but it's what's used  in logic  p q t t f ft f t ft f t tp qexamples of material implication  and natural language usage  politician says if i am elected  then i will fix the environment  false if the speaker is  elected and doesn't fix the  environment  true if e g  the speaker  doesn't get elected  if today is friday then       true no matter what day it is  if today is friday then       true except on fridays even  though      is false  exercise evaluating propositional  logic expressions   defn propositions are  boolean -valued  expressions i e  their  values are either true or  false   propsotional expressions  are evaluated like any  other mathematical  expressions examples  let p  true q   false r  true   what do  the following expressions  evaluate to    p  r    q v false    p q    r v p  q    p v r p v q  r    true r  cs --    for proj satisfiability  and assignments  of truth values to variables   an assignment of values to variables  is what you think it is something  like p  true q  false r  true  is as assignment of truth values to  the variables p q r   we say a propositional logic  expression ple  pis satisfiable if  there is an assignment of truth values  to the variables in p so that p evaluates to true examples  let p  true q   false r  true   what do  the following expressions  evaluate to    p  r    q v false    p q    r v p  q    p v r p v q  r    true r  business project    project  out due nov     deadline may be slightly extended   parts of project     recursive algorithm to evaluate propositional log ic expressions  your  team will create an algorithm to do the kind of thi ng a programming language  does evaluate propositional logic boolean expressi ons     exhaustive search algorithm for satisfiability  the satisfiability problem  sat  for short asks if there is a way for a propositi onal logic expression to be  made true  your team will create an exhaustive sear ch algorithms to solve this  problem     improvements  your team will improve upon your exhaustive searc h  algorithm     create and give a presentation  your team will present work from the  previous three parts of the assignment using recurrences and inductive  arguments loop invariants where appropriate  have you read through proj yet  please note the separate supplementary  document about truth tables  cs --    solving recurrences   we'll cover three common techniques for solving  recurrences i e  getting  or o bounds on the solution  unwinding or backward substitution  unroll the recurrence  until it reaches a base case then count  analyze the cost  represented  recursion-tree method  represent costs as nodes in a tree and  analyze total cost  master method  solve recurrences of the form  tn  atnb  fn we already did an example of unwinding and we'll  do another one soon  cs --    unwinding   an example solve tn  tn  n  unwind the recurrence by plugging in the definition on  successively smaller arguments   from the definition tn  tn  n   by that same definition tn  tn  n   tn  n   so by plugging that in tn  tn  n   n   what would the next steps be in this unwinding p rocess   where would it stop this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow   what information is missing from this recurrence w hich we will  need to be able to solve it  unwinding   an example solve tn  tn  n  unwind the recurrence by plugging in the definition on  successively smaller arguments   from the definition tn  tn  n what information is missing from this recurrence w hich we will  need to be able to solve it  tn tn tn tn  tn  n  tn  n  tn  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                   do you see a pattern here and when does this unwin ding end this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow   cs --    unwinding   an example solve tn  tn  n   for a base case let's use t   or  if we want  unwind the recurrence by plugging in the definition on  successively smaller arguments   from the definition tn  tn  n  tn tn tn tn  tn  n  tn  n  tn  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                           kk kktn tn tn tn kk kk  kn   kn   kn   kn                  the k'th step shown here illustrates  the pattern that holds for any  relevant k  it can help with our  analysis to show this in our work this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow   unwinding   an example solve tn  tn  n   for a base case let's use t   or  if we want  unwind the recurrence by plugging in the definition on  successively smaller arguments   from the definition tn  tn  n  tn tn tn tn  tn  n  tn  n  tn  n  tn  n   tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                           kk kktn tn tn tn kk kk  kn   kn   kn   kn                    nt  lg nn  nt  lg nn  nt  lg nn  nt  lg nn      n lg n the lg n term comes because the  recurrence unwinds lg n times  before hitting the base case do  you see why this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow   cs --    recursion trees an overview   recursion trees can represent how a recursive algorithm   breaks input down into recursive calls on sub-prob lems   or equivalently  combines recursive calls into a solution on the o riginal  problem   here's an example from clrs mergesort   each node shows input size at that level of  recursive calls   here original input size  breaks into  sub-problems of size  etc   this example shows the recursion going  up the tree combining solutions  note that the input sizes at each node  would be the same for the recursion going  down the tree breaking into sub-problems  cs --    recursion trees for solving time- complexity recurrences   when using recursion trees to solve for time complexity  though we don't need quite that much information   we do need the structure showing how the algo divides and  re- combines its inputs   we do need the input size at each node   we do not need details about exactly what  the input is at each node   what we need for each node of the tree   input size at each node   a way to represent the work done i e  the runtim e at that node of  the tree  not including any other work done above or below i t recall asymptotic  complexity is in terms of  input size n not individual  inputs of a given size  let's do an example  recursion-tree method   an example  mergesort  tn   n    t n if  n tn  sorting both halves       n merging otherwise         what's the cost at each  tree-level i e  not  counting levels below it what's the recursion  tree structure  cs --    recursion-tree method   an example  mergesort  tn   n    t n if  n tn  sorting both halves       n merging otherwise         what's the cost at each  tree-level i e  not  counting levels below it what's the recursion  tree structure set up a tree to  total up the work  done by the  algorithm  tree structure for complexity analysis corresponds to tree of  recursive calls by the algorithm  total work by the algorithm sum of work at all lev els of the tree  recursion-tree method   an example  mergesort  tn  tn   tn  tn   tn   tn   tn  t   t   t   t   t   t   t   t  n tn   k n  n  k n   k n                 log n n log n    t n if  n tn  sorting both halves       n merging otherwise         recursion tree for algorithm  total work done  cs --    recursion tree exercises   use the recursion-tree method to solve the following  recurrences for n     tn  tn  n if n    if n    assume n is a power of    tn  tn  n if n    if n    assume n is a power of    tn  tn  n if n    if n   assume n is a power of    tn  tn  n if n    if n   assume n is a power of   keep in mind the formula for the sum of a geometric  series  from appendix a  in ci c n    c- for constant c neq   recursion tree exercises   use the recursion-tree method to solve the following  recurrences for n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     those last three examples illustrate three different cases    the amount of work per level increases with the most work done  at the leaves of the tree  in fact it increases geometrically this means see me for a proof if  you'd like the total amount of work is work done at leaves  cs --    recursion tree exercises   use the recursion-tree method to solve the following  recurrences for n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     those last three examples illustrate three different cases    the amount of work per level increases with the most work done  at the leaves of the tree    the amount of work per level decreases with the most work  done at the root  in fact it decreases geometrically this means see me for a proof if  you'd like the total amount of work is work done at root  recursion tree exercises   use the recursion-tree method to solve the following  recurrences for n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     tn  tn  n if n    if n     those last three examples illustrate three different cases    the amount of work per level increases with the most work done  at the leaves of the tree    the amount of work per level decreases with the most work  done at the root    the amount of work per level is constant and there  are             lg n   levels in the tree there are lg n   levels in all three cases  really but it's of particular importance here note these three cases  are important we'll  come back to them on a  later slide 