CS   CS   Analysis of Algorithms Professor Eric Aaron Lecture  M W pm Lecture Meeting Location Davis  Business  Smaller Assignment  due already  Graded work will be returned to you in your Submit tedWork folder  Ill email the entire class when its been returne d  Smaller Assignment  out due Sept   Problem Set  out due Sept  For the semester please assume all PS and SA deadlines are pm on deadline day whether or not its explicitly stated in lecture CS   Business pt   Project  out today Please read the full project assignment Instructions are given there Please note projectspecific lateness policy on assignment sheet  Some key points about Proj  Deadline End of day pm on September   Part of it Asymptotic complexity analysis on meth ods in a Java classyoure given the source code  Part of it Analyzing and conjecturing about asymp totic complexity when youre given data from runtime performance not source code Project  is to be done in teams of  or   IMPORTANT By end of day Saturday Sept  one p erson from each team should email me and everyone on the team to let me know theyre teaming up  If youd like my help finding a team for you plea se let me know Time Complexity of Insertion Sort  Whats the time complexity of Insertion Sort  Our default is to look at the worstcase complexity of the algo on an input of size n So whats the worst case complexity Time complexity from adding cost  times In worst case tj j each time so Tn is order of n Plug in tj j  Note summation is same for c  c Wed say Insertion Sort is an n algorithm See CLRS Ch   pg  CS   Time Complexity of Insertion Sort  Whats the time complexity of Insertion Sort  Our default is to look at the worstcase complexity of the algo on an input of size n So whats the best case complexity Add up the  cost  times  for each row what do we get Time complexity from adding cost  times In best case tj  each time so This means Insertion Sort is linear in the best case But we dont consider it a linear algo because thats not its worst case time complexity Space Complexity of Insertion Sort  While were at it whats the space complexity of Insertion Sort  That is how much space is used beyond the storage  for the input CS   Space Complexity of Insertion Sort  While were at it whats the space complexity of Insertion Sort  That is how much space is used beyond the storage  for the input  Other than input A there are a few variables for storage j key i So constant space complexity and this is true in best case  worst case  and average case Space complexity constant CS   Back to Time Complexity  So that counted  We just counted numbers of operations for best cas e and worst case of Insertion Sort  How does that help us talk about which algorithms are faster than others  Big idea Consider time complexity on large input sizes n Lots of algorithms are usable on small inputs  The algorithms that are faster on large inputs are  the ones were going to consider fastest   but how do we define that for rigorous algorithm  analysis Well we kinda did those ciconstants werent super precise Introduction to Time Complexity Analysis of Algorithms Lets take the bigpicture view How in principle could we measure the time efficiency of an algorithm  Could use a timer or stopwatch or clock or calendar to measure how fast a program is on a given size of input  called empirical analysis  But that doesnt really measure the algorithm speed  How much clock time passes is dependent on things other than just the algorithm processor speed memory access speed et c  Better idea  Count how many operations an algorithm does on a given size of input as a measure of how long it takes  Assume some unit of time for each operation  This gives a measure of time usage ie speed t hat is dependent upon the algorithm as written  not external factors CS   Introduction to Time Complexity Analysis of Algorithms cont  But even that kind of counting depends on how an algorithm is implemented  If  the insertion sort idea is implemented with ev en minor differences  Operation count could change but the algorithm is the essentially the same independent of minor coding details  We dont want to say the algorithm has different speeds just because of many slightly different implementations  We want to discuss algorithm time complexity at a level a litt le bit more abstract than just a literal count of operations  If somehow we could capture the essential characte r of how many operations insertion sort takes   on input of a given size eg an array of size n  without getting caught up in small details Asymptotic Analysis  BigO Notation  With insertion sort if we gloss over minor details we can see the number of operations worst case is on the order of n ie it is cn  lower order terms   for some constant c where nis the size of the input  Definition An algorithm runs in time Ofn read order of fn means  There exist c  n  st  for all n n the running time of the algorithm is less than cfn  Basically that means that for every input big e nough the running time is less than a constant times fn  This running time measure captures some essential characteristic of an algorithm  O n algorithms differ from O n from O nlog n etc CS   Asymptotic Examples  In what BigO classes are the following  n    n n For the next one we use the shorthand that an algo rithm is in fn  Ogn if the running time is fn  tn for some  tn in Ogn Similarly for Ofn  Ogn  or other arithmet ic combinations  n lg n  On  O  On  Formal definition describes what we intuitively mean by not worrying about lowerorder terms Common complexity measures and how they relate to input sizes  Algorithms are sometimes described by their time complexity There are  Logarithmic algorithms  Quadratic algorithms  Exponential algorithms  Factorial algorithms  etc  To see which kind is fastest see how these functions grow with increases in the input size             e e    e e n log  n nnn CS   Conventional Wisdom about BigO Classes  If two algorithms are in different bigO classes then there seems to be something substantially different about their speed s  Even though for some small values of n an O n algorithm could be faster than an On  algorithm  It is nonetheless true that  ngrows faster than n  Thus an O n algorithm is in a relevant sense inherently slower than an On  algorithm  For an On algorithm called linear  Doubling the input size does what to the running t ime  Increasing input size by factor of  does what t o running time  For an On  algorithm quadratic  Doubling the input size does what to the running t ime  Increasing input size by factor of  does what t o running time  For an O n algorithm exponential  Doubling the input size does what to the running t ime Important Vocab see CLRS pg  These functions  of nhave very different orders of growth ie how fast they grow as ngets larger 