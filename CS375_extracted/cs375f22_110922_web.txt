cs   analysis of algorithms  professor eric aaron  lecture  m w pm  lecture meeting location davis   notes regarding these slides for   nov       i was ill and needed to miss class on nov    i am sorry about that inconvenience it's not a decision i made lightly   dale skrien very generously agreed to cover class for me   thank you dale   these are some slides i was prepared to use if i had been there   i gave them to dale as an overview of what he could cover   these notes do not perfectly match what happened in class    but i think they might still be a useful accompaniment to our nov     class meeting so i'm posting them anyway   i hope they're useful for you   as always please be in touch with questions  cs --     cs --     time complexity of  remove first occurrence of an element   how would you analyze the time complexity of this algorithm  this is something we haven't done before let's think it through  we analyze complexity as a function of input size as usual  let's let n stand for input size and tn stand for time complexity on input of size n  we need to figure out what tn is    what foundations or definitions can we follow   zen principles to help us   well it's recursive    so let's look at the base case and recursive case separately  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstlllremoveirestl  functions on llists  - firstl returns first - restl returns rest - consvl creates new llist with v as first and l as rest  assume all of these functions  are o they would be in  most implementations  cs --   recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases  return consfirstl  llremoveirestl    in the base case what is the input size                                                     and what is the runtime of the algo  recall that firstl restl consvl functions are all o  recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases  return consfirstl  llremoveirestl    in the base case what is the input size                                                     and what is the runtime of the algo  recall that firstl restl consvl functions are all o  base case    input size empty list n     runtime  do you see why    cs --   recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases  return consfirstl  llremoveirestl    in the base case what is the input size                                                     and what is the runtime of the algo  recall that firstl restl consvl functions are all o  base case    input size empty list n     runtime  do you see why  so we'd say t   to  express the base case runtime  recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove  algorithm llremovei l   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  let's just focus on the  recursive case for now  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases   base case t    return consfirstl  llremoveirestl   how about the recursive case what is the input size and runtime   recursive case we say input is size n as usual l has n elements  also it does some work other than the recursive call combined  do you see why     all of its other runtime is in its recursive call  how would we represent the runtime of   that particular recursive call    cs --   recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove  algorithm llremovei l   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  let's just focus on the  recursive case for now  if i  firstl  return restl   because llremove is recursive let's                                                  else  look at the base case  recursive cases   base case t    return consfirstl  llremoveirestl   how about the recursive case what is the input size and runtime   recursive case we say input is size n as usual l has n elements  also it does some work other than the recursive call combined  do you see why     all of its other runtime is in its recursive call      input size to recursive call n-  a list of  less element than l do you see why   how do we express the runtime of that call use our definition of t  recurrences for time complexity   of recursive functions   as an example of analyzing time complexity of recursive functions   let's stay with llremove  algorithm llremovei l   complexity of function of input size n   definition let tn stand for runtime  of llremove on list of size n   now we figure out what is tn  let's just focus on the  recursive case for now  if i  firstl  return restl   because llremove is recursive let's                                                  else  return consfirstl  llremoveirestl  look at the base case  recursive cases   base case t     recursive case tn  tn-    this may look unusual and recursive but it follows  cleanly from the previous slide  in the recursive case    it does some work other than the recursive call combined   do you see why   all of its other runtime is in its recursive call tn-     recurrences for time complexity   of recursive functions   putting all the pieces together so far there's more coming up   let's let n stand for input size and tn stand for time complexity on input of size n  we need to figure out what tn is    let's look at the base case and recursive case   separately  the base case prev  slide is t      what's the complexity in the recursive case tn  tn-    the time taken by everything but the recursive call is just  do you see why   and the recursive call is on input of size n-   so by our definition of function t complexity of the recursive call is tn-   algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  do you see how this  characterization of tn  exactly fits our  llremovel algo  return consfirstlllremoveirestl  let's put the pieces together  for n   t    for n     tn  tn-    that is a full definition of the  complexity of this algorithm  both the base case and the  recursive case  solving a time complexity   recurrence   let's focus on our definition of runtime function tn and how to use it   for n   t    for n   tn  tn-      important vocabulary   we say this definition of tn is a recurrence it defines tn in terms of itself   note that it follows good design principles for recursive definitions   it has a base case   its recursive case is defined in terms   of itself on smaller inputs   indeed the two parts together are   a complete definition of the runtime   but we're not done yet what's the   asymptotic complexity of llremove  algorithm llremovei l  see specification on prev  slide  if l     return l  else  if i  firstl  return restl  else  return consfirstl  llremoveirestl  cs --     solving a time complexity   recurrence   let's focus on our definition of runtime function tn and how to use it   for n   t    for n   tn  tn-      important vocabulary   we say this definition of tn is a recurrence it defines tn in terms of itself   to find the asymptotic complexity represented by this recurrence we need   to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on   successively smaller arguments  we know tn  tn-   that's in the definition but we similarly know from the definition what tn- is what is it  solving a time complexity   recurrence   let's focus on our definition of runtime function tn and how to use it   for n   t    for n   tn  tn-      important vocabulary   we say this definition of tn is a recurrence it defines tn in terms of itself   to find the asymptotic complexity represented by this recurrence we need   to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on   successively smaller arguments  tn    tn-      what does tn- equal according to  the recursive case of the definition of  the recurrence above  cs --     solving a time complexity   recurrence   let's focus on our definition of runtime function tn and how to use it   for n   t    for n   tn  tn-      important vocabulary   we say this definition of tn is a recurrence it defines tn in terms of itself   to find the asymptotic complexity represented by this recurrence we need   to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on   successively smaller arguments  tn    tn-    tn-      tn-         in this step we replaced tn- with its definition from the  recursive case from above tn-  tn-     next step we'll continue unwinding by replacing tn-  solving a time complexity   recurrence   let's focus on our definition of runtime function tn and how to use it   for n   t    for n   tn  tn-      important vocabulary   we say this definition of tn is a recurrence it defines tn in terms of itself   to find the asymptotic complexity represented by this recurrence we need   to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on   successively smaller arguments  tn    tn-    tn-      tn-     tn-       tn-          do you see a  pattern  in general unwinding stops at the base case of the definition of tn    when will this recurrence's unwinding reach its base case  cs --     solving a time complexity   recurrence   let's focus on our definition of runtime function tn and how to use it   for n   t    for n   tn  tn-      important vocabulary   we say this definition of tn is a recurrence it defines tn in terms of itself   to find the asymptotic complexity represented by this recurrence we need   to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on   successively smaller arguments  tn    tn-    tn-      tn-     tn-       tn-         t  n   what does this equal use the base case   definition above  solving a time complexity   recurrence   let's focus on our definition of runtime function tn and how to use it   for n   t    for n   tn  tn-      important vocabulary   we say this definition of tn is a recurrence it defines tn in terms of itself   to find the asymptotic complexity represented by this recurrence we need   to solve it come up with a closed non-recursive form for tn    let's try unwinding the recurrence plugging in the definition on   successively smaller arguments  tn    tn-    tn-      tn-     tn-       tn-         t  n    n  n  so llremove is a tn  n algorithm solved  cs --     cs --     time complexity of mergesort   using recurrences   mergesort is a classic recursive algo and recurrences are   an essential technique for time complexity analysis   what would a recurrence be that represents the time   complexity of mergesort  so let's define runtime function tn  as a recurrence for mergesort recall that recurrences   give a base case for tn  give a recursive case for tn  are solved to get asymptotic   complexity for the recursive algo  let's start with the base case  what is the input size in the base case  for this mergesort algo and what is runtime on that input  time complexity of mergesort   using recurrences   mergesort is a classic recursive algo and recurrences are   an essential technique for time complexity analysis   what would a recurrence be that represents the time   complexity of mergesort  so let's define runtime function tn as a  recurrence for mergesort recall that recurrences   give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for   the recursive algo  base case p  r  when p  r input size is   t    time complexity of mergesort   using recurrences   mergesort is a classic recursive algo and recurrences are   an essential technique for time complexity analysis   what would a recurrence be that represents the time   complexity of mergesort  so let's define runtime function tn as a  recurrence for mergesort recall that recurrences   give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for   the recursive algo  recursive case let n stand for the input size r-p tn   what work is done in the recursive case recall that merge is n  cs --     time complexity of mergesort   using recurrences   mergesort is a classic recursive algo and recurrences are   an essential technique for time complexity analysis   what would a recurrence be that represents the time   complexity of mergesort  so let's define runtime function tn as a  recurrence for mergesort recall that recurrences   give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for   the recursive algo  recursive case let n stand for the input size r-p tn   recursive calls  merge n  other stuff on lines    what work is done in the recursive case recall that merge is n  time complexity of mergesort   using recurrences   mergesort is a classic recursive algo and recurrences are   an essential technique for time complexity analysis   what would a recurrence be that represents the time   complexity of mergesort  so let's define runtime function tn as a  recurrence for mergesort recall that recurrences   give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for   the recursive algo  recursive case let n stand for the input size r-p tn   recursive calls  merge n  other stuff on lines       recursive calls  n  we're not done yet  how much work is done in the  recursive calls  cs --     time complexity of mergesort   using recurrences   mergesort is a classic recursive algo and recurrences are   an essential technique for time complexity analysis   what would a recurrence be that represents the time   complexity of mergesort  so let's define runtime function tn as a  recurrence for mergesort recall that recurrences   give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for   the recursive algo  recursive case let n stand for the input size r-p tn   recursive calls  merge n  other stuff on lines       recursive calls  n   we'll simplify by assuming each recursive call is on input size n  we'll use our definition of t to express the runtime of each recursive call  time complexity of mergesort   using recurrences   mergesort is a classic recursive algo and recurrences are   an essential technique for time complexity analysis   what would a recurrence be that represents the time   complexity of mergesort  so let's define runtime function tn as a  recurrence for mergesort recall that recurrences   give a base case for tn  give a recursive case for tn  are solved to get asymptotic complexity for   the recursive algo  recursive case let n stand for the input size r-p tn   recursive calls  merge n  other stuff on lines       tn  n   we'll simplify by assuming each recursive call is on input size n  we'll use our definition of t to express the runtime of each recursive call  cs --     cs --   time complexity of mergesort   using recurrences   let's put all the pieces together   let's let n stand for input size and tn stand for time complexity on input of size n  we need to figure out what tn is    let's look at the base case and recursive case   separately  the base case prev  slide is t      what's the complexity in the recursive case tn  tn  n  the time taken by everything but the  recursive calls is n do you see why   and we simplify and say each recursive call is on input of size n   so by our definition of function t complexity of each recursive call is tn   do you see how this tn  exactly fits our mergesort algo  let's put the pieces together  for n   t    for n     tn  tn  n  that is a full definition of the  complexity of this algorithm  both the base case and the  recursive case    solving recurrences   we'll cover three common techniques for solving   recurrences i e  getting  or o bounds on the solution   unwinding or backward substitution unroll the recurrence   until it reaches a base case then count  analyze the cost  represented  we already did an example of unwinding and we'll  do another one soon   recursion-tree method represent costs as nodes in a tree and   analyze total cost   master method solve recurrences of the form   tn  atnb  fn  unwinding  this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow    an example solve tn  tn  n  this is a simplified version of the recursive case of our  recurrence for mergesort but it's close enough to  capture the algo's time complexity   we already know what the answer is do you  remember the complexity of mergesort  let's go through the steps of solving it by unwinding  cs --     unwinding  this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow    an example solve tn  tn  n  what information is missing from this recurrence which we will  need to be able to solve it   unwind the recurrence by plugging in the definition on   successively smaller arguments  from the definition tn  tn  n   by that same definition tn  tn  n  tn  n   so by plugging that in tn  tn  n  n   what would the next steps be in this unwinding process   where would it stop  unwinding  this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow    an example solve tn  tn  n  what information is missing from this recurrence which we will  need to be able to solve it   unwind the recurrence by plugging in the definition on   successively smaller arguments  from the definition tn  tn  n  tn   tn  n tn   tn  n  tn  n tn  tn   tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n               do you see a pattern here and when does this unwinding end  cs --     unwinding  this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow    an example solve tn  tn  n   for a base case let's use t   or  if we want   unwind the recurrence by plugging in the definition on   successively smaller arguments  from the definition tn  tn  n  tn   tn  n tn   tn  n tn  tn   tn  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                  kkkktn tnkkkk  kn   kn tn tn   kn   kn               the k'th step shown here illustrates  the pattern that holds for any  relevant k  it can help with our  analysis to show this in our work  unwinding  this name may make it  sound more relaxing than it  actually is but as methods  for solving recurrences go  it's pretty mellow    an example solve tn  tn  n   for a base case let's use t   or  if we want   unwind the recurrence by plugging in the definition on   successively smaller arguments  from the definition tn  tn  n  tn   tn  n tn   tn  n  tn  n tn  tn   tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n  tn  n  n  tn  n                  kkkktn tnkkkk  kn   kn tn tn   kn   kn                     nt  lg nn  nt  lg nn  nt  lg nn  nt  lg nn     n lg n  the lg n term comes because the  recurrence unwinds lg n times  before hitting the base case do  you see why  cs --     cs --     recursion trees an overview  recursion trees can represent how a recursive algorithm   breaks input down into recursive calls on sub-problems   or equivalently combines recursive calls into a solution on the original   problem   here's an example from clrs mergesort   each node shows input size at that level of   recursive calls  here original input size  breaks into   sub-problems of size  etc    this example shows the recursion going   up the tree combining solutions    note that the input sizes at each node   would be the same for the recursion going  down the tree breaking into sub-problems  recursion trees for solving time-  complexity recurrences   when using recursion trees to solve for time complexity   though we don't need quite that much information  we do need the structure showing how the algo divides and re-  combines its inputs   we do need the input size at each node   we do not need details about exactly what   the input is at each node  recall asymptotic  complexity is in terms of  input size n not individual  inputs of a given size   what we need for each node of the tree   input size at each node   a way to represent the work done i e  the runtime at that node of   the tree not including any other work done above or below it  let's do an example  recursion-tree method   an example  mergesort             t n             t n            sorting both halves    n   merging  if   n    otherwise  tn  n  what's the recursion   tree structure  what's the cost at each   tree-level i e  not   counting levels below it  cs --     recursion-tree method   an example  mergesort             t n             t n            sorting both halves    n   merging  if   n    otherwise   set up a tree to   total up the work  done by the  algorithm  tn  n  what's the recursion   tree structure  what's the cost at each   tree-level i e  not   counting levels below it   tree structure for complexity analysis corresponds to tree of   recursive calls by the algorithm   total work by the algorithm sum of work at all levels of the tree  recursion-tree method   an example  mergesort             t n             t n            sorting both halves    n   merging  if   n    otherwise  tn  tn  tn  tn  tn  tn  tn  logn  tn  k  t  t  t  t  t  t  t  t  recursion tree for algorithm  n  n  n        k n  k        n   n logn  total work done  cs --     