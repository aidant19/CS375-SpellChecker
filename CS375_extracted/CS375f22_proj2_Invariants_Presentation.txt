analysis of algorithms  cs  fall   project   due in part by monday oct   and  in part by thursday nov     please see notes and descriptions below  project  algorithm design and explanation loop invariants exhaustive search and beyond  in this assignment you'll work in teams of four to design multiple algorithms to use loop invariants to understand and explain algorithms and to create and deliver a presentation about some of the algorithms you designed  the goals of this project are   to give you practice designing algorithms starting here with exhaustive search algorithms   and improving the efficiency of algorithms   to give you practice using loop invariants to explain algorithm correctness   to give you practice creating and giving a technical presentation and   to give you practice working with other students as a team   the project assignment  this project is a multi-part assignment with different deadlines for different parts the deadline for part  is oct   and the deadline for parts  is nov   see section  below  as an overview here are the parts of the project assignment as presented in class on oct      design exhaustive search algorithms your team will collectively design ex- haustive search algorithms for a variety of problems with specifications given below     improve time efficiency your team will pick one of the problems and make your  exhaustive search algorithm more efficient     reduction for the same problem chosen for part  above yes make sure it's the same one you will reduce that problem to one of the other problems given in part   this is a new topic for us more about it soon    create and give a presentation your team will present work from all three other parts of the assignment about the problem you chose for parts  and  above using loop invariants where appropriate to explain the correctness of your algorithms   there are things to do for each part of the assignment as described individually below      design exhaustive search algorithms  for this project your team will collectively solve eight problems with exhaustive search algorithms  then you will submit revised solutions for four of those problems one on which you will focus heavily including doing a presentation and three others for which your submission will be a simpler write-up  instructions are below but as always please be in touch with any questions    independent problem solving  your team has eight problems to solve grouped into three categories of related problems described in section  below  with four people in your team each of you should come up with exhaustive search algorithms to solve two of the eight problems under these constraints   each person in your team should solve two problems but they cannot be from the  same category    your team of four people should collectively solve all eight problems each person  solving two of the eight    once you've met as a team to divide the eight problems among the four of you please work fully individually on these exhaustive search algorithms not discussing them with anyone but your tas and prof  and not using any additional resources other than your clrs textbook  there is of course a reason for this more about this below  each individual on the team will individually submit their two algorithms to their sub- mitted work folder  this will be graded as a smaller assignment for the individual submit- ter  not part of the project grade and graded based on effort  full credit will be given for strong demonstrated effort regardless of whether or not the solutions are correct    team problem solving  once each team member has submitted their two algorithms your entire team should meet to discuss the algorithms  part of the point of this is to give and receive constructive feedback to  from teammates about algorithm design as you're reading over each other's work having not seen it before if you have worked together on the initial submissions it will diminish the value of this part of the project   then for your team's final project submission your team will work together to revise and write up algorithms for three of the original eight problems keeping in mind the following   your three problems must not include the problem on which you're doing your pre-  sentation    your three problems must include one from each category in section  below    each of your three algorithms should be presented as pseudocode with a short english description of how the algorithm works and a concise high-level analysis of its time and space complexity  you do not need to give a detailed correctness argument or use loop invariants for these three algorithms     for other parts of this project your team will also work on an algorithm for a fourth of the eight problems  as described in sections  your team will improve on the time efficiency of that algorithm you will come up with a solution for it using a reduction and you will give a presentation about it accompanied by an informative write-up that includes complexity analyses and the use of loop invariants for explaining correctness   to submit for this part of the project   by pm on monday october  each individual team member should submit a document containing exhaustive search algorithms for their two of the eight problems  standard file naming conventions apply please submit your typewritten answers in a pdf file named cs projstage userid pdf where userid is replaced by your full colby userid and submit it to your submittedwork folder    by pm on thursday november  the entire team should submit a docu- ment containing their polished write-ups of algorithms for three of the eight problems as described above  please submit these typewritten answers in a pdf file named cs proj threealgos team initials pdf  additional instructions for submit- ting this threealgos document along with the remainder of your work for the project are given in section  below     improve time efficiency  as mentioned in section  your team will choose one of the eight problems on which to give a presentation and focus for the other parts of this project  in the remainder of this project assignment i'll use the variable name p to refer to the problem on which your team chooses to focus just so that there's a name for it   after your team has worked together to arrive at a good exhaustive search solution for problem p in your work for part  of the project your next step will be to improve upon the time efficiency of that exhaustive search solution   in general not just for this project but in general for algorithm design there are a few  ways to think of improving upon an algorithm's time efficiency  they include    you can make it somewhat faster with small-ish changes that streamline but do not  substantially redesign the algorithm or change its asymptotic complexity class     you can make it much faster with a substantial redesign perhaps even giving a new  algorithm altogether which might even improve its asymptotic complexity class     you can focus on special cases of the input that can be solved very efficiently  that is instead of coming up with a more efficient solution that works for all possible inputs in the problem's specification come up with a solution that is much more efficient i e  a better asymptotic complexity class for some of the possible inputs   for example imagine that you've solved a problem with this input specification  input k a positive integer    but you then come up with a much faster algorithm that will work only when k is an even number  that faster algorithm does not meet the original problem specifications but it is an improvement in the special case of an even integer input   if a note smaller input sizes are rarely considered special cases in this sense  suggested improvement is it's the same algorithm but it's super-fast on small inputs that likely is not actually a useful improvement  please see me if your team has a suggested improvement that requires looking at only very small inputs to confirm that it's worthy of including in your project write-up  presentation  for this project your team will come up with improvements upon the efficiency of your original exhaustive search algorithm for problem p  you are encouraged to think of improve- ments in terms of the three ways listed above and you are especially encouraged not to restrict yourself to only the first or second of them special-case improvements can be very helpful even on very simple-seeming special cases  there are no fixed criteria for this project about exactly how much you must speed up your initial exhaustive search algorithm or with the special cases approach how broadly applicable your improvements might be to cover as many cases as possible  your team can also propose up to three algorithms or modifications that improve the efficiency of your original algorithm for problem p although submitting three improvements is not necessarily better than one  ultimately your team will earn more credit on this part of the project for improvements that show more depth of thought about the problem and its solutions achieve greater time efficiency apply more broadly to possible inputs and are more thoroughly and helpfully analyzed and described but in some cases one substantial improvement might achieve that better that three small ones  i hope these criteria make intuitive sense to you  as always please feel free to ask me questions  hint you are advised not to try to come up with polynomial-time solutions for the general cases of any of the eight problems presented  you might however create polynomial time solutions for special cases which you could choose to include in your write-up  presentation  to submit for this part of the project in your presentation for this project your team should present not only your original exhaustive search algorithm for problem p but also your improvements to it  in the write-up that accompanies your presentation please include the following   a full description of your exhaustive search algorithm for problem p including a short english description of it pseudocode for it a concise and convincing correctness argu- ment for it using loop invariants to establish correctness and a concise high-level complexity analysis for it    english descriptions of each improvement  each description should include  sen-  tences about how you came up with the ideas behind that proposed improvement    pseudocode showing what each improvement does    a concise high-level complexity analysis showing how much each improvement actually improved the time efficiency of the original exhaustive search algorithm  although you do not need to use formal definitions of asymptotic complexity in your analysis you might want to use some part of them in particular if your improvement doesn't    change the asymptotic complexity class you might describe its improvement in terms of a lower leading constant for complexity analysis   you do not necessarily need to give a separate correctness argument for your improvements although if they affect the loop invariants your team previously used to show correctness of the exhaustive search algorithm you do need to show that the improvements also solve the problem correctly which could involve a modified loop invariant   more details about your presentation and its write-up are in section  below    reduction  sometimes we can incorporate solutions to previously solved problems as subroutines in an algorithm we're designing  for this project your team will do that in a specific way you'll reduce problem p to another problem   informally in general reducing problem a to problem b means creating an algorithm that if you plugged in a subroutine that solved problem b would immediately be able to solve problem a the algorithm reduces the task of solving problem a to the task of solving problem b  we'll call such an algorithm a reduction from a to b   as a concrete very simple example which we also went over in our oct   class  meeting consider problem a with these specifications  input list l  c c       cn of numbers  output true if the first element of l c is  false otherwise   and consider problem b with these specifications  input list m  d d       dk of numbers  output true if the last element of m  dk is  false otherwise   for these problems a reduction from a to b would take some input l remember this reduction is an algorithm for some problem a so it has to take an input intended for a  and create a new list m  c that contains only the first element of l  then the reduction would use m as input to a subroutine that solved problem b  if that subroutine returned true that would mean c   do you see why which in turn means that the first element of l is  so the reduction solving a should return true  on the other hand if that subroutine for b returned false on input of list m  that would mean c is not  so the reduction solving a should return false   there are other possible reductions that could have worked for instance m could in- stead have been created as m  cn       c built from all elements of l in reverse order rather than just a list with one element the rest of the reduction would have been exactly the same  for this project your team just needs to present one correct reduction  please note again that this is a very simple example your work for this project may not be quite this simple  for this project your team will create a reduction from problem p to any other of the eight problems given in the project  here is the specific way to think of it for this assignment   an all-powerful creature has bestowed upon you a wonderful gift of magic they've given you seven magic subroutines one for each problem in section  other than p  that will solve each problem in o time to use one of these magic subroutines just    give it some input that matches the input specifications for the problem and then it will instantly give you a correct true or false answer for that input to that problem   there's a catch though you only get to use one of these magic subroutines any one you choose but only that one and you only get to use it once  after that all seven subroutines disappear   your task is to write a new algorithm to solve problem p that makes use of the magic subroutine of your choice  it shouldn't be an exhaustive search algorithm anymore the magic subroutine can do the hard work of exhaustive search in fact if you are careful in choosing and employing the magic subroutine you could even come up with a polynomial time algorithm for problem p recall from lecture that a polynomial time algorithm is one that is onk for some constant k  this is much faster than any exponential- or factorial-time algorithm even a large polynomial like n has a rate of growth much slower than n   just to give a name to the problem you choose to reduce p to let's use variable q to refer to that problem i e  you'll using the magic subroutine that solves problem q as part of your reduction from p to q  your reduction should thus transform any possible input p for problem p into an input q for problem q such that when you get a true or false answer about input q for q you can use that to come up with a correct true or false answer about input p for problem p   for this part of the project in addition to creating the reduction as described above you  will also do all of the following   analyze the time complexity of your reduction under the assumption that the solution for q comes in o time  for maximal credit your reduction should be in polynomial time onk for some k but don't worry about what constant k you use  every correct polynomial time reduction will be equally good for this project   include the reduction in your presentation see section  below  be sure to include problems p and q you're reducing from and to a short description of your reduction algorithm pseudocode is not required though you may include it if you think it helps your presentation a short explanation of correctness and a short complexity analysis    describe the reduction in the write-up document accompanying the presentation  again state the problems p and q you're reducing from and to and give a helpfully complete description of the reduction an english description is required pseudocode is optional along with a short explanation of correctness and your complexity analysis of the reduction   your explanation of correctness does not need to use loop invariants your reduction will probably be straightforward enough that loop invariants aren't required  if your team thinks loop invariants might be a good idea to use though feel free to do so or feel free to ask me about it  important note a correct reduction must be exactly consistent with the input  output specifications for both p and q  for full credit your explanation of correctness should explicitly refer to those specifications     your presentation and accompanying write-up document will contain all the work you need to submit for this part of the project  please make sure your reduction is clearly and concisely described in the presentation itself and all helpful details for understanding the reduction are included in the write-up  hint see section   for a hint that might or might not depending on your approach be useful for reductions involving problems in the social networks category    create and give a presentation  at this point your team has done a lot of work on problem p  let's hear about it  your team will give a technical presentation about the algorithms you've created for problem p  for your presentation create slides in powerpoint google slides or some other application of your choice and take  minutes to present all of the material needed  presentations that are too long or too short may not receive full credit too short often indicates that some important material was not well presented too long often indicates that additional preparation would have resulted in a more effective talk so it is recommended that you target a  minute presentation  if you think your talk will be much longer or shorter than that please discuss that with me i will be happy to help you find a good balance for your presentation   the default expectation is that you will record your presentation as a screen recording in zoom  if you believe another option would be better for your team please see me about it as soon as possible  this is a team presentation and a class assignment so ideally the entire team would learn about all parts of the topic being presented and not only would the workload be balanced among team members but it would also appear balanced to viewers  for that reason your presentation should consist of each person presenting for roughly  minutes at a time followed by a different teammate so for example in a roughly  minute presentation each person on a four-person team would take two non-consecutive shifts of presenting for roughly  minutes each  this structure might require a conceptual topic to be split among multiple individuals in the presentation due to the impositions of time limits but that's part of the pedagogical benefit of this it encourages more people to engage with more different parts of the topic being presented  important note presentations not following this structure will not receive full credit for this assignment  if there are questions about what's expected in terms of the division among teammates of time spent presenting please let me know  here are some things you should include in your presentation not necessarily in this  order  your exhaustive search algorithm for your exhaustive search algorithm please include   an accessible description of the problem p you solved    a high-level summary of your algorithm and how it works    a short example that you step through to give your audience a sense of what problem p is and how your algorithm works  it may be appropriate to only step through a part of an example instead of an entire one but you should do enough to fully illuminate how your algorithm works for your audience      pseudocode of the algorithm along with a correctness argument using a loop  invariant    a complexity argument of the algorithm including what the worst-case and best- case complexities are and how much space is needed beyond the original input   your improvements to your exhaustive search algorithm for each of the improve-  ments you're presenting please include   a high-level description of the improved algorithm    a short example that you step through to give your audience a sense how the improvement differs from the original exhaustive search algorithm  once again you may not need to go through a full example but you should do enough to illuminate the differences in your improved algorithm    pseudocode of the improved algorithm along with a correctness argument  as noted above you need not use loop invariants for this though you could if you thought it was necessary but you do need to give a concise and convincing correctness argument  you can refer to your original exhaustive search algorithm and its correctness without re-explaining them    a complexity argument of the algorithm including what the worst-case and best- case complexities are and how much space is needed beyond the original input    a comparison of the complexity of your improved algorithm with that of your  exhaustive search algorithm   your reduction algorithm for your reduction please include   an accessible description of the problem q you're reducing to    a high-level description of the reduction algorithm that solves p including how  it uses the subroutine for q in that solution    a short example to show your audience what the reduction does transforming input to p into input to q and using output from the subroutine for q to get a correct answer on the input to p    pseudocode of the reduction along with a correctness argument  as noted in section  above this will involve referring to the specifications of p and q  you need not use loop invariants for this just give a concise and convincing correctness argument that the reduction meets specifications and solves p correctly assuming the subroutine solves q correctly  you can refer to your original exhaustive search algorithm and its correctness without re-explaining them    worst-case time complexity and space complexity arguments for the reduction  assuming the subroutine for q has o time and space complexity  magic  you should assume that your audience is at the level of cs students who are familiar with asymptotic complexity and loop invariants but are not yet experts with them  for example assume that your audience knows a set of size n has n subsets a list of length n has n per- mutations and all about the relative growth rates of functions used in asymptotic complexity including knowing what polynomial time means but would need to be walked through details involving leading constants and n thresholds in definitions of asymptotic complexity     you should also assume your audience has no previous knowledge of your algorithms or any problems involved and they may not quickly grasp any subtleties   to help prepare for your presentation please look through the documents linked from  cs's project assignments page   some general advice on how to give good technical presentations dale skrien shared  this with his classes and i am passing it along to you   a tutorial on screen recording with zoom from colby academic its    advice on setting up a good environment for a web conference using zoom from colby academic its  i'm not sure how useful this will be but i'm including it just in case   your accompanying write-up in addition to the presentation itself your team will create an accompanying write-up document which should enable your audience to under- stand the highlights of your presentation even if they do not see your talk  this document must be typed submitted in pdf and contain some important details that you may not have time to include in your talk itself  for example some small but important details of complexity arguments might not fit in the  minutes of your talk but they can be included in the write-up  for full credit your write-up must be polished well formatted for a professional technical presentation easy to read and free of grammatical errors   please see individual sections above for more information about details to include in your presentation write-up about the exhaustive search improvements and reduction algorithms  depending on the margins  font size  etc  of your document your write-up should probably be  pages in length  please keep it as concise as it can be while still containing all relevant information  if your write-up is running longer or shorter than that range please see me to check whether it contains unneeded material or too little material write-ups that are much too long or too short are not maximally effective and may not receive full credit   dress rehearsal as part of this project please schedule a dress rehearsal with me  this should be a live in-person presentation rather than on zoom the intent is to be as effective as possible in giving feedback on the organization and content of your talk rather than on using zoom technology  as in our class meetings masks will be required for our dress rehearsal meeting  if that will be problematic for any of your teammates please let me know plan on  minutes for the dress rehearsal  come to the dress rehearsal already having practiced your talk with your slides ready and your write-up ready for me to look at while you're presenting the rehearsal is a dress rehearsal not a draft rehearsal   so that the dress rehearsal time can be used as effectively as possible you are strongly encouraged to record a draft rehearsal  practice run of your talk beforehand and do a self- evaluation of how it went identifying areas of strength and room for improvement  time permitting i will be happy to give feedback on that recording during our appointment time please note there will be significant deductions to your grade if your eventual project submission includes a poor presentation including things like poor organization poor clarity of speaking or poor knowledge of the material so please use your draft rehearsals and our dress rehearsal time wisely to polish your work   i expect to schedule all dress rehearsal appointments for the afternoons of friday oct   and saturday oct    please email me to set up an appointment and please be as flexible as possible with your availability for scheduling those will be very busy days    some suggestions for getting audiences engaged in a presentation  note from your prof  dale skrien gave these suggestions to his students for his presen- tation assignments  i'm not sure that they all fully apply to this presentation but in the interest of giving you good advice about technical presentations in general i'm passing them along to you    get the audience to care about the subject  for example get the presentation started  by asking a question whose answer the audience cares about    keep examples simple and focused  don't make the audience think about irrelevant  things    use conversational tones in presentations  use i me and we so that the lis-  tener's brain thinks it's in a conversation    garr reynolds the author of presentation zen says the principles and techniques for creating a presentation for a conference or a keynote address have more in common with the principles and techniques behind the creation of a good documentary film or a good comic book than the creation of a conventional static business document with bullet points    something to think about regarding your presentation also from garr if the au- dience could remember only one thing and you'll be lucky if they do what do you want it to be  please feel free to ask me questions about them if you'd like   submission instructions  deadline pm oct   for the individual work in section  as described in that section every individual should submit typewritten answers in a pdf file named cs projstage userid pdf where userid is replaced by your full colby userid and submit it to your submittedwork folder   deadline pm nov   for all of the group work in this project a designated sub- mitter from each team should submit four items one to their google drive submittedwork folder and three by emailing them to me  the file to submit to the submittedwork folder of the designated submitter   a document containing their polished write-ups of algorithms for the three problems solved for section  as described above  please submit these typewritten answers in a pdf file named cs proj threealgos team initials pdf where initials is replaced by the initials of the team members in the group in the team assignments  e g  if eric aaron and stephanie taylor were the teammates the file from that team would be called cs proj threealgos team ea st pdf     the items to email to me eaaroncolby edu   a pdf file with all of the slides used for the presentation  please put two slides per  page as is done for cs course lecture notes and name the file cs proj slides team initials pdf    the write-up document that accompanies your presentation which should be a pdf  file called cs proj writeup team initials pdf    a video file or link to it of your presentation  please put it in your google drive  space if it's too large to simply include in an email  please name the file cs proj presentation team initials mp  note the preferred mp format  please let me know as soon as possible  if for any reason you cannot submit an mp video  lateness policy to keep pace with the project assignments in cs it is important that this assignment be turned in promptly  for this project there will be a deduction of   for each day late i e    deduction for submitting up to  hours late   deduction for submitting more than  hours late up to  hours etc up to a  deduction for submitting up to  days  hours late  after  days late submissions will receive a  deduction  please submit your work promptly  as always extenuating circumstances will be considered please contact me as soon as  possible if any extenuating circumstances are impeding your work on this project     the eight problems to be solved  below are the eight problems to be solved divided into three categories  note that each of the problems is a decision problem it asks for a true  false answer to be given   for each of the problems below in all three categories your exhaustive search algorithm will need to look through either all subsets of a set or all permutations of a list  for your work please assume that you can use algorithms to create the relevant lists for your exhaustive search meeting the specifications given here the same as those in our lecture notes and with the time and space complexities given here   generate-all-subsets you may use a generate-all-subsetss algorithm that has time complexity n  n and space complexity n  n on input s of size n meeting these specifications  input s  s s s        sn a set of n elements output l a list of all subsets of s   generate-all-permutations you may use a generate-all-permutationsl al- gorithm that has time complexity n  n and space complexity n  n on input l of size n meeting these specifications  input l  s s s        sn a list of n elements output p sl a list of all permutations of l  note that you are not told how these algorithms work and they may not be identical to the ones we derived in class you should just assume that they exist for your use and meet these specifications   in addition here are some reminders about sets and graphs that might be useful   the specifications for some of the problems below involve sets  please recall that by the definition of a set no two values in a set can be equal to each other  all of the specifications were written to be consistent with this definition    the specifications for some of the problems below involve graphs  every graph g is defined as a combination of a set v of vertices in the graph and a set e of edges that connect some or all or none of the vertices in the graph for short we say g  v e  see clrs appendix b  pg   for more about graphs and as always please feel free to ask me any questions about definitions regarding graphs  the following sections give the three categories containing the eight problems to be solved     category taking stuff  the problems to be solved in this category are    fair share you and a friend are in a room with n valuable items with values c c       cn and you want to take all of them but only if you each take exactly the same value with you  is that possible with the items in front of you    the fair-share problem  input a set c  c       cn of n positive integer values the values of the n items  output true if there exists a subset s of c for which the sum of the values in s is exactly the sum of the values not in s false otherwise   for example if c      a correct algorithm for fair-share would return true because there's a set s    where the sum of the values is  and the sum of values not in s is       on the other hand if we consider set c        there is no set s of values from c that could equal the values not in s try it no subset of c works for these values so a correct algorithm would return false     price is exactly right you're in a store with n items with costs c c       cn and you have an amount v to spend on these items  can you spend exactly v on some or all of the items from this store  the price-exactly-right problem  input a set c  c       cn of n positive integer values the values of the n items and a positive integer v   output true if there exists a subset s of c for which the sum of the values in s is exactly equal to v  false otherwise   for example if c      and v   a correct algorithm should return true because there exists subset c     for which the values add up to   that's not the only subset with values that add to  but one is enough for the algorithm to return true  on the other hand for the same c      if v   there is no subset s of c for which the values of s could add up to exactly      book bag you're at a used book sale where there's a deal available if you pay a flat fee let's call the fee amount k they give you a bag with a capacity of c and you can take as many books as you want as long as they all fit in that bag  the numbers k and c can be in whatever units you like as long as we're consistent throughout the problem it doesn't matter which they are  you can choose books to take from a set b  b       bn of n books and each book bi has a size sbi and a value vbi  is it possible to find some subset s of the books such that all the books in s could fit in the bag they give you and the total value of the books in s add up to more than the amount k that you'd pay for the deal  the book-bag problem  input set b  b       bn so that each bi has a positive integer size si and a positive integer value vi positive integer capacity c positive integer fee k  output true if there exists a subset s  a       am of b for which the sum of the sizes m isai is less than or equal to c and the sum of the values m  ivai is greater than or equal to k false otherwise   for example let b  b b b where b has size  and value  b has size  and value  and b has size  and value   then if c   and k   a correct    figure  an example graph referred to in examples accompanying problem statements  figure taken from clrs   algorithm should return true on inputs b c k because the set of books b b has their total size equal to  less than or equal to c and their total value equal to  greater than or equal to k  for the same b and k however but c   a correct algorithm should return false one way to see this is that the greatest value possible for a set of books from b with total size less than or equal to  would be  from the subset b b and that's not greater than or equal to k     category social networks  in all of the problems in this category we'll be using graphs to represent social networks every vertex in a graph will represent a person and every edge between two people will represent that the people know each other  please assume graphs for problems in this category are undirected   the problems to be solved in this category are   clique a clique is defined to be a collection c  c       cj of people such that every pair of people in c know each other  because we're using a graph g  v e to represent the social network a clique is a subset c of the vertices of the graph for which every pair of vertices in c has an edge between them  c could in principle be equal to v  which would be a complete graph  the question given a number k is there a clique of size k in the social network we're studying  the clique problem  input graph g  v e positive integer k  v   output true if there is a clique c of size k in g false otherwise   for example in figure  the graph contains multiple cliques of size  such as the set     the set     is not a clique because  is not connected to      strangers  in the social network g  v e we will define a group of people s  s       sj to be strangers to each other when for every pair of people in s they do not know each other  because we're using graph g  v e to represent the social network a set of strangers is a subset s of the vertices of the graph for which no edge in e exists between any two people in s  s could in principle be equal to v  which would be a maximally sparse graph  the question given a number k is there a set of strangers s of size k in the social network we're studying    figure  an example graph referred to in examples regarding the complement of a graph  figure taken from clrs   the strangers problem  input graph g  v e positive integer k  v   output true if there is a set of strangers s where s has size k in g false otherwise   for example in figure  the set   is a set of strangers of size  there are also others but there is no set of strangers of size  for every three people in the graph there's a connection between some two of them  try it    network cover  in the social network g  v e we will define a group of people p  p       pj to be a network cover if across all the people in p  every social connection in the network involves at least one of the people in p   because we're using graph g to represent the social network a network cover is a subset p of the vertices in g such that every edge in e involves at least one person in p   the question given a number k is there a network cover p of size k in the social network we're studying  the network-cover problem  input graph g  v e positive integer k  v   output true if there is a network cover p where p has size k in g false otherwise   for example in figure  the set    is a network cover of size  there are also others but the set   is not a network cover because the connection between  and  is not covered by       hint this hint only applies to reductions section  not other parts of the project  when thinking about designing reductions involving the problems in the social networks category section   you might want to consider the complement of a graph as part of your reduction  by definition for a graph g  v e the complement of g is a graph g  v e where the vertices are the same as in g but the edges are all edges not in e  more precisely considering every edge in a graph as a pair of vertices e  u v  u v  v but u v  e  as a concrete example let g be the graph in figure  then there would be edges from vertex  to every other vertex in the complement g because none of those edges are in g but edge   would not be in g because there is an edge between vertices  and  in g   you don't need to use the complement of a graph in your reduction but you might want to in some cases  as always please feel free to talk with me about these concepts    category maps and touring  in the problems in this category we'll be using graphs to represent maps every vertex in a graph will represent a location and every edge between two locations will represent that we can travel between those locations in either direction  please assume graphs for problems in this category are undirected   for these problems we'll define a tour on a map g  v e a tour is a path that starts in some initial city c in v and then following edges in e passes through every other city in v exactly once before returning to c  for example in the map represented by the graph in figure  one possible tour is represented by the shaded edges the one from u to w to v to x and then back to starting city u  note that there are many possible tours through all cities on this map this is just one possibility   also for the problems in this section note that in a tour it doesn't really matter which city we indicate as the starting city since the tour goes through all of them exactly once before looping back to where it started its starting point could equivalently be anywhere for these problems  the direction also doesn't matter for the problems in this section because the graphs are undirected  for example the tour indicated by the shaded edges in figure  could be viewed as starting at city x and going x to v to w to u to x just as well as u to w to v to x to u   the problems to be solved in this category are    traveling salesman in this classic cs problem we start with a complete graph g  v e in which every pair of cities vi vj in v is connected by an edge in e  in addition to the graph there is a distance function d that gives a distance dvi vj between every pair of cities assume that the distance is the same in either direction so dvi vj  dvj vi for every pair of cities  it is our traveling salesperson's job to make a tour to start from their home city then follow edges in the graph to visit every other city exactly once before returning to their home city  the question given a number k is it possible to make a tour while covering total distance k or less  the traveling-salesman problem    figure  an example tour on a graph referred to in examples accompanying problem statements  here there are many possible tours through all cities on this map including one from u to w to v to x and then back to starting city u shown by shaded edges in the graph  figure taken from clrs   input graph g  v e distance function d as described above and positive integer k  output true if there is a tour of v having distance k or less false otherwise   for example in figure  the distance function d giving distances between cities is indicated by the number over each edge e g  dv x   and dx w    consider the map in that figure that distance function d and number k    a correct algorithm would return false because there is no tour of all those cities remember it has to end up back where it started with distance  or less  on the other hand with that map that distance function and k   a correct algorithm would return true indeed the shaded edges are a tour of distance  which is less than      hamiltonian tour unlike the traveling salesman example the touring company of hamilton does not start with a complete graph instead they start with some map g  v e that may or may not have edges between any two cities  there is also no distance function to be considered here all that matters is whether or not they can get from one city to the next   their goal however is to make a tour in the same technical sense of tour used in the traveling salesman problem to visit every city exactly once before returning home  the question given a map g  v e is there a tour in the map visiting each city exactly once before returning to the city from which it started  the hamiltonian-tour problem  input graph g  v e  output true if there is a tour in g false otherwise   for example in figure  there are many paths that are not tours in this sense  for example if a possible tour started at city  and then went to  and then  and then  it could not get to city  without going back to  along the way and that's not a tour in our sense of the word it would visit city  more than once before returning to where it started  nonetheless there is a tour through that graph for example it could go from  to  to  to  to  before going back to  so a correct algorithm would return true on that graph     