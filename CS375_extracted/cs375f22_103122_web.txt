CS   CS   Analysis of Algorithms Professor Eric Aaron Lecture  M W pm Lecture Meeting Location Davis  Business  Grading update  PS in progress  Expect PS out in next couple of days  Due no sooner than  week after its assigned  Project   First part due already  Other parts due Nov   Please note some restrictions on my schedule  I will not be available for dress rehearsals Tuesd ay or later  I expect to be traveling on Nov  and probably wo nt be on email or able to answer questions after noon on that day so please plan accordingly CS   Business Some notes on grading of projects  Grading on projects is in part as might be expect ed similar to grading of other papers in other nonCS courses  Overall for both presentations and writeups mor e credit will be given to submissions that demonstrate  Greater scope of work completed  Greater depth of insight in the work completed  Greater command of relevant concepts  Greater clarity completeness and effective commu nication of the work This is meant to be intuitivewhat youd expect to g et credit forbut please let me know if there are any questions about  grading criteria This is related to the idea that not all improvements to your exhaustive search algo are of equal value as noted on the project assignment Business Some notes on grading of projects  Grading on projects is in part as might be expect ed similar to grading of other papers in other nonCS courses  As expected credit will be given for work your team has done As always be sure to cite  credit every source of  assistance including your Prof TAs textbook and online sources  Be specific about contributions from other sources  so your audience can be certain about what work your team has done ie as oppose d to work taken from other sources  As expected credit is given for work done by your  teampresenting others work or ideas earns credit for the presentation but not fo r creating the work  ideas of others  As always please feel free to ask me gradingrela ted questions as you do your work on projects Its best to direct projectoriented questions to m e rather than to TAsTAs do not always have the context that will best help you complete t he project as intended  expected CS   Zen and The Art Of Algorithm Design  A couple of Generally Good Ideas principles to help you design your algorithms and their implementations  I might restate principle  as  Keep your foundations simple  I might restate principle  as  Let your definitions tell you what to do  Lets apply this to binary trees  The foundationsie relevant definitions and dat a structuresshould be as simple as possible while sti ll providing all needed functionality  Let the foundations guide the development and ana lysis of algorithms based on them CS   Definition of our IntBinTree Data Structure  Throughout CS we will sometimes refer to an IntBinTree data structure representing a binary tree of integers  In English wed say an IntBinTree is  Either empty  Or  an int called val  and two subtrees called left and right  that are also IntBinTrees  Programmers might be used to seeing it more like this Definition IntBinTree Empty or int val  the int value not empty intBinTree left  the left subtree intBinTree right  the right subtree Is this a good definition Consider Principle  Keep your foundations simple NOTE This definition may show up on HW too Is this definition equivalent to the English one above The fact that a tree could be empty is often implicit in many specifications Definition of our IntBinTree Data Structure  In English wed say an IntBinTree is  Either empty  Or  an int called val  and two subtrees called left and right  that are also IntBinTrees  To be unambiguous  and consistent with functional programming  about how we work with IBTs these will be the primitive functions defined on IBTs  val T returns the val element of an IBT T left T returns the left subtree of an IBT T right T returns the right subtree of an IBT TNOTE This definition may show up on HW too Well call them IBT s for short Important note valT leftT and rightT are functions that return values they are not fields of an object Because of this we cannot assign values to themeg valT   is not permittedFor CS these are the only ways to access val left right  So something like Tval is not permitted CS   Correctness of Recursive Algorithms Inductive Arguments  When arguing the correctness of a recursive algorithm the general form is that of an inductive argument  The explanation follows the structure of the algorithm  Show that the algorithms base case returns correc t output  Show that the recursive cases return correct outpu t under the assumption that all recursive calls retur n correct output  Here how would that work  How would we explain the base case The recursive case Just like when creating recursive codewe assume rec ursive calls work in the recursive case Algorithm LevelsT Input IntBinTree TOutput integer number of levels in T if T is empty return  else return maxLevelsleftT LevelsrightT   Correctness of Recursive Algorithms Inductive Arguments  When arguing the correctness of a recursive algorithm the general form is that of an inductive argument  The explanation follows the structure of the algorithm  Show that the algorithms base case returns correc t output  Show that the recursive cases return correct outpu t under the assumption that all recursive calls retur n correct output  As part of explaining recursive cases also explain how we know the algo terminates  Show arguments in recursive calls get closer to base case Just like when creating recursive codewe assume rec ursive calls work in the recursive case Algorithm LevelsT Input IntBinTree TOutput integer number of levels in T if T is empty return  else return maxLevelsleftT LevelsrightT   CS   Another IntBinTrees Exercise Search  The search problem on IntBinTrees asks if an int is anywhere in an IntBinTree  How would we write the problem specification for IBTSearch  What would be the input  What would be correct output  How would we design an algorithm to solve it  Would the algorithm be iterative or recursive  How would we argue its correctness Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree Another IntBinTrees Exercise Search  The search problem on IntBinTrees asks if an int is anywhere in an IntBinTree  How would we write the problem specification for IBTSearch  Input an int i and an IntBinTree T Output True exactly when iis in TFalse otherwise Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree Algorithm IBTSearchi T Input int I IntBinTree TOutput True exactly when iis in T False otherwise CS   Another IntBinTrees Exercise Search  The search problem on IntBinTrees asks if an int is anywhere in an IntBinTree  How would we write the problem specification for IBTSearch  Input an int i and an IntBinTree T Output True exactly when iis in TFalse otherwise Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree Algorithm IBTSearchi T Input int i IntBinTree TOutput True exactly when iis in T False otherwise if T  empty return False else if valT  i return True else return IBTSearchileftT or IBTSearchirightT  The last line uses the Boolean operator or  which is inclusive it is True when either or both operands are True Another IntBinTrees Exercise Search  The search problem on IntBinTrees asks if an int is anywhere in an IntBinTree  How would we argue correctness for IBTSearch  Inductively  Base case If Tis empty Some people might view this as having two base cases The definition of IntBinTree however has one base case empty tree I view the algo as following that definition Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree Algorithm IBTSearchi T Input int i IntBinTree TOutput True exactly when iis in T False otherwise if T  empty return False else if valT  i return True else return IBTSearchileftT or IBTSearchirightT  CS   Another IntBinTrees Exercise Search  The search problem on IntBinTrees asks if an int is anywhere in an IntBinTree  How would we argue correctness for IBTSearch  Inductively  Recursive case For nonempty T if i is in T its either at the root in left  or in right by defn thats all there is in a tree  So Some people might view this as having two base cases The definition of IntBinTree however has one base case empty tree I view the algo as following that definition Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree Algorithm IBTSearchi T Input int i IntBinTree TOutput True exactly when iis in T False otherwise if T  empty return False else if valT  i return True else return IBTSearchileftT or IBTSearchirightT  Another IntBinTrees Exercise Search  The search problem on IntBinTrees asks if an int is anywhere in an IntBinTree  How would we argue correctness for IBTSearch  Inductively  Does the algo terminate Ie does input get closer to a base case with each recursive call Hint Yes Its always a subtree  Some people might view this as having two base cases The definition of IntBinTree however has one base case empty tree I view the algo as following that definition Definition IntBinTree Empty or int val  int value intBinTree left  left subtree intBinTree right  right subtree Algorithm IBTSearchi T Input int i IntBinTree TOutput True exactly when iis in T False otherwise if T  empty return False else if valT  i return True else return IBTSearchileftT or IBTSearchirightT  CS   Break It Down Again  In general different ways of breaking down a problem into subproblems can lead to different algorithms  Different data structures by their definitions suggest different natural ways to break problems into subproblems  How would a binary tree suggest breaking a problem  into subproblems  How would a nodebased linked list suggest breakin g a problem into subproblems  How about for an array eg Mergesort vs  any other sort basically This isnt to say that for any given data structur e some approach is always applied This is just looking for common approaches and wha t makes them natural in context CS   Break It Down Again  In general different ways of breaking down a problem into subproblems can lead to different algorithms  Different data structures by their definitions suggest different natural ways to break problems into subproblems  How would a binary tree suggest breaking a problem  into subproblems subproblems on subtreeskinda one half at a time  How would a nodebased linked list suggest breakin g a problem into subproblems subproblems on lists one element shorter  How about for an array subproblems involve changing indices and iterating over indexed rangesindex access is centra l to arrays eg Mergesort vs  any other sort basically In all of these cases the foundationsthe definitio ns of the underlying structuresuggest that approach to breaking into sub problems Break It Down Again  In general different ways of breaking down a problem into subproblems can lead to different algorithms  Different data structures by their definitions suggest different natural ways to break problems into subproblems  How would a binary tree suggest breaking a problem into subproblems subproblems on subtreeskinda one half at a time  How would a nodebased linked list suggest breaking a problem into subproblems subproblems on lists one element shorter eg Mergesort vs  any other sort basically In all of these cases the foundationsthe definitio ns of the underlying structuresuggest that approach to breaking into sub problems In a very broad sense these represent the two major ways of thinking about recursion Size of subproblems either divided from tree or subtracted from list original input size CS   List Algorithms  Weve seen how the definition of a binary tree can guide the design of algorithms on binary trees  Many common algorithms are written on lists  How does the definition of a list guide the design s of those algorithms What are some difference between arrays and lists in this context CS   List Algorithms  Weve seen how the definition of a binary tree can guide the design of algorithms on binary trees  Many common algorithms are written on lists  How does the definition of a list guide the design s of those algorithms  Among the significant differences between an array and a list  Arrays are stored as contiguous blocks of memory lists when not simply extensions of arrays are nodebased  linked lists  Arrays have direct constanttime indexed access to any element lists require traversing a list to reach an element whic h is not constanttime  Because lists are nodebased it can be constantt ime to access the sublist of all but the first element as a distinct object What are some difference between arrays and lists in this context List Algorithms  Weve seen how the definition of a binary tree can guide the design of algorithms on binary trees  Many common algorithms are written on lists  How does the definition of a list guide the design s of those algorithms  For example consider the search problem on lists  There are multiple ways to approach designing an algorithm for this how might you design one  What can you say about the complexity of your algo rithm Input item i and list L Output True if i is an element of L False otherwise What are some difference between arrays and lists in this context CS   List Algorithms and Recursion  Lists as opposed to arrays can have nodebased defintitions  As part of that a List type is commonly defined recursively  How would you write a recursive algorithm to solve the search problem on lists  One possibility is shown here  How would we argue its correctness  Do you believe that it works correctly  What can we say about its complexity Input item i and list L Output True if i is an element of L False otherwise Algorithm recListSearchi L  see specification immediately above if L    return False else if i is L return True else return recListSearchiL This uses Pythonlike list slicing syntax to refer to all but the first element of L List Algorithms and Recursion  Lists as opposed to arrays can have nodebased defintitions  As part of that a List type is commonly defined recursively  How would you write a recursive algorithm to solve the search problem on lists  One possibility is shown here  How would we argue its correctness  Do you believe that it works correctly  What can we say about its complexity  List slicing cant be assumed to be constant time Input item i and list L Output True if i is an element of L False otherwise Algorithm recListSearchi L  see specification immediately above if L    return False else if i is L return True else return recListSearchiL This uses Pythonlike list slicing syntax to refer to all but the first element of L CS   List Algorithms Remove first occurrence of an element  Consider the problem of removing the first occurrence of an element from a sequence specified here for a list  How would you design an algorithm to solve this problem  Iteratively on arraybased lists  Recursively on nodebased lists  How would the complexity of this be different on a  list ie a linked list than on an array Input item i and list L  x   x nOutput If i x kand k is the smallest value for which i x k return x   x k x k   x nOtherwiseie when there is no k such that i x kreturn L Definition of our LList Data Structure  Throughout CS we will sometimes refer to an LList data structure representing a list of elements  In English wed say an LList is  Either empty  Or  an element called first  and an LList called rest representing all the elements after first Is this a good definition Consider Principle  Keep your foundations simple NOTE This definition may show up on HW too Is this consistent with your understanding of list structuresthat is linked list structures which are typically nodebased in implementation CS   Definition of our LList Data Structure  In English wed say an LList is  Either the empty list  Or  an element called first  and an LList called rest representing all the elements after first  To be unambiguous about how we work with LLists these will be the primitive functions defined on Llists  firstL returns value of the first element of an LList L  restL returns value of the rest sublist of an LList L  consvL a constructor function that takes an item v and an LList L and returns a new LList L such that  What do you think it might be NOTE This definition may show up on HW too What do you think the complexities of these functions are 